{zone-template-instance:ZFPROP:Proposal Zone Template}
{composition-setup}

{zone-data:component-name}
Zend_Db_Mapper
{zone-data}

{zone-data:proposer-list}
[Benjamin Eberlei|mailto:kontakt@beberlei.de]
{zone-data}

{zone-data:liaison}
TBD
{zone-data}

{zone-data:revision}
1.0 - 25 January 2009: Initial Draft.
{zone-data}

{zone-data:overview}
This component willl be an implementation of *DataMapper pattern* that tries to seperate Objects from their persistent separation to let you focus on the application more.

It will offer a huge range of features for handling all types of objects, versioning, relations, cascadading operations. Extension points are provided to make the component as flexible as possible. The data mapping will be based on a mapping syntax that has to be written out explicitly (or be autogenerated). Data Mapping is a crucial point for developing applications that are developed *Domain Driven*. This component will contrast the Table-Row-Data-Gateway pattern which is more useful for Transaction Script or Table Module patterns of the model. Its *core feature* is the *focus on the Entity as datastructure* in contrast to SQL as datastructure. DataMapper makes heavy use of *LazyLoading for relations* that the actual related objects with Proxies that act as if they were the real objects and *only upon request* load the required data from the database. This lazyloading can be done for single related entities, collections or for fields of an entity that contain huge data (BLOBs and Text fields). The lazyloading replacements make sure that every relation of an object can be traversed/accessed inside the application without thinking about if it was loaded before.

Why is a data mapper a good extension to ZF? Because Data mapper is an enterprise pattern, and gets really useful in domain driven design. Zend Framework is an enterprise application framework. Other data mapper implementations are ezComponents Persistent Object (which leans to much to SQL Tables imho rather than on a Entity Class as the central datatype) and the under development FLOW3 Framework (which handles Content Repository mapping).

The proposed data mapper solution will offer a generic solution and the possibility to extend certain parts of the mapper to match your needs perfectly. It will offer more flexibility for applications with complex business logic where a Table-Row-Data-Gateway will reach its limits faster. Using the DataMapper for an application as simple as a blog is nice, but rather overhead. This solution shines when you have more complex stuff going on.

In its datastructure for persistence mapping the component will try to *borrow concepts from Java Hibernate and the EJB 3 (Enterprise Java Beans) specification*, because they are proven solutions to this problem. We can profit from the experience that was cummulated over the last years in this community.

This proposal is a first step, a second might be a proposal for *Zend_Entity_Repository* which implements the repository and specification patterns to completly encapsualte domain logic from persistence. Zend_Repository might use adapter to offer access to Zend_Db_Table instances, Zend_Db_Mapper persistence sessions and even an adapter for In Memory Repositories which would significantly enhance Unit Testing of Domain Logic. It could also include adapters for another current propsal Zend_CouchDb. Implementing the repository on top of a functional mapper is peanouts though :-)

Additional further support to enhance this component would be integration with a Database Schema Component and different Tooling providers.

h5. Clarification of terms

*Entity* An entity is a class/object that encapsulates Domain Logic. It uses all object-oriented reference types like composition, aggregation and such to represent the state of business objects in memory. It has onlly little relation with the relational entity definition.

*Data Mapper* A class that maps entities into a relational database based on mapping defintions. It does that behind an API that hides the relational database. In short words: It maps the memory representation of objects into the database.

*Entity Manager* Single point of entry for calls to the underlying mapping persistence engine. It controls the entity definitions, unit-of-work, the mapping engine and it allows CRUD operations on those entities via load, save and delete methods. These methods accept SQL through the Zend_Db_Select Query object (only).

*Collections* Sets of entities are saved in collections. These are ArrayAccess and Iterator implementations. Implementing those as objects rather than simple PHP arrays allows for Lazy Loading of collections behind the scenes and offer a way for the data mapper to recognize which related objects have changed, are new or were deleted in a session.

*Repository* A repository completly hides the underlying persistence from the business domain, it does not allow for sql or query objects. It offers access to objects via Criteria objects that specifiy which objects may be retrieved. An extended repository allows saving and deleting of objects. Criteria are transformed into the concrete selecting language, SQL in the case of relational databases.

*Loader* Based on the definitiosn a loader implementation is selected for each entity to load the data from the database in the most efficient way.

*Persister* Inverted principle of the loader, based on the definition the persister knows how to persist an entitiy and its related entities.

h5. Proposing for two namespaces

For this proposal to be really useful in a generic context it should follow its primary terminology Entity for its frontline interfaces. This would seperate the mapper and database from the entities through the creation of a new package. The question is wheater to seperate those two into two namespaces "Zend_Entity" and "Zend_Db_Mapper". Personally I would put it all under a new Zend_Entity namespace but that might be misleading, becase Database usage is quite hardcoded and cannot be "generalized".

What is definetly required in my opinion is the definition of the following 3 interfaces in a new Zend_Entity package that other persistence layers might be using (to name a few CouchDB, XML Databases, Remote Webservice that manage models).

* Zend_Entity_Manager_Interface
* Zend_Entity_Interface
* Zend_Entity_Collection_Interface

I have changed the class tree to reflect the split between the two parts of the component and refered to this discussion here.

The *Zend_Entity* namespace should then be extended by a Repository Proposal would suggest interfaces and implementations
for *Zend_Entitiy_Repository*.

{zone-data}

{zone-data:references}
* [Martin Fowler: Data Mapper Pattern|http://martinfowler.com/eaaCatalog/dataMapper.html]
* [Martin Fowler: Unit Of Work|http://martinfowler.com/eaaCatalog/unitOfWork.html]
* [ezComponents Persistent Object|http://ezcomponents.org/docs/api/trunk/classtrees_PersistentObject.html]
* [FLOW 3 Persistence|http://flow3.typo3.org/documentation/reference/persistence]
* [Hibernate|http://www.hibernate.org]
* [Enterprise Java Beans 3 Specification|http://java.sun.com/products/ejb/docs.html]
* [Eric Evans: Domain Driven Design|http://www.domainlanguage.com/ddd/index.html]
{zone-data}

{zone-data:requirements}
* Zend_Db_Mapper *is NOT* a model proposal. It merely allows to save Entities (classes) persistent. See "Domain Model, Table Module or Transaction Script" Patterns in Fowler PEAA for a model.
* Zend_Db_Mapper *will* put the Entity (A Record Class) as Datastructure into the focus, not the where and how it is saved for persistance.
* Zend_Db_Mapper *will* lean to a Data Mapper like Hibernate, it will provide the most basic functionality but offer rich interfaces to extend it.
** It *will* take a Hibernate Mapping like syntax as basis to profit from the rich experience.
** It will have reasonable defaults, only deviations should be configured.
** It *will* provide a generic solution for the DataMapper pattern based on generic per entity data-mappers.
** It *will* provide full functionality to define relations between tables that are translated into object composition behind the scenes.
* Zend_Db_Mapper *will* provide extension points through modularity that allow to overwrite specific functionality of the mapper.
** It *will* strictly give responsibility of query building to subcomponents of the entity definitions such that developers can overwrite behaviour very simple (This compares to Doctrine behaviours)
** It *should not* hinder developers to implement Single-Table-Inheritence, Class Table Inheritence or Concrete Table Inheritence patterns and mapping of records onto multiple tables.
* Zend_Db_Mapper *will* include interfaces for Entity objects
** Simple entity objects will be supported via an interface, they are fully encapsulated from the database.
** Collections and object composition *will* make heavy use of behind the scences lazy loading to encapsulate object creation and domain logic without hurting performance.
* The developed utilities for mapping definitions *should* be take from or be re-integrated into Zend_Db_Table where possible to profit from DRY code.
* A UnitOfWork Interface will be provided that handles all write statements back to the database.
** A default implementation of UoW *will* be provided that works behind the scenes using spl_object_hash() to make objects unique.
{zone-data}

{zone-data:dependencies}
* Zend_Db_Adapter_Abstract
* Zend_Db_Select
* Zend_Loader_PluginLoader
* Zend_Loader_Autoloader_Resource
{zone-data}


{zone-data:operation}
*Steps of configuration:*
* For each object that is an Entity you have to create a definition file that describes the process of mapping this entity to the database.
* Each object that is an Entity has to be implemented. An interface has to be implemented that breaks up encapsulation of the entity for the datamapper.
* The Entity Manager will have to be initialized to be aware of the definitions. We should investigate in what way the ResourceLoader can help at this point.

*Steps of a session:*
* A new *Entity Manager* is initializing with a Database connection and the mapping definitions.
* The *Entity Manager* is a single point of entry that encapsulates the *Mapping* and *Loading* objects.
* The *Entity Manager* delegates all calls to the underlying concrete/generic mappers.
* You can load Entities through the *Entity Manager* via Primary Key or a Zend_Db_Select object.
* The *Entity Manager* return and accept *Entity objects* that are controlled a very simple entity interface
* The *Entity Manager* delegates saving, selecting, updating and inserting.
* When *Entities* are retrieved the *Mapping* Engine decides how relations and large fields should be handled in termns of LazyLoading.
* *Entities* do not include any database related code (except hidden lazy loading mechanisms through an Inner/Outer Iterator schema).
* Besides more or less transactionless work, the session allows access to a Unit Of Work that handles a complete transaction based on the users need.

*Additional detail on my currenct concrete implementation proposal ideas:*

1.) Concrete Type Mapper vs Generic Mapper: It will be allowed to overwrite the lowlevel mapper for a particular entity. By default all entities will use a powerful generic entity mapper, so that only when performance issues occour it should be relevant to write hard-coded sql by overwriting a mapper.

2.) The *Entity Manager* keeps track of all dependencies such as Db Adapter, the unit of work, identity map, entity definitions and the underying mappers. They are enforced to be "singletons" with small "s" inside that session. This allows to have a hand on memory management which is necessary with UoW and Identity Map.

3.) LazyLoading will primarily be implemented at the Collection level, which under circumstances can lead to the N+1 query problem. This can be prevented by using outer joins which might be generated when loading the root object. You could also define a "formula" field can also be used to inject subselect values into an object field.

4.) Cascaded saving, updating and deleting of objects will be supported by configuration, allowing to save an entity and automatically saving all or some of its related entities.

5.) The generic implementation of the mapper is possible by using the Visitor pattern with the definition objects of a table. Depending on the state and action the mapper injects all the related data into a visitor accept function of the definition property. That way complicated lazy loading, association and other stuff is encapsulated at the point where its information is stored. This pattern allows for the great flexibility for developers to build their own properties with special handling that only need to be attached to the table definition and work without changes on the session and mapper code.

6.) As for every tool that tries to make you think less about the database this mapper implementation could cause considerable Database overhead, when used wrong. Therefore the documentation should by default include a section about pitfalls, performance and best-practices for special cases. To investigate the mapper behaviour I would like you to propose some object designs that we have to test in their persistent form.
{zone-data}

{zone-data:milestones}
* Milestone 1: Proposal
* Milestone 2: Early Prototype and add more Use-Cases from it
* Milestone 3: Reviews and Zend acceptance.
* Milestone 4: Unit-Tests of decided upon interfaces and API
* Milestone 5: Collection of crazy but probable Domain Designs for Scenario Unit Tests
* Milestone 6: Refactoring & Development to meet both API and Scenario Tests
* Milestone 7: Documentation
* Milestone 8: Extension Phase: Add more features via the Table Definition API
{zone-data}

{zone-data:class-list}

Why two namespaces? I discuss some requirements of that in the Component Overview section.

Core classes (Public API)
* Zend_Entity_ManagerFactory
* Zend_Entity_Manager_Interface
* Zend_Entity_UnitOfWork_Interface
* Zend_Entity_IdentityMap

Entity and Collection classes
* Zend_Entity_Interface
* Zend_Entity_List (Simple list 1...n of related objects)
* Zend_Entity_Map (Objects accessiable via map-key => object association)
* Zend_Entity_Set (Unique objects)
* Zend_Entity_Collection_Interface

Database specific implementations of core interfaces
* Zend_Db_Mapper_EntityManager
* Zend_Db_Mapper_UnitOfWork
* Zend_Db_Mapper_LazyLoad_List
* Zend_Db_Mapper_LazyLoad_Map
* Zend_Db_Mapper_LazyLoad_Set
* Zend_Db_Mapper_LazyLoad_Entity
* Zend_Db_Mapper_Abstract

Loader and Persister classes
* Zend_Db_Mapper_Persister_Interface
* Zend_Db_Mapper_Loader_Interface
* A bunch of implementations based on the requirements of the entity definition

Definition classes (Tooling Providers would greatly enhance work with this)
* Zend_Db_Mapper_DefinitionMap
* Zend_Db_Mapper_Definition_Entity (*Core Definition*)
* Zend_Db_Mapper_Definition_Property (Simple column property mapped to entity field)
* Zend_Db_Mapper_Definition_PrimaryKey (Required Id field of entity)
* Zend_Db_Mapper_Definition_CompositeKey
* Zend_Db_Mapper_Definition_Formula (Read only properties that are SQL formulas, for example group formulas)
* Zend_Db_Mapper_Definition_Collection (Has Many collections of entities or value objects)
* Zend_Db_Mapper_Definition_Join (Join a second table that holds properties of entity)
* Zend_Db_Mapper_Definition_Component (Nested value object that is generated from table columns)
* Zend_Db_Mapper_Definition_Discriminator (Property that decides which sub-class to instantiate)
* Zend_Db_Mapper_Definition_Version (field to use for optimitistic locking)
* Zend_Db_Mapper_Definition_Timestamp (Update timestamp on saving)
* Zend_Db_Mapper_Definition_Date (Zend_Date Serializer)
* Zend_Db_Mapper_Definition_DateTime (DateTime Serializer)
* Zend_Db_Mapper_Definition_Id_Interface
* Zend_Db_Mapper_Definition_Id_AutoIncrement
* Zend_Db_Mapper_Definition_Id_Sequence
* Zend_Db_Mapper_Definition_Relation_Interface
* Zend_Db_Mapper_Definition_Relation_OneToMany
* Zend_Db_Mapper_Definition_Relation_ManyToOne
* Zend_Db_Mapper_Definition_Relation_OneToOne
* Zend_Db_Mapper_Definition_Relation_ManyToMany
{zone-data}

{zone-data:use-cases}
{deck:id=UseCaseBasic}
{card:label=Use-Case 1: Setup and simple usage}
Initialize db adapter and create the mapper factory with a plugin loader configuration.

{code}
$dbAdapter = Zend_Db::factory(..);
$manager   = Zend_Db_Mapper_EntityManager::factory($dbAdapter, array(
    'mapperClassPath' => array('My_Application_Mapper' => 'My/Application/Mapper')
));

$customer       = $manager->findByKey("Customer", 1);

$customer->name = "Foo";

$manager->save($customer);
{code}
{card}

{card:label=Use-Case 2: Usage with Zend_Db_Select}

We could also go to the concrete mapper managing an entity, both session and mapper offer acess via Zend_Db_Select objects

{code}
$manager->select("Customer");
$select->where("customer_name = ?", "John Wayne");

$john = $manager->findOne("Customer", $select);
$john->addOrder(...);
$manager->save($john);

// Retrieve concrete mapper responsible for a Class.
// This is by no means necessary but he might have userland functions depending on user implementation.
$customerMapper = $manager->getMapperByEntity("Customer");
$select         = $customerMapper->select();
$select->where("customer_name = ?", "John Wayne");

$matches        = $customerMapper->find($select);
$john           = $customerMapper->findOne($select);
$numberOneMil   = $customerMapper->findByKey(1000000);
{code}
{card}

{card:label=Use-Case 3: An Entity Class Implementation}

Our customer entity object used by the mappers before would look something like:

{code}
class Customer implements Zend_Entity_Interface
{
    protected $id;

    protected $name;

    protected $salesHistory;

    /**
     * Required interface function for setting state of an object
     */
    public function setState(array $state)
    {
        foreach($state AS $k => $v) {
            $this->$k = $v;
        }
    }

    /**
     * Required function to get the state of an object
     */
    public function getState()
    {
        return array(
            'id' => $this->id,
            'name' => $this->name,
            'salesHistory' => $this->salesHistory, // Type Collection
        );
    }

    /** Userland functions to retrieve and set properties */
    public function getId()
    {
        return $this->id;
    }

    public function getName()
    {
        return $this->name;
    }

    public function setName($name)
    {
        $this->name = $name;
    }

    public function getSalesHistory()
    {
        return $this->salesHistory;
    }

    public function addSale(Sale $sale)
    {
        // salesHistory is a collection object
        $this->salesHistory->add($sale);
    }
}
{code}
{card}

{card:label=Use-Case 4: Unit Of Work}

We can use the unit of work instance inside the session to manage our transactions, to manage writing data back to the database:

{code}
$manager = Zend_Db_Mapper_EntityManager::factory($db,...);
$manager->beginTransaction();
$select  = $manager->select("Customer");
// [..] do something with $select

foreach($manager->find($select, "Customer") AS $customer) {
    $manager->delete($customer);
}
$manager->commit();
{code}
{card}

{deck}

{deck:id=UseCaseDefinitions}
{card:label=Use-Case 5:Mapping Definition in PHP}

A mapper definition has to be generated for all entities that describe the details of the mapping scheme. The definitions will be lazyloaded the first time the mapper is used.

{code}
$def = new Zend_Db_Mapper_Definition_Entity();
// You have to require and build this "Customer" class yourself implementing Zend_Entity_Interface as seen in UC-3
$def->setClass("Customer");

// Sql Schema & Tablename
$def->setSchema("myApplicationDb");
$def->setTable("customers");

// In General: The add[$propertyType]($propertyName, $options) func uses the pluginloader to load definitions

// Add Primary Key
$def->addPrimaryKey("id", array(
    "generator" => "AutoIncrement"
   )
);

// Will load: Zend_Db_Mapper_Definition_Property
$def->addProperty("name", array("columnName" => "customer_name") );

// Retrieve all Sales and put them into salesHistory, by default all collections are lazy loaded.
$def->addCollection('salesHistory', array(
"table" => "CustomerSales",         // Using a Join Table even for this OneToMany relation
        "key" => "customer_id",             // Key in Join table
        // Define the relationtype and which property and DbColumn are responsible in the Sales Entity
        "relation" => array("OneToMany", "id", array(
            "columnName" => "id",           // Could be set implicit by propertyName already
            "class" => "Sale",             // This relates to the entity "Class"
        )),
    )
);

// Retrieve the interests of the customer
$def->addCollection('interests', array(
        "table" => "CustomerInterests",     // Using a Join Table required for ManyToMany relationsships
        "key" => "customer_id",             // Key in Join table
        // Define the relationtype and which property and DbColumn are responsible in the Interests Entity
        "relation" => array("ManyToMany", "id", array(
            "columnName" => "interest_id",           // This is required for the join table
            "class" => "Interest",             // This relates to the entity "Class"
         )),
        "load" => "directly" // directly load these entites rather than waiting for lazy load trigger
    )
);

return $def;
{code}
{card}

{card:label=A second Definition: Article}
An Blog Article that has, a User, a Category, joins statistical information from a second table using an Outer Join (optional = true) and loads the Many Information about Tags and Comments via Lazy Load collections.

{code}
// Constructor API: First Parameter proxies setClass(), the option array calls their setters.
$def = new Zend_Entity_Mapper_Definition_Entity("Article", array('table' => "articles"));
$def->addPrimaryKey("id", array(
    'generator' => new Zend_Entity_Mapper_Definition_PrimaryKey_AutoIncrement(),
));

$def->addProperty("entry_type");
$def->addProperty("entry_headline");
$def->addProperty("entry_link");
$def->addProperty("entry_body");
$def->addProperty("entry_allowcomments");

$def->addProperty("created");

$def->addManyToOne("user", array(
    "columnName" => "user_id",
    "class" => "User",
    "foreignKey" => "id",
    "load" => "lazy",
));
$def->addManyToOne("category", array(
    "columnName" => "category_id",
    "class" => "Category",
    "foreignKey" => "id",
    "load" => "directly",
));

// Use a join table to gain certain statistical values that are aggregated into this
$join = $def->addJoin("article_statistics", array("key" => "article_id", "optional" => true));
$join->addFormula("comment_count", array(
    'sqlExpr' => "(SELECT count(comments.id) FROM comments WHERE comments.article_id = articles.id)"
));
$join->addProperty("entry_hits");
$join->addProperty("article_update_count");

$def->addCollection("comments", array(
    "table" => "comments",
    "key" => "article_id",
    "relation" => new Zend_Entity_Mapper_Definition_Relation_OneToMany("id", array("class" => "Comment")),
    "load" => "lazy",
));

$def->addCollection("tags", array(
    "table"    => "article2tag",
    "key"      => "article_id",
    "cascade"  => "all",
    "load" => "lazy",
    "relation" => new Zend_Entity_Mapper_Definition_Relation_ManyToMany("tag", array("class" => "Tag")),
));

return $def;
{code}
{card}
{deck}

h5. Clinic Management Example

This larger example shows SQL Schema, Definitions and Entities for a Clinic Management software.
Central piece is the planing of occupancies of emergency and regular patients in different stations
of the clinic based on current capacity.

The scenario is obviously very strange, but i wanted to come up with a real world enterprise
example and well, all the others were already used by others. :-)

{deck:id=UseCaseClinic}

{card:label=Entity: Station}
{code}
/**
 * A station of a clinic. Based on its type of patients different allocation strategies can be used.
 *
 * @entity
 */
class Clinic_Station implements Zend_Entity_Interface
{
    /**
     * Station Id
     *
     * @var int
     */
    protected $id;

    /**
     * Station Name
     *
     * @var string
     */
    protected $name;

    /**
     * Current Occupancies
     *
     * @var Clinic_Occupancy[]
     */
    protected $currentOccupancies;

    /**
     * Beds of this station
     *
     * @var Clinic_Bed[]
     */
    protected $beds;

    public function getId()
    {
        return $this->id;
    }

    public function getName()
    {
        return $this->name;
    }

    public function setName($name)
    {
        $this->name = $name;
    }

    public function getBeds()
    {
        return $this->beds;
    }

    public function getBedAllocationStrategy()
    {
        return $this->bedAllocationStrategy;
    }

    public function setBedAllocationStrategy($bedAllocationStrategy)
    {
        $this->bedAllocationStrategy = $bedAllocationStrategy;
    }

    public function getCurrentOccupancies()
    {
        return $this->currentOccupancies;
    }

    /**
     * Request an emergency occupancy for this clinic patient.
     *
     * @param  Clinic_Patient $patient
     * @return Clinic_Occupancy
     */
    public function requestEmergencyOccupancy(Clinic_Patient $patient, $requiredDays)
    {
        if(count($this->getCurrentOccupancies()) < count($this->getBeds())) {
            $today             = time();
            $expectedLeaveDate = $today + $requiredDays * 3600 * 24;
            $bed = $this->getEmptyBed();
            return $bed->addOccupancy($patient, $today, $expectedLeaveDate);
        }
        return null;
    }

    /**
     * Get currently empty bed or throw exception.
     *
     * @throws Exception
     * @return Clinic_Bed
     */
    protected function getEmptyBed()
    {
        foreach($this->getBeds() AS $bed) {
            if($bed->isCurrentlyEmpty() == true) {
                return $bed;
            }
        }
        throw new Exception("No empty bed found! Please refer to other clinic/station!");
    }

    /**
     * Request a routine occupancy for this patient.
     *
     * An occupancy is returned that has the date where the patients stay starts.
     *
     * @param  Clinic_Patient $patient
     * @return Clinic_Occupancy
     */
    public function requestRoutineOccupancy(Clinic_Patient $patient, $requiredDays)
    {
        // Not implemented: This algorihm should look to find current and future free time
        // to place the patient.
    }

    /**
     * Increase the number of beds of the station by the given number.
     *
     * Used by management to increase number of beds when capacity needs to be extended.
     *
     * @param  integer $byCount
     * @return Clinic_Bed[]
     */
    public function increaseNumberOfBeds($byCount)
    {
        for($i = 0; $i  < $byCount; $i++) {
            $bed = new Clinic_Bed();
            $bed->setStation($this);
            $this->beds->add($bed);
        }
        return $this->getBeds();
    }

    /**
     * Decrease the number of beds of the station by the given number.
     *
     * Used by management to decrease number of beds when capacity needs to be reduced.
     *
     * @param  integer $byCount
     * @return Clinic_Bed[]
     */
    public function decreaseNumberOfBeds($byCount)
    {
        // Only non-occupied beds can be removed
    }

    public function setState(array $state)
    {
        foreach($state AS $k => $v) {
            if(property_exists($this, $k)) {
                $this->$k = $v;
            }
        }
    }

    public function getState()
    {
        return array(
            'id' => $this->id,
            'name' => $this->name,
            'beds' => $this->beds,
        );
    }
}
{code}
{card}

{card:label=Entity: Patient}
{code}
/**
 * A clinic patient.
 *
 * @entity
 */
class Clinic_Patient implements Zend_Entity_Interface
{
    /**
     * Patient Id
     *
     * @var integer
     * @primary
     */
    protected $id;

    /**
     * Patient Name
     *
     * @var string
     */
    protected $name;

    /**
     * Patients Social Security Number
     *
     * @var string
     */
    protected $socialSecurityNumber;

    /**
     * Patients Birth Date
     *
     * @var Zend_Date
     */
    protected $birthDate;

    /**
     * Occupancies
     *
     * @return Clinic_Occupancy[]
     */
    protected $occupancies;

    public function getId() {
        return $this->id;
    }

    public function getName() {
        return $this->name;
    }

    public function setName($name) {
        $this->name = $name;
    }

    public function getSocialSecurityNumber() {
        return $this->socialSecurityNumber;
    }

    public function setSocialSecurityNumber($socialSecurityNumber) {
        $this->socialSecurityNumber = $socialSecurityNumber;
    }

    public function getBirthDate() {
        return $this->birthDate;
    }

    public function setBirthDate($birthDate) {
        $this->birthDate = $birthDate;
    }

    public function getState()
    {
        return array(
            'id'                    => $this->id,
            'name'                  => $this->name,
            'socialSecurityNumber'  => $this->socialSecurityNumber,
            'birthDate'             => $this->birthDate,
            'occupancies'           => $this->occupancies,
        );
    }

    public function setState(array $state)
    {
        foreach($state AS $k => $v) {
            if(property_exists($this, $k)) {
                $this->$k = $v;
            }
        }
    }
}
{code}
{card}

{card:label=Entity: Bed}
{code}
class Clinic_Bed implements Zend_Entity_Interface
{
    /**
     * Bed Id
     *
     * @var int
     */
    protected $id;

    /**
     * Station
     *
     * @var Clinic_Station
     */
    protected $station;

    /**
     * OccupancyPlan
     *
     * @var Zend_Entity_Collection
     */
    protected $occupancyPlan;

    public function getId()
    {
        return $this->id;
    }

    public function getStation()
    {
        return $this->station;
    }

    public function setStation($station)
    {
        $this->station = $station;
    }

    /**
     * Return all planed occupancies.
     *
     * @return Clinic_Occupancy[]
     */
    public function getOccupancyPlan()
    {
        return $this->occupancyPlan;
    }

    /**
     * Add patient as new occupancy on the given time interval.
     *
     * @param  Clinic_Patient $patient
     * @param  integer $from
     * @param  integer $to
     * @return Clinic_Occupancy
     */
    public function addOccupancy(Clinic_Patient $patient, $from, $to)
    {
        if($this->isCurrentlyEmpty()) {
            $occupancy = new Clinic_Occupancy();
            $occupancy->setBed($this);
            $occupancy->setPatient($patient);
            $occupancy->setStation($this->getStation());
            $occupancy->setOccupiedFrom($from);
            $occupancy->setOccupiedTo($to);

            // TODO: check if this does not collide with already "booked" occupancies

            $this->occupancyPlan->add($occupancy);
            return $occupancy;
        }
        return null;
    }

    public function isCurrentlyEmpty()
    {
        foreach($this->getOccupancyPlan() AS $occupancy) {
            $from = $occupancy->getOccupiedFrom();
            $to   = $occupancy->getOccupiedTo();
            if($from <= time() && $to >= time()) {
                return false;
            }
        }
        return true;
    }

    public function getState()
    {
        return array(
            'id'      => $this->id,
            'station' => $this->station,
        );
    }

    public function setState(array $state)
    {
        foreach($state AS $k => $v) {
            if(property_exists($this, $k)) {
                $this->$k = $v;
            }
        }
    }
}
{code}
{card}

{card:label=Entity: Occupancy}
{code}
/**
 * An occupancy defines which patient lies in which bed during which timespan.
 *
 * @entity
 */
class Clinic_Occupancy implements Zend_Entity_Interface
{
    /**
     * Occupancy Id
     *
     * @var integer
     */
    protected $id;

    /**
     * Patient
     *
     * @var Clinic_Patient
     * @hasOne
     */
    protected $patient;

    /**
     * Bed
     *
     * @var Clinic_Bed
     * @hasOne
     */
    protected $bed;

    /**
     * Station
     *
     * @var Clinic_Station
     * @hasOne
     */
    protected $station;

    /**
     * Day of first occupation
     *
     * @var integer
     */
    protected $occupiedFrom;

    /**
     * Estimated day of leave
     *
     * @var integer
     */
    protected $occupiedTo;

    public function getId() {
        return $this->id;
    }

    public function getPatient() {
        return $this->patient;
    }

    public function setPatient(Clinic_Patient $patient) {
        $this->patient = $patient;
    }

    public function getBed() {
        return $this->bed;
    }

    public function setBed(Clinic_Bed $bed) {
        $this->bed = $bed;
    }

    public function getOccupiedFrom() {
        return $this->occupiedFrom;
    }

    public function setOccupiedFrom($occupiedFrom) {
        $this->occupiedFrom = $occupiedFrom;
    }

    public function getOccupiedTo() {
        return $this->occupiedTo;
    }

    public function setOccupiedTo($occupiedTo) {
        $this->occupiedTo = $occupiedTo;
    }

    public function getStation()
    {
        return $this->station;
    }

    public function setStation($station)
    {
        $this->station = $station;
    }

    public function getState()
    {
        return array(
            'id'            => $this->id,
            'bed'           => $this->bed,
            'patient'       => $this->patient,
            'station'       => $this->station,
            'occupiedTo'    => $this->occupiedTo,
            'occupiedFrom'  => $this->occupiedFrom,
        );
    }

    public function setState(array $state)
    {
        foreach($state AS $k => $v) {
            if(property_exists($this, $k)) {
                $this->$k = $v;
            }
        }
    }
}
{code}
{card}

{card:label=Definition: Station}
{code}
$def = new Zend_Entity_Mapper_Definition_Entity("Clinic_Station", array("table" => "stations"));

$def->addPrimaryKey("id");
$def->addProperty("name");
$def->addCollection("beds", array(
    "key" => "station_id",
    "cascade" => "save",
    "relation"   => new Zend_Entity_Mapper_Definition_Relation_OneToMany("id", array("class" => "Clinic_Bed")),
));

$def->addCollection("currentOccupancies", array(
    "key" => "station_id",
    "relation" => new Zend_Entity_Mapper_Definition_Relation_OneToMany("id", array("class" => "Clinic_Occupancy")),
    "where" => "(occupancies.occupiedFrom >= NOW() AND occupancies.occupiedTo <= NOW())"
));

return $def;
{code}
{card}

{card:label=Definition: Patient}
{code}
$def = new Zend_Entity_Mapper_Definition_Entity("Clinic_Patient", array("table" => "patients"));
$def->addPrimaryKey("id");
$def->addProperty("name");
$def->addProperty("socialSecurityNumber");
$def->addProperty("birthDate");

$def->addCollection("occupancies", array(
    "key" => "occupancy_id",
    "relation" => new Zend_Entity_Mapper_Definition_Relation_OneToMany("id", array("class" => "Clinic_Occupancy")),
));

return $def;
{code}
{card}

{card:label=Definition: Bed}
{code}
$def = new Zend_Entity_Mapper_Definition_Entity("Clinic_Bed", array("table" => "beds"));

$def->addPrimaryKey("id");
$def->addManyToOne("station", array(
    "class"       => "Clinic_Station",
    "columnName"  => "station_id",
    "propertyRef" => "id",
    "load"        => "directly",
));
$def->addCollection("occupancyPlan", array(
    "key" => "bed_id",
    "relation" => new Zend_Entity_Mapper_Definition_Relation_OneToMany("id", array("class" => "Clinic_Occupancy")),
));

return $def;
{code}
{card}

{card:label=Definition: Occupancy}
{code}
$def = new Zend_Entity_Mapper_Definition_Entity("Clinic_Occupancy", array("table" => "occupancies"));

$def->addPrimaryKey("id");
$def->addManyToOne("patient", array("columnName" => "patient_id", "propertyRef" => "patient", "class" => "Clinic_Patient", "cascade" => "save"));
$def->addManyToOne("bed",     array("columnName" => "bed_id", "class" => "Clinic_Bed"));
$def->addManyToOne("station", array("columnName" => "station_id", "class" => "Clinic_Station"));
$def->addProperty("occupiedFrom");
$def->addProperty("occupiedTo");

return $def;
{code}
{card}

{card:label=Required MySQL Schema}
{code}
--
-- Table structure for table `beds`
--

CREATE TABLE IF NOT EXISTS `beds` (
  `id` int(11) unsigned NOT NULL auto_increment,
  `station_id` int(11) unsigned NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;

--
-- Table structure for table `occupancies`
--

CREATE TABLE IF NOT EXISTS `occupancies` (
  `id` int(11) unsigned NOT NULL auto_increment,
  `patient_id` int(11) unsigned NOT NULL,
  `bed_id` int(11) unsigned NOT NULL,
  `station_id` int(10) unsigned NOT NULL,
  `occupiedFrom` date NOT NULL,
  `occupiedTo` date NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;

--
-- Table structure for table `patients`
--

CREATE TABLE IF NOT EXISTS `patients` (
  `id` int(11) unsigned NOT NULL auto_increment,
  `name` varchar(255) NOT NULL,
  `socialSecurityNumber` varchar(16) NOT NULL,
  `birthDate` date NOT NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `socialSecurityNumber` (`socialSecurityNumber`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;

--
-- Table structure for table `stations`
--

CREATE TABLE IF NOT EXISTS `stations` (
  `id` int(11) unsigned NOT NULL auto_increment,
  `name` varchar(64) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;
{code}
{card}

{card:label=Clinic Scenario 1: New Emergency Patient}
{code}
$station = $entityManager->findByKey("Clinic_Station", 1);

$patient = new Clinic_Patient();
$patient->setName("John Doe");
$patient->setBirthDate("2008-01-04");
$patient->setSocialSecurityNumber("98203481");

$occupancy = $station->requestEmergencyOccupancy($patient, 7);

// Saving $patient is not required, since $occupancy cascades the save operation to $patient!
$entityManager->save($occupancy);
{code}
{card}

{card:label=Clinic Scenario 2: Increase number of beds in station}
{code}
$station = $entityManager->findByKey("Clinic_Station", 1);
$station->increaseNumberOfBeds(10);

$entityManager->save($station); // cascades operation to beds!
foreach($station->getBeds() AS $bed) { // iterate over all of them
    echo $bed->getId()."\n";
}
{code}
{card}

{deck}

{zone-data}

{zone-data:skeletons}
{deck:id=Skeletons}

These skeletons describe the available Public API to the userland.

{card:label=Zend_Entity_Manager_Interface}
Generic interface for any Manager that works on entities. The only specific word
here is "select" which is kinda SQL but every other datasource has Query Objects
to which this method proxies.

{code}
interface Zend_Entity_Manager_Interface
{
    /**
     * Return concrete mapper implementation of the given Entity Type
     *
     * @param  string|Zend_Entity_Interface $entity
     * @return Zend_Db_Mapper_Interface
     */
    public function getMapperByEntity($entity);

    /**
     * Return Query Object for given Entity
     *
     * @param  string $entityClass
     * @return object
     */
    public function select($entity);

    /**
     * Find all entities matching Query Object statement
     *
     * @param object $select
     * @param string $entityName
     */
    public function find($entityName, $select);

    /**
     * Find one entity matching select statement
     *
     * @param string $entityName
     * @param object $select
     * @return Zend_Entity_Interface
     */
    public function findOne($entityName, $select);

    /**
     * Find all entities of a type
     *
     * @param string $entityName
     * @param string $subcondition
     * @param int    $limit
     * @param string $order
     * @return Zend_Entity_Collection
     */
    public function findAll($entityName, $subcondition, $limit, $order);

    /**
     * Find by primary key
     *
     * @param string $entityName
     * @param string $key
     * @return Zend_Entity_Interface
     */
    public function findByKey($entityName, $key);

    /**
     * Save entity by registering it with UnitOfWork or hitting the database mapper.
     *
     * @param  Zend_Entity_Interface $record
     * @return void
     */
    public function save(Zend_Entity_Interface $entity);

    /**
     * Try to delete entity by checking with UnitOfWork or directly going to mapper.
     *
     * @param  Zend_Entity_Interface $record
     * @return void
     */
    public function delete(Zend_Entity_Interface $entity);

    /**
     * Refresh object state from the database
     *
     * @param  Zend_Entity_Interface $record
     * @return void
     */
    public function refresh(Zend_Entity_Interface $entity);

    /**
     * Retrieve the underyling datasource adapter
     *
     * @return object
     */
    public function getAdapter();

    /**
     * Tell Unit Of work to begin transaction
     *
     * @retun void
     */
    public function beginTransaction();

    /**
     * Tell Unit of Work to commit transaction.
     */
    public function commit();

    /**
     * Tell Unit of Work to rollback transaction.
     */
    public function rollBack();

    /**
     * Flush Transaction to database and immediatly open up new one.
     */
    public function flush();

    /**
     * Clear persistence session, rolling back all current changes if transaction is open
     * and deleting the UnitOfWork and Identity Map states.
     */
    public function clear();

    /**
     * Close connection to database, commit transaction if any is open and call clear().
     */
    public function closeConnection();

    /**
     * Set this session to read only, which might lead to faster object destruction and memory management.
     *
     * @return void
     */
    public function setReadOnly();

    /**
     * Retrieve Unit of Work instance from the EntityManager
     *
     * @return Zend_Db_Mapper_UnitOfWork_Interface
     */
    public function getUnitOfWork();

    /**
     * Retrieve Identity Map instance from EntityManager
     *
     * @return Zend_Db_Mapper_IdentityMap
     */
    public function getIdentityMap();
}
{code}
{card}

{card:label=Zend_Entity_Interface}
{code}
interface Zend_Entity_Interface
{
    /**
     * Return the current COMPLETE state of the object as an array
     *
     * @return array
     */
    public function getState();

    /**

     * Is used by Mappers to set complete or PARTIAL (!) information on an entity.
     *
     * @param array $state
     * @return void
     */
    public function setState(array $state);
}
{code}
{card}

{card:label=Zend_Entity_Collection}
The collection is required to be able to make a diff on commit and add, delete
only the relevant objects.

{code}
interface Zend_Entity_Collection extends ArrayAccess, Iterator, Countable
{
    public function __construct(array $collection=array(), $entityClassType=null);

    public function add($entity);

    public function remove($index);

    public function getDeleted();

    public function getAdded();

    public function wasLoaded();
}
{code}
{card}
{deck}
{zone-data}
{zone-template-instance}