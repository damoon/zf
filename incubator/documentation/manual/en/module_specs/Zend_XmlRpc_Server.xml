<sect1 id="zend.xmlrpc.server">
    <title>Zend_XmlRpc_Server</title>
    <para>Zend_XmlRpc_Server is intended as a fully-featured XML-RPC server,
        following <ulink url="http://www.xmlrpc.com/spec">the specifications
        outlined at www.xmlrpc.com</ulink>. Additionally, it implements the
        system.multicall() method, allowing boxcarring of requests.
    </para>

    <sect2 id="zend.xmlrpc.server.structure">
        <title>XMLRPC Server Structure</title>

        <para>Zend_XmlRpc_Server is composed of a variety of components, ranging
            from the server itself to request, response, and fault objects.</para>

        <para>To bootstrap Zend_XmlRpc_Server, the developer must attach one or
            more classes or functions to the server, via the
            <code>setClass()</code> and <code>addFunction()</code> methods.</para>

        <para>Once done, you may either pass a <code>Zend_XmlRpc_Request</code>
            object to <code>Zend_XmlRpc_Server::handle()</code>, or it will
            instantiate a <code>Zend_XmlRpc_Request_Http</code> object if none
            is provided -- thus grabbing the request from
            <code>php://input</code>.</para>

        <para><code>Zend_XmlRpc_Server::handle()</code> then attempts to
            dispatch to the appropriate handler based on the method
            requested. It then returns either a
            <code>Zend_XmlRpc_Response</code>-based object or a
            <code>Zend_XmlRpc_Server_Fault</code>object. These objects both have
            <code>__toString()</code> methods that create valid XMLRPC XML
            responses, allowing them to be directly echoed.</para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.usage">
        <title>XMLRPC Server Basic Usage</title>
        <para>
            An example of the most basic use case:
        </para>

        <programlisting role="php">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'My/Service/Class.php';

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('My_Service_Class');
echo $server->handle();
?&gt;</programlisting>
    </sect2>

    <sect2 id="zend.xmlrpc.server.namespaces">
        <title>Utilizing Namespaces</title>
        <para>
            XMLRPC has a concept of namespacing; basically, it allows grouping
            XMLRPC methods by dot-delimited namespaces. This helps prevent
            naming collisions between methods served by different classes. As an
            example, the XMLRPC server is expected to server several methods in
            the 'system' namespace:
        </para>
        <itemizedlist>
            <listitem><para>system.listMethods</para></listitem>
            <listitem><para>system.methodHelp</para></listitem>
            <listitem><para>system.methodSignature</para></listitem>
        </itemizedlist>
        <para>
            Internally, these map to the methods of the same name in
            Zend_XmlRpc_Server.
        </para>
        <para>
            If you want to add namespaces to the methods you server, simply
            provide a namespace to the appropriate method when attaching a
            function or class:
        </para>
        <programlisting role="php">&lt;?php
// All public methods in My_Service_Class will be accessible as
// myservice.METHODNAME
$server-&gt;setClass('My_Service_Class', 'myservice'); 

// Function 'somefunc' will be accessible as funcs.somefunc
$server-&gt;addFunction('funcs', 'somefunc');</programlisting>
    </sect2>

    <sect2 id="zend.xmlrpc.server.request">
        <title>Custom Request Objects</title>
        <para>
            Most of the time, you'll simply use the default request type
            included with Zend_XmlRpc_Server, Zend_XmlRpc_Request_Http. However,
            there may be times when you need XMLRPC to be available via the CLI,
            a GUI, or other environment, or want to log incoming requests. To do
            so, you may create a custom request object that extends
            Zend_XmlRpc_Request. The most important thing to remember is to
            ensure that the getMethod() and getParams() methods are implemented
            so that the XMLRPC server can retrieve that information in order to
            dispatch the request.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.response">
        <title>Custom Responses</title>
        <para>
            Similar to request objects, Zend_XmlRpc_Server can return custom
            response objects; by default, a Zend_XmlRpc_Response_Http object is
            returned, which sends an appropriate Content-Type HTTP header for
            use with XMLRPC. Possible uses of a custom object would be to log
            responses, or to send responses back to STDOUT.
        </para>
        <para>
            To use a custom response class, use
            Zend_XmlRpc_Server::setResponseClass() prior to calling handle().
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.fault">
        <title>Handling Exceptions via Faults</title>
        <para>
            Zend_XmlRpc_Server catches Exceptions generated by a dispatched
            method, and generates an XMLRPC fault response when such an
            exception is caught. By default, however, the exception messages and
            codes are not used in a fault response. This is an intentional
            decision to protect your code; many exceptions expose more
            information about the code or environment than a developer would
            necessarily intend (a prime example includes database abstraction or
            access layer exceptions).
        </para>
        <para>
            Exception classes can be whitelisted to be used as fault responses,
            however. To do so, simply utilize
            Zend_XmlRpc_Server_Fault::attachFaultException() to pass an
            exception class to whitelist:
        </para>
        <programlisting role="php">&lt;?php
Zend_XmlRpc_Server_Fault::attachFaultException('My_Project_Exception');</programlisting>
        <para>
            If you utilize an exception class that your other project exceptions
            inherit, you can then whitelist a whole family of exceptions at a
            time.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.caching">
        <title>Caching Server Definitions Between Requests</title>
        <para>
            Attaching many classes to an XMLRPC server instance can utilize a
            lot of resources; each class must introspect using the Reflection
            API (via Zend_Server_Reflection), which in turn generates a list of
            all possible method signatures to provide to the server class.
        </para>
        <para>
            To reduce this performance hit somewhat, Zend_XmlRpc_Server_Cache
            can be used to cache the server definition between requests. When
            combined with __autoload(), this can greatly increase performance.
        </para>
        <para>
            An sample usage follows:
        </para>
        <programlisting role="php">&lt;?php
require_once 'Zend.php';
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Cache.php';

function __autoload($class)
{
    Zend::loadClass($class);
}

$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';
$server = new Zend_XmlRpc_Server();

if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    require_once 'My/Services/Glue.php';
    require_once 'My/Services/Paste.php';
    require_once 'My/Services/Tape.php';

    $server->setClass('My_Services_Glue', 'glue');   // glue. namespace
    $server->setClass('My_Services_Paste', 'paste'); // paste. namespace
    $server->setClass('My_Services_Tape', 'tape');   // tape. namespace

    Zend_XmlRpc_Server_Cache::save($cacheFile, $server);
}

echo $server->handle();</programlisting>
        <para>
            The above example attempts to retrieve a server definition from
            xmlrpc.cache in the same directory as the script. If unsuccessful,
            it loads the service classes it needs, attaches them to the server
            instance, and then attempts to create a new cache file with the
            server definition.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.use">
        <title>Advanced Usage Examples</title>
        <para>
            TODO: provide some advanced usage examples
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
