<sect1 id="zend.openid.consumer">
    <title>Zend_OpenId_Consumer Basics</title>
    <para>
        <code>Zend_OpenId_Consumer</code> is used to implement OpenID
        authentication schema on web sites.
    </para>

    <sect2 id="zend.openid.consumer.authentication">
        <title>OpenID Authentication</title>
        <para>
            From site developer point of view the OpenID authentication
            process consists from three steps:
        </para>

        <orderedlist>
            <listitem>
                Show OpenID authentication form.
            </listitem>
            <listitem>
                Accept OpenID identity and pass it to OpenID provider.
            </listitem>
            <listitem>
                Verify response from OpenID provider.
            </listitem>
        </orderedlist>

        <para>
            Really the OpenID authentication protocol performs more steps, but
            most of them encapsulated inside <code>Zend_OpenId_Consumer</code>,
            and developers may forget about them.
        </para>

        <para>
            The OpenID authentication process is initiated by end-user who fill
            in their identity into appropriated form and submit it. The following
            example shows a simple form that accepts OpenID identifier. Note
            that it doesn't accept any password.
        </para>

        <example id="zend.openid.consumer.example-1">
            <title>The Simple OpenID Login form</title>
            <programlisting role="php"><![CDATA[<html><body>
<form method="post" action="example-1_2.php"><fieldset>
<legend>OpenID Login</legend>
<input type="text" name="openid_identifier">
<input type="submit" name="openid_action" value="login">
</fieldset></form></body></html>]]>
            </programlisting>
        </example>

        <para>
            On submit this form passes OpenID identity to the following PHP
            script that performs second step of authentication. The only thing
            that PHP script needs to do on this step is call <code>Zend_OpenId_Consumer::login()</code>
            method. The first argument to this method is an accepted OpenID
            identity and the second is an URL of script that handles third step
            of authentication.
        </para>

        <example id="zend.openid.consumer.example-1_2">
            <title>The Authentication Request Handler</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if (!$consumer->login($_POST['openid_identifier'], 'example-1_3.php')) {
    die("OpenID login failed.");
}]]>
            </programlisting>
        </example>

        <para>
            The <code>Zend_OpenId_Consumer::login()</code> performs discovery
            on given identifier and on success finds out the address of
            identity provider and its local identifier. Then it performs
            associations with given provider so both site and provider know
            the same secret that is used to sign the following messages.
            And then it passes authentication request to provider. Note that
            this request redirects end-user's web browser to OpenID server
            site, where users are able to continue the authentication process.
        </para>

        <para>
            OpenID Server usually asks user for password (if they weren't
            logged-in before), asks if user trusts to this site and which
            information about they may be returned back to the site.
            All this interactions are not visible to OpenID-enabled site so
            it will never know user's password or other information that they
            don't open.
        </para>

        <para>
            On success <code>Zend_OpenId_Consumer::login()</code> never returns,
            because it performs HTTP redirection, however in case of errors it
            may return false. These may be errors because of invalid identity,
            dead provider, communication errors, etc
        </para>

        <para>
            The third step of authentication is initiated by response from
            OpenID provider that has already checked user's password. This
            response is passed indirectly, as HTTP redirection of end-user's
            web browser. And the only thing that site must do is to check if
            this response is valid.
        </para>

        <example id="zend.openid.consumer.example-1_3">
            <title>The Authentication Response Verifier</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if ($consumer->verify($_GET, $id)) {
    echo "VALID $id";
} else {
    echo "INVALID $id";
}]]>
            </programlisting>
        </example>

        <para>
            This check is performed using <code>Zend_OpenId_Consumer::verify</code>
            method, that takes the whole array of HTTP request arguments and
            checks if this response is properly signed by appropriated OpenID
            provider. As an option it returns the claimed OpenID identity that
            was entered by end-user on first step.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.combine">
        <title>Combine All Steps on One Page</title>
        <para>
            The following example combines all three steps together. It
            doesn't provide any additional functionality. The only useful
            thing that now developers don't need to specify URL's of scripts
            that handle next step. By default all steps use the same URL.
            However now script includes dispatch code that calls code for
            appropriate step of authentication.
        </para>

        <example id="zend.openid.consumer.example-2">
            <title>The Complete OpenID Login Script</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$status = "";
if (isset($_POST['openid_action']) &&
    $_POST['openid_action'] == "login" &&
    !empty($_POST['openid_identifier'])) {

    $consumer = new Zend_OpenId_Consumer();
    if (!$consumer->login($_POST['openid_identifier'])) {
        $status = "OpenID login failed.<br>";
    }
} else if (isset($_GET['openid_mode'])) {
    if ($_GET['openid_mode'] == "id_res") {
        $consumer = new Zend_OpenId_Consumer();
        if ($consumer->verify($_GET, $id)) {
            $status = "VALID $id";
        } else {
            $status = "INVALID $id";
        }
    } else if ($_GET['openid_mode'] == "cancel") {
        $status = "CANCELED";
    }
}
?>
<html><body>
<?php echo "$status<br>";?>
<form method="post"><fieldset>
<legend>OpenID Login</legend>
<input type="text" name="openid_identifier" value="">
<input type="submit" name="openid_action" value="login">
</fieldset></form></body></html>]]>
            </programlisting>
        </example>

        <para>
            In addition this code makes difference between canceled and wrong
            authentication response. In case if identity provider doesn't know
            the supplied identity, or user is not logged-in or they don't trust
            to this site - provider returns canceled response. The wrong
            response assumes wrong or incorrectly signed response.

        </para>

    </sect2>

    <sect2 id="zend.openid.consumer.realm">
        <title>Realm</title>
        <para>
            When OpenID-enabled site passes authentication requests to provider
            it identifies itself with realm URL. This URL may be considered as
            a root of trusted site. In case if user trusts to this URL they
            also trust to all matched and subsequence URLs.
        </para>

        <para>
            By default realm URL automatically set to URL of directory where
            the login script lays. This decision is useful for most, but not
            all cases. Sometime you like to use not directory but whole site,
            or even combine several servers from one domain.
        </para>

        <para>
            To implement this ability developers may pass realm value as a
            third argument to <code>Zend_OpenId_Consumer::login</code> method.
            In the following example the single interaction asks for trusted
            access to all php.net sites.
        </para>

        <example id="zend.openid.consumer.example-3_2">
            <title>Authentication Request for Specified Realm</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if (!$consumer->login($_POST['openid_identifier'], 'example-3_3.php', 'http://*.php.net/')) {
    die("OpenID login failed.");
}]]>
            </programlisting>
        </example>

        <para>
            The example below implements only the second step of authentication,
            first and third steps are the same as in the first example.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.check">
        <title>Immediate Check</title>
        <para>
            In some situations it would be useful to check if user already
            logged-in into OpenID server and trusts us without any interaction
            with them. Method <code>Zend_OpenId_Consumer::check</code> intended
            to do this work. It executed with exactly the same arguments
            as <code>Zend_OpenId_Consumer::login</code> but doesn't allow
            user to see any OpenID server pages. For users it seems like they
            don't leave the site. The third step will succeed if user was
            already logged-in and trusted to the site and failed otherwise.
        </para>

        <example id="zend.openid.consumer.example-4">
            <title>The Immediate Check without Interaction</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";

$consumer = new Zend_OpenId_Consumer();
if (!$consumer->check($_POST['openid_identifier'], 'example-4_3.php')) {
    die("OpenID login failed.");
}]]>
            </programlisting>
        </example>

        <para>
            The example below implements only the second step of authentication,
            first and third steps are the same as in the first example.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.storage">
        <title>Zend_OpenId_Consumer_Storage</title>
        <para>
            There are three steps of OpenID authentication procedure, and each
            step is performed in separate HTTP request. To store information
            between requests <code>Zend_OpenId_Consumer</code> uses an internal
            storage.
        </para>

        <para>
            Developers may not care about this storage because by default
            <code>Zend_OpenId_Consumer</code> uses file-based storage under
            /tmp similar to PHP sessions.
            However this storage may be not suitable for all cases. Someone
            will like to store information in database, another will need to
            use common storage for big web-farm. Fortunately, developers may
            easily replace default storage with their own. The only thing they
            need - implement its own storage class as child of
            <code>Zend_OpenId_Consumer_Storage</code> and pass it as first
            argument to <code>Zend_OpenId_Consumer</code> constructor.
        </para>

        <para>
            The following example demonstrates a simple storage that uses
            <code>Zend_Db</code> as a backend. It contains three groups of
            functions. First is to work with associations, the second is to
            cache discovery information and the third is to check responce
            uniqueness. The class implemented in such a way that it can be
            easily used with existing or new database. If necessary database
            tables don't exist, it creates them.
        </para>

        <example id="zend.openid.consumer.example-5">
            <title>Databse Storage</title>
            <programlisting role="php"><![CDATA[<?php
class DbStorage extends Zend_OpenId_Consumer_Storage
{
    private $_db;
    private $_association_table;
    private $_discovery_table;
    private $_nonce_table;

    public function __construct($db,
                                $association_table = "association",
                                $discovery_table = "discovery",
                                $nonce_table = "nonce")
    {
        $this->_db = $db;
        $this->_association_table = $association_table;
        $this->_discovery_table = $discovery_table;
        $this->_nonce_table = $nonce_table;
        $tables = $this->_db->listTables();
        if (!in_array($association_table, $tables)) {
            $this->_db->getConnection()->exec(
                "create table $association_table (" .
                " url     varchar(256) not null primary key," .
                " handle  varchar(256) not null," .
                " macFunc char(16) not null," .
                " secret  varchar(256) not null," .
                " expires timestamp" .
                ")");
        }
        if (!in_array($discovery_table, $tables)) {
            $this->_db->getConnection()->exec(
                "create table $discovery_table (" .
                " id      varchar(256) not null primary key," .
                " realId  varchar(256) not null," .
                " server  varchar(256) not null," .
                " version float," .
                " expires timestamp" .
                ")");
        }
        if (!in_array($nonce_table, $tables)) {
            $this->_db->getConnection()->exec(
                "create table $nonce_table (" .
                " nonce   varchar(256) not null primary key," .
                " created timestamp default current_timestamp" .
                ")");
        }
    }

    public function addAssociation($url, $handle, $macFunc, $secret, $expires)
    {
        $table = $this->_association_table;
        $secret = base64_encode($secret);
        $this->_db->query("insert into $table (url, handle, macFunc, secret, expires) " .
                          "values ('$url', '$handle', '$macFunc', '$secret', $expires)");
        return true;
    }

    public function getAssociation($url, &$handle, &$macFunc, &$secret, &$expires)
    {
        $table = $this->_association_table;
        $this->_db->query("delete from $table where expires < " . time());
        $res = $this->_db->fetchRow("select handle, macFunc, secret, expires from $table where url = '$url'");
        if (is_array($res)) {
            $handle  = $res['handle'];
            $macFunc = $res['macFunc'];
            $secret  = base64_decode($res['secret']);
            $expires = $res['expires'];
            return true;
        }
        return false;
    }

    public function getAssociationByHandle($handle, &$url, &$macFunc, &$secret, &$expires)
    {
        $table = $this->_association_table;
        $this->_db->query("delete from $table where expires < " . time());
        $res = $this->_db->fetchRow("select url, macFunc, secret, expires from $table where handle = '$handle'");
        if (is_array($res)) {
            $url     = $res['url'];
            $macFunc = $res['macFunc'];
            $secret  = base64_decode($res['secret']);
            $expires = $res['expires'];
            return true;
        }
        return false;
    }

    public function delAssociation($url)
    {
        $table = $this->_association_table;
        $this->_db->query("delete from $table where url = '$url'");
        return true;
    }

    public function addDiscoveryInfo($id, $realId, $server, $version, $expires)
    {
        $table = $this->_discovery_table;
        $this->_db->query("insert into $table (id, realId, server, version, expires) " .
                          "values ('$id', '$realId', '$server', $version, $expires)");
        return true;
    }

    public function getDiscoveryInfo($id, &$realId, &$server, &$version, &$expires)
    {
        $table = $this->_discovery_table;
        $this->_db->query("delete from $table where expires < " . time());
        $res = $this->_db->fetchRow("select realId, server, version, expires from $table where id = '$id'");
        if (is_array($res)) {
            $realId  = $res['realId'];
            $server  = $res['server'];
            $version = $res['version'];
            $expires = $res['expires'];
            return true;
        }
        return false;
    }

    public function delDiscoveryInfo($id)
    {
        $table = $this->_discovery_table;
        $this->_db->query("delete from $table where id = '$id'");
        return true;
    }

    public function isUniqueNonce($nonce)
    {
        $table = $this->_nonce_table;
        try {
            $ret = $this->_db->query("insert into $table (nonce) values ('$nonce')");
        } catch (Zend_Db_Statement_Exception $e) {
            return false;
        }
        return true;
    }

    public function purgeNonces($date=null)
    {
    }
}

$db = Zend_Db::factory('Pdo_Sqlite',
    array('dbname'=>'/tmp/openid_consumer.db'));
$storage = new DbStorage($db);
$consumer = new Zend_OpenId_Consumer($storage);
]]>
            </programlisting>
        </example>

        <para>
            The example doesn't include OpenID authentication code itself, but
            it may be the same as in previous or following examples.
        </para>

    </sect2>

    <sect2 id="zend.openid.consumer.sreg">
        <title>Simple Registration Extension</title>
        <para>
            In addition to authentication OpenID can be used for light-weight
            profile exchange. This feature is not covered by OpenID
            authentication specification but by OpenID Simple Registration
            Extension protocol. This protocol allows OpenID-enabled sites to
            ask some information about end-user from OpenID providers. Such
            information may include:
        </para>

        <itemizedlist>
            <listitem>
                <emphasis>nickname</emphasis> -
                any UTF-8 string that the end user wants to use as a nickname.
            </listitem>
            <listitem>
                <emphasis>email</emphasis> -
                the email address of the end user as specified in section 3.4.1
                of RFC2822.
            </listitem>
            <listitem>
                <emphasis>fullname</emphasis> -
                a UTF-8 string representation of the end user's full name.
            </listitem>
            <listitem>
                <emphasis>dob</emphasis> -
                the end user's date of birth as YYYY-MM-DD. Any values whose
                representation uses fewer than the specified number of digits
                should be zero-padded. The length of this value must always be
                10. If the end user does not want to reveal any particular
                component of this value, it must be set to zero. For instance,
                if a end user wants to specify that his date of birth is in
                1980, but not the month or day, the value returned shall be
                "1980-00-00".
            </listitem>
            <listitem>
                <emphasis>gender</emphasis> -
                the end user's gender, "M" for male, "F" for female.
            </listitem>
            <listitem>
                <emphasis>postcode</emphasis> -
                UTF-8 string that should conform to the end user's country's
                postal system.
            </listitem>
            <listitem>
                <emphasis>country</emphasis> -
                the End User's country of residence as specified by ISO3166.
            </listitem>
            <listitem>
                <emphasis>language</emphasis> -
                end User's preferred language as specified by ISO639.
            </listitem>
            <listitem>
                <emphasis>timezone</emphasis> -
                ASCII string from TimeZone database. For example, "Europe/Paris" or "America/Los_Angeles".
            </listitem>
        </itemizedlist>

        <para>
            An OpenID-enabled web site may ask any combination of these fields.
            It also may strictly require some information and allow end-user to
            provide or hide other. The following example creates an object of
            <code>Zend_OpenId_Extension_Sreg</code> class that requires
            <emphasis>nickname</emphasis> and optionally ask for <emphasis>email</emphasis>
            and <emphasis>fullname</emphasis>.
        </para>

        <example id="zend.openid.consumer.example-6_2">
            <title>Sending Request with Simple Registration Extension</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";
require_once "Zend/OpenId/Extension/Sreg.php";

$sreg = new Zend_OpenId_Extension_Sreg(array(
    'nickname'=>true,
    'email'=>false,
    'fullname'=>false), null, 1.1);
$consumer = new Zend_OpenId_Consumer();
if (!$consumer->login($_POST['openid_identifier'], 'example-6_3.php', null, $sreg)) {
    die("OpenID login failed.");
}]]>
            </programlisting>
        </example>

        <para>
            As you can see the constructor of <code>Zend_OpenId_Extension_Sreg</code>
            accepts array of asked fields. This array has the names of fields
            as indexes and requirements flag as values. <emphasis>true</emphasis>
            means that field is required and <emphasis>false</emphasis> that
            field is optional. The <code>Zend_OpenId_Consumer::login</code>
            accepts extension or list of extension as fourth argument.
        </para>

        <para>
            On third step of authentication the object of <code>Zend_OpenId_Extension_Sreg</code>
            should be passed to <code>Zend_OpenId_Consumer::verify</code> and
            then on successful authentication <code>Zend_OpenId_Extension_Sreg::getProperties</code>
            will return associative array of returned fields.
        </para>

        <example id="zend.openid.consumer.example-6_3">
            <title>Verifying Response with Simple Registration Extension</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";
require_once "Zend/OpenId/Extension/Sreg.php";

$sreg = new Zend_OpenId_Extension_Sreg(array(
    'nickname'=>true,
    'email'=>false,
    'fullname'=>false), null, 1.1);
$consumer = new Zend_OpenId_Consumer();
if ($consumer->verify($_GET, $id, $sreg)) {
    echo "VALID $id<br>\n";
    $data = $sreg->getProperties();
    if (isset($data['nickname'])) {
        echo "nickname: " . $data['nickname'] . "<br>\n";
    }
    if (isset($data['email'])) {
        echo "email: " . $data['email'] . "<br>\n";
    }
    if (isset($data['fullname'])) {
        echo "fullname: " . $data['fullname'] . "<br>\n";
    }
} else {
    echo "INVALID $id";
}]]>
            </programlisting>
        </example>

        <para>
            In case if <code>Zend_OpenId_Extension_Sreg</code> was created
            without arguments, user code should check for existence of required
            data itself. However if the object is created with the same list
            of required fields as on second step, it will check existence
            automatic. In this case <code>Zend_OpenId_Consumer::verify</code>
            will return <emphasis>false</emphasis> if any of required fields
            are missing.
        </para>

        <para>
            By default <code>Zend_OpenId_Extension_Sreg</code> uses version 1.0,
            because the specification for version 1.1 is not finalized yet.
            However some libraries don't support version 1.0 correctly. For
            example www.myopenid.com requires SREG namespace in request that
            is subject of 1.1. So to work with this server we should explicitly
            set version to 1.1 in <code>Zend_OpenId_Extension_Sreg</code>
            constructor.
        </para>

        <para>
            The second argument of <code>Zend_OpenId_Extension_Sreg</code>
            constructor is a policy URL, that should be provided to end-user
            by identity provider.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.auth">
        <title>Integration with Zend_Auth</title>
        <para>
            Zend Framework provides special class to support user authentication
            - <code>Zend_Auth</code> and you it can be used together with
            <code>Zend_OpenId_Consumer</code>. In the following example
            <code>OpenIdAdapter</code> implements <code>Zend_Auth_Adapter_Interface</code>
            with method <code>authenticate</code>. This performs authentication
            query and verification.
        </para>

        <para>
            The big difference between this adapter and existing ones, that it
            works on two HTTP requests and includes dispatch code to perform
            second or third step of OpenID authentication.
        </para>

        <example id="zend.openid.consumer.example-7">
            <title>Zend_Auth Adapter for OpenID</title>
            <programlisting role="php"><![CDATA[<?php
require_once "Zend/OpenId/Consumer.php";
require_once "Zend/Auth.php";
require_once "Zend/Auth/Adapter/Interface.php";

class OpenIdAdapter implements Zend_Auth_Adapter_Interface {
    private $_id = null;

    public function __construct($id = null) {
        $this->_id = $id;
    }

    public function authenticate() {
        $id = $this->_id;
        if (!empty($id)) {
            $consumer = new Zend_OpenId_Consumer();
            if (!$consumer->login($id)) {
                $ret = false;
                $mdg = "Authentication failed.";
            }
        } else {
            $consumer = new Zend_OpenId_Consumer();
            if ($consumer->verify($_GET, $id)) {
                $ret = true;
                $msg = "Authentication successful";
            } else {
                $ret = false;
                $msg = "Authentication failed";
            }
        }
        return new Zend_Auth_Result($ret, $id, array($msg));
    }
}

$status = "";
$auth = Zend_Auth::getInstance();
if ((isset($_POST['openid_action']) &&
     $_POST['openid_action'] == "login" &&
     !empty($_POST['openid_identifier'])) ||
    isset($_GET['openid_mode'])) {
    $adapter = new OpenIdAdapter(@$_POST['openid_identifier']);
    $result = $auth->authenticate($adapter);
    if ($result->isValid()) {
        Zend_OpenId::redirect(Zend_OpenId::selfURL());
    } else {
        $auth->clearIdentity();
        foreach ($result->getMessages() as $message) {
            $status .= "$message<br>\n";
        }
    }
} else if ($auth->hasIdentity()) {
    if (isset($_POST['openid_action']) &&
        $_POST['openid_action'] == "logout") {
        $auth->clearIdentity();
    } else {
        $status = "Yoy are logged-in as " . $auth->getIdentity() . "<br>\n";
    }
}
?>
<html><body>
<?php echo "$status";?>
<form method="post"><fieldset>
<legend>OpenID Login</legend>
<input type="text" name="openid_identifier" value="">
<input type="submit" name="openid_action" value="login">
<input type="submit" name="openid_action" value="logout">
</fieldset></form></body></html>
]]>
            </programlisting>
        </example>

        <para>
            With <code>Zend_Auth</code> the identity of end-user is saved
            in session data. It may be checked with <code>Zend_Auth::hasIdentity</code>
            and <code>Zend_Auth::getIdentity</code>.
        </para>
    </sect2>

    <sect2 id="zend.openid.consumer.mvc">
        <title>Integration with Zend_Controller</title>
        <para>
            Finally a couple of word about integration into Model-View-Controller
            applications. Such Zend Framework applications are implemented using
            <code>Zend_Controller</code> class and they use objects of
            <code>Zend_Controller_Response_Http</code> class to prepare HTTP
            response and send it back to end user's web-browser.
        </para>

        <para>
            <code>Zend_OpenId_Consumer</code> doesn't provide any GUI
            capabilities but it performs HTTP redirections on success of
            <code>Zend_OpenId_Consumer::login</code> and
            <code>Zend_OpenId_Consumer::check</code>. These redirections
            may work incorrect or don't work at all if some data was already
            sent to web-browser before. To properly perform HTTP redirection
            in MVC code the real <code>Zend_Controller_Response_Http</code>
            should be sent to <code>Zend_OpenId_Consumer::login</code> and
            <code>Zend_OpenId_Consumer::check</code> as last argument.
        </para>
    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->