<sect1 id="zend.controller.exceptions">
    <title>Wyjątki MVC</title>

	<sect2 id="zend.controller.exceptions.introduction">
		<title>Wprowadzenie</title>

        <para>
            The MVC components in Zend Framework utilize a Front Controller,
            which means that all requests to a given site will go through a
            single entry point. As a result, all exceptions bubble up to the
            Front Controller eventually, allowing the developer to handle them
            in a single location.
        </para>

        <para>
            However, exception messages and backtrace information often contain
            sensitive system information, such as SQL statements, file
            locations, and more. To help protect your site, by default
            Zend_Controller_Front catches all exceptions and registers them with
            the response object; in turn, by default, the response object does
            not display exception messages.
        </para>
    </sect2>

    <sect2 id="zend.controller.exceptions.handling">
        <title>W jaki sposób możesz obsługiwać wyjątki?</title>

        <para>
            Obecnie w komponentach MVC wbudowanych jest kilka mechanizmów
            pozwalających na obsługę wyjątków
        </para>

        <itemizedlist>
            <listitem>
                <para>Zend_Controller_Front::throwExceptions()</para>

                <para>
                    Przekazująć logiczną wartość true do tej metody, możesz 
                    nakazać kontrolerowi frontowemu aby zamiast składować
                    wyjątki w obiekcie odpowiedzi, wyrzucił je, żebyś mógł
                    obsłużyć je samodzielnie. Na przykład:
                </para>

                <programlisting role="php"><![CDATA[<?php
$front->throwExceptions(true);
try {
    $front->dispatch();
} catch (Exception $e) {
    // sam obsłuż wyjątki
}
]]></programlisting>

                <para>
                    Ta metoda jest najprawdopodobniej najłatwiejszym sposobem
                    dodania własnej obsługi wyjątków do twojej aplikacji 
                    używającej kontrolera frontowego.
                </para>
            </listitem>

            <listitem>
                <para>Zend_Controller_Response_Abstract::renderExceptions()</para>

                <para>
                    Przekazując logiczną wartość true do tej metody, możesz
                    nakazać obiektowi odpowiedzi aby renderował on wyjątki gdy
                    sam będzie renderowany. W takim scenariuszu, każdy wyjątek
                    wyrzucony w twojej aplikacji będzie wyświetlony. To jest 
                    jedynie rekomendowane dla nieprodukcyjnych środowisk.
                </para>
            </listitem>

            <listitem>
                <para>Zend_Controller_Front::returnResponse() oraz
                    Zend_Controller_Response_Abstract::isException()</para>

                <para>
                    Przekazanie wartości logicznej true do metody 
                    Zend_Controller_Front::returnResponse(), spowoduje, że 
                    obiekt Zend_Controller_Front::dispatch() nie będzie 
                    renderował odpowiedzi, a zamiast tego ją zwróci. Gdy już
                    masz odpowiedź, możesz sprawdzić czy są w niej wyjątki
                    używając metody isException(), a następnie odebrać wyjątki
                    używając metody getException(). Na przykład:
                </para>

                <programlisting role="php"><![CDATA[<?php
$front->returnResponse(true);
$response = $front->dispatch();
if ($response->isException()) {
    $exceptions = $response->getException();
    // obsługa wyjątków ...
} else {
    $response->sendHeaders();
    $response->outputBody();
}
]]></programlisting>
                
                <para>
                    The primary advantage this method offers over
                    Zend_Controller_Front::throwExceptions() is to allow you to
                    conditionally render the response after handling the
                    exception.
                </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.controller.exceptions.internal">
        <title>Wyjątki MVC które możesz napotkać</title>

        <para>
            The various MVC components -- request, router, dispatcher, action
            controller, and response objects -- each may throw exceptions on
            occasion. Some exceptions may be conditionally overridden, and
            others are used to indicate the developer may need to consider
            their application structure.
        </para>

        <para>As some examples:</para>

        <itemizedlist>
            <listitem>
                <para>
                    Zend_Controller_Dispatcher::dispatch() domyślnie wyrzuci
                    wyjątek jeśli zażądano nieprawidłowego kontrolera. Są dwa
                    zalecane sposoby na obsłużenie tego:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>Ustawienie parametru 'useDefaultControllerAlways'.</para>

                        <para>
                            W twoim kontrolerze frontowym, lub w obiekcie 
                            uruchamiającym, dodaj poniższą dyrektywę:
                        </para>

                        <programlisting role="php"><![CDATA[<?php
$front->setParam('useDefaultControllerAlways', true);

// lub
$dispatcher->setParam('useDefaultControllerAlways', true);
]]></programlisting>

                        <para>
                            Gdy ta flaga jest ustawiona, obiekt uruchamiający, 
                            użyje domyślnego kontrolera oraz akcji zamiast
                            wyrzucania wyjątku. Minusem użycia tej metody jest 
                            to, że jakikolwiek błąd literowy w adresie 
                            dostępowym do twojej strony spowoduje wyświetlenie
                            strony głównej, co może źle wpłynąć na optymalizację
                            serwisu dla wyszukiwarek internetowych.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            Wyjątek wyrzucany przez metodę dispatch() jest
                            wyjątkiem Zend_Controller_Dispatcher_Exception 
                            zawierającym tekst 'Invalid controller specified'. 
                            Użyj jednej z metod opisanych w <xref 
                            linkend="zend.controller.exceptions.handling">poprzedniej
                            sekcji</xref> aby złapać wyjątek, a następnie 
                            przekierować do strony błędu lub do strony głownej.
                        </para>
                    </listitem>
                </itemizedlist>
            </listitem>

            <listitem>
                <para>
                    Zend_Controller_Action::__call() will throw an exception if
                    it cannot dispatch a non-existent action to a method. Most
                    likely, you will want to use some default action in the
                    controller in cases like this. Ways to achieve this include:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            Rozszerzenie klasy Zend_Controller_Action i 
                            nadpisanie metody __call(). Na przykład:
                        </para>

                        <programlisting role="php"><![CDATA[<?php
class My_Controller_Action extends Zend_Controller_Action
{
    public function __call($method, $args)
    {
        if ('Action' == substr($method, -6)) {
            $controller = $this->getRequest()->getControllerName();
            $url = '/' . $controller . '/index';
            return $this->_redirect($url);
        }

        throw new Exception('Invalid method');
    }
}
]]></programlisting>
                        <para>
                            The example above intercepts any undefined action
                            method called and redirects it to the default action
                            in the controller.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            Subclass Zend_Controller_Dispatcher and override the
                            getAction() method to verify the action exists.
                            As an example:
                        </para>

                        <programlisting role="php"><![CDATA[<?php
class My_Controller_Dispatcher extends Zend_Controller_Dispatcher
{
    public function getAction($request)
    {
        $action = $request->getActionName();
        if (empty($action)) {
            $action = $this->getDefaultAction();
            $request->setActionName($action);
            $action = $this->formatActionName($action);
        } else {
            $controller = $this->getController();
            $action     = $this->formatActionName($action);
            if (!method_exists($controller, $action)) {
                $action = $this->getDefaultAction();
                $request->setActionName($action);
                $action = $this->formatActionName($action);
            }
        }

        return $action;
    }
}
]]></programlisting>

                        <para>
                            The above code checks to see that the requested
                            action exists in the controller class; if not, it
                            resets the action to the default action.
                        </para>

                        <para>
                            This method is nice as you can transparently alter
                            the action prior to final dispatch. However, it also
                            means that typos in the URL may still dispatch
                            correctly, which is not great for search engine
                            optimization.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            Use Zend_Controller_Action::preDispatch() or 
                            Zend_Controller_Plugin_Abstract::preDispatch() to
                            identify invalid actions.
                        </para>

                        <para>
                            By subclassing Zend_Controller_Action and modifying
                            preDispatch(), you can modify all of your
                            controllers to forward to another action or redirect
                            prior to actually dispatching the action. The code
                            for this will look similar to the code for
                            overriding __call(), above.
                        </para>

                        <para>
                            Alternatively, you can check this information in a
                            global plugin. This has the advantage of being
                            action controller independent; if your application
                            consists of a variety of action controllers, and not
                            all of them inherit from the same class, this method
                            can add consistency in handling your various
                            classes.
                        </para>

                        <para>
                            Przykład:
                        </para>

                        <programlisting role="php"><![CDATA[<?php
class My_Controller_PreDispatchPlugin extends Zend_Controller_Plugin_Abstract
{
    public function preDispatch(Zend_Controller_Request_Abstract $request)
    {
        $dispatcher = Zend_Controller_Front::getInstance()->getDispatcher();
        $controller = $dispatcher->getController($request);
        if (!$controller) {
            $controller = $dispatcher->getDefaultControllerName($request);
        }
        $action     = $dispatcher->getAction($request);

        if (!method_exists($controller, $action)) {
            $defaultAction = $dispatcher->getDefaultAction();
            $controllerName = $request->getControllerName();
            $response = Zend_Controller_Front::getInstance()->getResponse();
            $response->setRedirect('/' . $controllerName . '/' . $defaultAction);
            $response->sendHeaders();
            exit;
        }
    }
}
]]></programlisting>
                        
                        <para>
                            W tym przykładzie sprawdzamy czy zażądana akcja 
                            jest dostępna w kontrolerze. Jeśli nie, 
                            przekierujemy żądanie do domyślnej akcji w 
                            kontrolerze, i kończymy wykonywanie skryptu.
                        </para>
                    </listitem>
                </itemizedlist>
            </listitem>
        </itemizedlist>
    </sect2>
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->
