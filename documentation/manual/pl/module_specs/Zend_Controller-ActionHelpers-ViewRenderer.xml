<sect3 id="zend.controller.actionhelpers.viewrenderer">
    <title>ViewRenderer</title>

    <sect4 id="zend.controller.actionhelper.viewrenderer.introduction">
        <title>Introduction</title>

        <para>
            The <code>ViewRenderer</code> helper is designed to satisfy the
            following goals:
        </para>

        <itemizedlist>
            <listitem><para>Eliminate the need to instantiate view objects
                    within controllers; view objects will be automatically
                    registered with the controller.</para></listitem>

            <listitem><para>Automatically set view script, helper, and filter
                    paths based on the current module, and automatically
                    associate the current module name as a class prefix for
                    helper and filter classes.</para></listitem>

            <listitem><para>Create a globally available view object for all
                    dispatched controllers and actions.</para></listitem>

            <listitem><para>Allow the developer to set default view rendering
                    options for all controllers.</para></listitem>

            <listitem><para>Add the ability to automatically render a view
                    script with no intervention.</para></listitem>
        </itemizedlist>

        <para>
            Eventually, we will also add the ability to define the schema used
            to autodetermine the view script to utilize.
        </para>

        <note>
            <para>
                If you perform a <code>_forward()</code> or redirect,
                autorendering will not occur, as by performing either of these
                actions it is assumed you have either explicitly rendered a
                script or do not want to do so.
            </para>
        </note>
    </sect4>

    <sect4 id="zend.controller.actionhelper.viewrenderer.api">
        <title>API</title>

        <para>
            At its most basic usage, you simply instantiate the
            <code>ViewRenderer</code> and pass it to the action helper broker:
        </para>

        <programlisting role="php"><![CDATA[<?php
Zend_Controller_Action_HelperBroker::addHelper(new Zend_Controller_Action_Helper_ViewRenderer());
]]></programlisting>
        
        <para>
            The first time <code>preDispatch()</code> is called, the
            <code>ViewRenderer</code> will instantiate a view object. Each time
            <code>preDispatch()</code> is called, it will set the view property
            of the action controller, and call <code>addScriptPath()</code> with
            a path relative to the current module; this will be called with a
            class prefix named after the current module, effectively namespacing
            all helper and filter classes you define for the module. 
        </para>

        <para>
            Each time <code>postDispatch()</code> is called, it will call
            <code>render()</code> for the current action. 
        </para>

        <para>
            As an example, consider the following class:
        </para>

        <programlisting role="php"><![CDATA[<?php
// A controller class, foo module:
class Foo_BarController extends Zend_Controller_Action
{
    // Render bar/index.phtml by default; no action required
    public function indexAction()
    {
    }

    // Render bar/populate.phtml with variable 'foo' set to 'bar'.
    // Since view object defined at preDispatch(), it's already available.
    public function populateAction()
    {
        $this->view->foo = 'bar';
    }
}
?>

// in one of your view scripts:
<?php $this->foo(); // call Foo_View_Helper_Foo::foo() ?>
]]></programlisting>

        <para>
            The <code>ViewRenderer</code> also defines a number of accessors to
            allow setting and retrieving view options:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>setView($view)</code> allows you to set the view
                    object for the <code>ViewRenderer</code>. It gets set as 
                    the public class property <code>$view</code>.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>setNeverRender($flag = true)</code> can be used to
                    disable or enable autorendering globally, i.e., for all
                    controllers. If set to true, <code>postDispatch()</code>
                    will not automatically call <code>render()</code> in the
                    current controller.  <code>getNeverRender()</code> retrieves
                    the current value.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>setNoRender($flag = true)</code> can be used to
                    disable or enable autorendering. If set to true,
                    <code>postDispatch()</code> will not automatically call
                    <code>render()</code> in the current controller. This
                    setting is reset each time <code>preDispatch()</code> is
                    called (i.e., you need to set this flag for each controller
                    for which you don't want autorenderering to occur).
                    <code>getNoRender()</code> retrieves the current value.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>setNoController($flag = true)</code> can be used to
                    tell <code>render()</code> not to look for the action script
                    in a subdirectory named after the controller (which is the
                    default behaviour). <code>getNoController()</code> retrieves
                    the current value.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>setScriptAction($name)</code> can be used to
                    specify the action script to render. <code>$name</code>
                    should be the name of the script minus the file suffix (and
                    without the controller subdirectory, unless
                    <code>noController</code> has been turned on). If not
                    specified, it looks for a view script named after the action
                    in the request object. <code>getScriptAction()</code>
                    retrieves the current value.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>setResponseSegment($name)</code> can be used to
                    specify which response object named segment to render into.
                    If not specified, it renders into the default segment.
                    <code>getResponseSegment()</code> retrieves the current
                    value.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>initView($path, $prefix, $options</code> may be called
                    to specify the base view path, class prefix for helper and
                    filter scripts, and <code>ViewRenderer</code> options. You
                    may pass any of the following flags:
                    <code>neverRender</code>, <code>noRender</code>,
                    <code>noController</code>, <code>scriptAction</code>, and
                    <code>responseSegment</code>.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>setRender($action = null, $name = null, $noController
                        = false)</code> allows you to set any of
                    <code>scriptAction</code>, <code>responseSegment</code>, and
                    <code>noController</code> in one pass. <code>direct()</code>
                    is an alias to this method, allowing you to call this method
                    easily from your controller:
                </para>

                <programlisting role="php"><![CDATA[
// Render 'foo' instead of current action script
$this->_helper->viewRenderer('foo');

// render form.phtml to the 'html' response segment, without using a
// controller view script subdirectory:
$this->_helper->viewRenderer('form', 'html', true);
]]></programlisting>

                <note><para>
                        <code>setRender()</code> and <code>direct()</code> don't
                        actually render the view script, but instead set hints
                        that <code>postDispatch()</code> uses to render the
                        view.
                </para></note>
            </listitem>
        </itemizedlist>

        <para>
            The constructor allows you to optionally pass the view object and
            <code>ViewRenderer</code> options; it accepts the same flags as
            <code>initView()</code>:
        </para>

        <programlisting role="php"><![CDATA[
$view    = new Zend_View(array('encoding' => 'UTF-8'));
$options = array('noController' => true, 'neverRender' => true);
$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer($view, $options);
]]></programlisting>
    </sect4>

    <sect4 id="zend.controller.actionhelper.viewrenderer.basicusage">
        <title>Basic Usage Examples</title>

        <example>
            <title>Basic Usage</title>

            <para>
                At its most basic, you simply add the <code>ViewRenderer</code>
                helper to the helper broker in your bootstrap, and then set
                variables in your action methods. 
            </para>

            <programlisting role="php"><![CDATA[<?php
// In your bootstrap:
Zend_Controller_Action_HelperBroker::addHelper(new Zend_Controller_Action_Helper_ViewRenderer());
?>

<?php
// A controller class, foo module:
class Foo_BarController extends Zend_Controller_Action
{
    // Render bar/index.phtml by default; no action required
    public function indexAction()
    {
    }

    // Render bar/populate.phtml with variable 'foo' set to 'bar'.
    // Since view object defined at preDispatch(), it's already available.
    public function populateAction()
    {
        $this->view->foo = 'bar';
    }

    // Renders nothing as it forwards to another action; the new action
    // will perform any rendering
    public function bazAction()
    {
        $this->_forward('index');
    }

    // Renders nothing as it redirects to another location
    public function batAction()
    {
        $this->_redirect('/index');
    }
}
?>
]]></programlisting>
        </example>

        <example>
            <title>Disabling autorender</title>

            <para>
                For some actions or controllers, you may want to turn off the
                autorendering -- for instance, if you're wanting to emit a
                different type of output (XML, JSON, etc), or if you simply want
                to emit nothing. You have two options: turn off all cases of
                autorendering (<code>setNeverRender()</code>), or simply turn it
                off for the current action (<code>setNoRender()</code>).
            </para>

            <note><para>
                In most cases, it makes no sense to turn off autorendering
                globally (ala <code>setNeverRender()</code>), as the only thing
                you then gain from <code>ViewRenderer</code> is the autosetup of
                the view object.
            </para></note>

            <programlisting role="php"><![CDATA[<?php
// Baz controller class, bar module:
class Bar_BazController extends Zend_Controller_Action
{
    public function fooAction()
    {
        // Don't auto render this action
        $this->_helper->viewRenderer->setNoRender();
    }
}

// Bat controller class, bar module:
class Bar_BatController extends Zend_Controller_Action
{
    public function preDispatch()
    {
        // Never auto render this controller's actions
        $this->_helper->viewRenderer->setNoRender();
    }
}
?>
]]></programlisting>
        </example>

        <example>
            <title>Choosing a different view script</title>

            <para>
                Some situations require that you render a different script than
                one named after the action. For instance, if you have a
                controller that has both add and edit actions, they may both
                display the same 'form' view, albeit with different values set.
                You can easily change the script name used with either
                <code>setScriptAction()</code>, <code>setRender()</code>, or
                calling the helper as a method, which will invoke
                <code>setRender()</code>.
            </para>

            <programlisting role="php"><![CDATA[<?php
// Bar controller class, foo module:
class Foo_BarController extends Zend_Controller_Action
{
    public function addAction()
    {
        // Render 'bar/form.phtml' instead of 'bar/add.phtml'
        $this->_helper->viewRenderer('form');
    }

    public function editAction()
    {
        // Render 'bar/form.phtml' instead of 'bar/edit.phtml'
        $this->_helper->viewRenderer->setScriptAction('form');
    }

    public function processAction()
    {
        // do some validation...
        if (!$valid) {
            // Render 'bar/form.phtml' instead of 'bar/process.phtml'
            $this->_helper->viewRenderer->setRender('form');
            return;
        }

        // otherwise continue processing...
    }

}
?>
]]></programlisting>
        </example>

        <example>
            <title>Modifying the registered view</title>

            <para>
                What if you need to modify the view object -- for instance,
                change the helper paths, or the encoding? You can do so either
                by modifying the view object set in your controller, or by
                grabbing the view object out of the <code>ViewRenderer</code>;
                both are references to the same object.
            </para>

            <programlisting role="php"><![CDATA[<?php
// Bar controller class, foo module:
class Foo_BarController extends Zend_Controller_Action
{
    public function preDispatch()
    {
        // change view encoding
        $this->view->setEncoding('UTF-8');
    }

    public function bazAction()
    {
        // Get view object and set escape callback to 'htmlspecialchars'
        $view = $this->_helper->viewRenderer->view;
        $view->setEscape('htmlspecialchars');
    }
}
?>
]]></programlisting>
        </example>
    </sect4>
</sect3>
<!--
vim:se ts=4 sw=4 et:
-->
