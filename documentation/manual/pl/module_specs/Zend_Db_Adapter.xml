<sect1 id="zend.db.adapter">

    <title>Zend_Db_Adapter</title>

    <sect2 id="zend.db.adapter.introduction">

        <title>Wprowadzenie</title>

        <para>
            <code>Zend_Db_Adapter</code> jest uniwersalnym interfejsem dostępu 
            do baz danych dla Zend Framework. Bazuje on na PDO. Używając interfejsu
            <code>Zend_Db_Adapter</code> możesz połączyć się z dowolnym wspieranym
            systemem bazodanowym używając tego samego API. Wspierane systemy to
            między innymi Microsoft SQL Server, MySQL, PostgreSQL, SQLite, i inne.
        </para>

        <para>Aby utworzyć instancję interfejsu <code>Zend_Db_Adapter</code> dla
        określonego systemu bazodanowego, musisz wywołać metodę <code>Zend_Db::factory()</code> 
        przekazując jej nazwę systemu bazodanowego oraz tablicę parametrów potrzebnych 
        do połączenia. Na przykład, aby połączyć się z bazą MySQL nazwaną "camelot" 
        znajdującą się pod adresem lokalnym, jako użytkownik "malory" możesz zrobić tak:</para>

        <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Db.php';

$params = array ('host'     => '127.0.0.1',
                 'username' => 'malory',
                 'password' => '******',
                 'dbname'   => 'camelot');

$db = Zend_Db::factory('PDO_MYSQL', $params);

?>]]></programlisting>

        <para>
            Podobnie, aby połączyć się z bazą SQLite nazwaną "camelot.sq3":
        </para>

        <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Db.php';

$params = array ('dbname' => 'camelot.sq3');

$db = Zend_Db::factory('PDO_SQLITE', $params);

?>]]></programlisting>

        <para>
            Podobnie, aby połączyć się z bazą danych SQLite2 o nazwie "camelot.sq2":
            Dla bazy sqlite opartej na pamięci nie określaj prefiksu dsn i użyj bazy
            danych o nazwie ":memory:".
        </para>

        <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Db.php';

$params = array ('dbname' => 'camelot.sq2',
                 'dsnprefix' => 'sqlite2');

$db = Zend_Db::factory('PDO_SQLITE', $params);

?>]]></programlisting>

        <para>
            W każdym z tych przypadków będziesz mógł używać takiego samego API
            aby tworzyć zapytania do bazy.
        </para>
    </sect2>

    <sect2 id="zend.db.adapter.quoting">

        <title>Zapobieganie atakom SQL Injection</title>

        <para>
            Powinieneś zawsze cytować wartości, które będą użyte w wyrażeniu SQL;
            zapobiega to atakom SQL Injection. <code>Zend_Db_Adapter</code> zapewnia
            dwie metody (poprzez obiekt PDO) aby pomóc Ci manualnie cytować wartości.
        </para>

        <para>
            Pierwsza z nich to metoda <code>quote()</code>.  It will quote a
            scalar value appropriately for your database adapter; if you
            attempt to quote an array, it will return a comma-separated
            string of the array values, each properly quoted (this is
            useful for functions that take a list parameter).
        </para>

        <programlisting role="php"><![CDATA[<?php

// create a $db object, assuming Mysql as the adapter.

// quote a scalar
$value = $db->quote('St John"s Wort');
// $value is now '"St John\"s Wort"' (note the surrounding quotes)

// quote an array
$value = $db->quote(array('a', 'b', 'c');
// $value is now '"a", "b", "c"' (a comma-separated string)

?>]]></programlisting>

        <para>
            The second is the <code>quoteInto()</code> method.  You provide a base
            string with a question-mark placeholder, and then one scalar
            or array to quote into it.  This is useful for constructing
            queries and clauses as-you-go.  Scalars and arrays work just
            as in the <code>quote()</code> method.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// create a $db object, assuming Mysql as the adapter.

// quote a scalar into a WHERE clause
$where = $db->quoteInto('id = ?', 1);
// $where is now 'id = "1"' (note the surrounding quotes)

// quote an array into a WHERE clause
$where = $db->quoteInto('id IN(?)', array(1, 2, 3));
// $where is now 'id IN("1", "2", "3")' (a comma-separated string)

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.queries">

        <title>Bezpośrednie zapytania</title>

        <para>
            Gdy posiadasz instancję <code>Zend_Db_Adapter</code>, możesz wykonywać
            zapytania bezpośrednio jako SQL. <code>Zend_Db_Adapter</code> przekazuje
            te zapytania do obiektu PDO, który je przygotowuje i wykonuje, a następnie
            zwraca Ci obiekt PDOStatement abyś mógł manipulować danymi wynikowymi 
            (jeśli jekieś są).
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// tworzymy obiekt $db, a następnie ...query... bazę
// with a properly-quoted SQL statement.
$sql = $db->quoteInto(
    'SELECT * FROM example WHERE date > ?',
    '2006-01-01'
);
$result = $db->query($sql);

// use the PDOStatement $result to fetch all rows as an array
$rows = $result->fetchAll();

?>]]></programlisting>

        <para>
            You may bind data into your query automatically.  This means
            you can set multiple named placeholders in the query, and
            then pass an array of data that is substituted for those
            placeholders.  The substituted values are automatically
            quoted for you, providing greater security against SQL
            injection attacks.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// create a $db object, and then query the database.
// this time, use placeholder binding.
$result = $db->query(
    'SELECT * FROM example WHERE date > :placeholder',
    array('placeholder' => '2006-01-01')
);

// use the PDOStatement $result to fetch all rows as an array
$rows = $result->fetchAll();

?>]]></programlisting>

        <para>
            Optionally, you may wish to prepare and bind data to SQL statements
            manually.  To do so, use the <code>prepare()</code> method to get a prepared
            <code>PDOStatement</code> that you can manipulate directly.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// create a $db object, and then query the database.
// this time, prepare a PDOStatement for manual binding.
$stmt = $db->prepare('SELECT * FROM example WHERE date > :placeholder');
$stmt->bindValue('placeholder', '2006-01-01');
$stmt->execute();

// use the PDOStatement to fetch all rows as an array
$rows = $stmt->fetchAll();

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.transactions">

        <title>Transakcje</title>

        <para>
            Domyślnie, PDO (a więc i <code>Zend_Db_Adapter</code>) działają w trybie
            "auto-commit". Oznacza to, że wszystkie zapytania są realizowane natychmiast
            po ich wykonaniu. Jeśli chcesz je wykonać wewnątrz transakcji, w prosty sposób
            wywołak metodę <code>beginTransaction()</code>, a następnie <code>commit()</code>
            aby zrealizować zapytania lub <code>rollBack()</code> aby je cofnąć.
            <code>Zend_Db_Adapter</code> wraca wtedy do trybu "auto-commit" dopóki
            znów nie wywołasz metody <code>beginTransaction()</code>.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// utwórz obiekt $db, a następnie rozpocznij transakcję
$db->beginTransaction();

// attempt a query.
// if it succeeds, commit the changes;
// if it fails, roll back.
try {
    $db->query(...);
    $db->commit();
} catch (Exception $e) {
    $db->rollBack();
    echo $e->getMessage();
}

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.insert">

        <title>Wstawianie wierszy</title>

        <para>
            As a convenience, you may use the <code>insert()</code> method to create
            an INSERT statement for you and bind data to be inserted into it.
            (The bound data is quoted for you automatically to help prevent
            SQL injection attacks.)
        </para>

        <para>
            Zwracana wartość <emphasis>nie</emphasis> jest ostatnio wstawionym 
            numerem ID, ponieważ tabela nie musi posiadać automatycznie inkrementowanej
            kolumny;  zwracana wartość jest liczbą wstawionych wierszy (najczęściej 1). 
            Jeśli chcesz otrzymać wartość ID ostatnio wstawionego rekordu, wywołaj 
            metodę <code>lastInsertId()</code> po wstawieniu rekordu.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// INSERT INTO round_table
//     (noble_title, first_name, favorite_color)
//     VALUES ("King", "Arthur", "blue");
//

// tworzymy obiekt $db, a następnie...
// dane do wstawienia w postaci nazwa_kolumny => wartość
$row = array (
    'noble_title'    => 'King',
    'first_name'     => 'Arthur',
    'favorite_color' => 'blue',
);

// nazwa tabeli do której ma być wstawiony wiersz
$table = 'round_table';

// wstawiamy wiersz i pobieramy jego ID
$rows_affected = $db->insert($table, $row);
$last_insert_id = $db->lastInsertId();

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.update">

        <title>Aktualizowanie wierszy</title>

        <para>
            As a convenience, you may use the <code>update()</code> method to create
            an UPDATE statement for you and bind data to be updated into it.
            (The bound data is quoted for you automatically to help prevent
            SQL injection attacks.)
        </para>

        <para>
            You may provide an optional WHERE clause
            to tell which rows to update.  (Note that the WHERE clause is not
            a bound parameter, so you need to quote values in it yourself.)
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// UPDATE round_table
//     SET favorite_color = "yellow"
//     WHERE first_name = "Robin";
//

// tworzymy obiekt $db, a następnie...
// dane do aktualizowania w postaci nazwa_kolumny => wartość
$set = array (
    'favorite_color' => 'yellow',
);

// nazwa tabeli w której ma być aktualizowany wiersz
$table = 'round_table';

// warunek WHERE
$where = $db->quoteInto('first_name = ?', 'Robin');

// uaktualniamy tabelę i pobieramy liczbę uaktualnionych wierszy
$rows_affected = $db->update($table, $set, $where);

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.delete">

        <title>Usuwanie wierszy</title>

        <para>
            As a convenience, you may use the <code>delete()</code> method to create
            a DELETE statement for you; you may provide an optional WHERE clause
            to tell which rows to delete.  (Note that the WHERE clause is not
            a bound parameter, so you need to quote values in it yourself.)
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// DELETE FROM round_table
//     WHERE first_name = "Patsy";
//

// tworzymy obiekt $db, a następnie...
// nazwa tabeli z której usuwamy wiersz
$table = 'round_table';

// warunek WHERE
$where = $db->quoteInto('first_name = ?', 'Patsy');

// usuwamy wiersz i pobieramy liczbę usuniętych wierszy
$rows_affected = $db->delete($table, $where);

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.fetch">

        <title>Pobieranie wierszy</title>

        <para>
            Although you may query the database directly with the <code>query()</code>
            method, frequently all you need to do is select rows and get
            the results.  The <code>fetch*()</code> series of methods does this for you.
            For each of the <code>fetch*()</code> methods, you pass an SQL SELECT
            statement; if you use named placeholders in the statement, you
            may also pass an array of bind values to be quoted and replaced
            into the statement for you.  The <code>fetch*()</code> methods are:
        </para>

        <itemizedlist>
            <listitem><para><code>fetchAll()</code></para></listitem>
            <listitem><para><code>fetchAssoc()</code></para></listitem>
            <listitem><para><code>fetchCol()</code></para></listitem>
            <listitem><para><code>fetchOne()</code></para></listitem>
            <listitem><para><code>fetchPairs()</code></para></listitem>
            <listitem><para><code>fetchRow()</code></para></listitem>
        </itemizedlist>

        <programlisting role="php"><![CDATA[<?php
	
// tworzymy obiekt $db, a następnie...

// pobieramy wszystkie kolumny wszystkich wierszy jako sekwencyjną tablicę
$result = $db->fetchAll(
    "SELECT * FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// pobieramy wszystkie kolumny wszystkich wierszy jako tablicę
// asocjacyjną; pierwsza kolumna jest używana jako klucz tablicy
$result = $db->fetchAssoc(
    "SELECT * FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// pobieramy pierwszą kolumnę wszystkich zwróconych wierszy
$result = $db->fetchCol(
    "SELECT first_name FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// pobieramy tylko pierwszą zwróconą wartość
$result = $db->fetchOne(
    "SELECT COUNT(*) FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// pobieramy serię par klucz-wartość; pierwsza kolumna jest
// kluczem tablicy, a druga jest wartością
$result = $db->fetchPairs(
    "SELECT first_name, favorite_color FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// pobieramy tylko pierwszy zwrócony wiersz
$result = $db->fetchRow(
    "SELECT * FROM round_table WHERE first_name = :name",
    array('name' => 'Lancelot')
);

?>]]></programlisting>
    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
