<sect1 id="zend.controller.plugins">
    <title>Wtyczki</title>

    <sect2 id="zend.controller.plugins.introduction">
        <title>Wprowadzenie</title>

        <para>
            Architektura kontrolera zawiera także system wtyczek, który pozwala
            programiście na wykonanie własnego kodu, gdy następują określone
            zdarzenia w trakcie trwania procesu kontrolera. Kontroler frontowy
            używa agenta wtyczek jako rejeestru dla wtyczek programisty,
            a agent wtyczek jest odpowiedzialny za to, że metody zdarzeń są
            wywoływane dla każdej wtyczki zarejestrowanej w kontrolerze 
            frontowym.
        </para>

        <para>
            Metody zdarzeń są zdefiniowane w klasie abstrakcyjnej
            <code>Zend_Controller_Plugin_Abstract</code>, z której dziedziczy
            każda klasa wtyczki:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>
                    <code>routeStartup()</code> is called before
                    <code>Zend_Controller_Front</code> calls on <link
                        linkend="zend.controller.router">the router</link>
                    to evaluate the request against the registered routes.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>routeShutdown()</code> is called after <link
                        linkend="zend.controller.router">the router</link>
                    finishes routing the request.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>dispatchLoopStartup()</code> is called before
                    <code>Zend_Controller_Front</code> enters its dispatch loop.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>preDispatch()</code> is called before an action is
                    dispatched by <link linkend="zend.controller.dispatcher">the
                        dispatcher</link>. This callback allows for proxy or
                    filter behavior. By altering the request and resetting its
                    dispatched flag (via
                    <code>Zend_Controller_Request_Abstract::setDispatched(false)</code>),
                    the current action may be skipped and/or replaced.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>postDispatch()</code> is called after an action is
                    dispatched by <link linkend="zend.controller.dispatcher">the
                        dispatcher</link>. This callback allows for proxy or
                    filter behavior. By altering the request and resetting its
                    dispatched flag (via
                    <code>Zend_Controller_Request_Abstract::setDispatched(false)</code>),
                    a new action may be specified for dispatching.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>dispatchLoopShutdown()</code> is called after
                    <code>Zend_Controller_Front</code> exits its dispatch loop.
                </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.controller.plugins.writing">
        <title>Pisanie wtyczek</title>

        <para>
            W celu napisania klasy wtyczki, w prosty sposób rozszerz klasę 
            abstrakcyjną <code>Zend_Controller_Plugin_Abstract</code>:
        </para>

        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Controller/Plugin/Abstract.php';

class MyPlugin extends Zend_Controller_Plugin_Abstract
{
    // ...
}
?>]]></programlisting>

        <para>
            Żadna z metod klasy <code>Zend_Controller_Plugin_Abstract</code> nie 
            jest abstrakcyjna, co oznacza, że nie jest konieczne implementowanie 
            wszystkich dostępnych metod zdarzeń opisanych powyżej. Autor wtyczki 
            może zaimplementować tylko te metody zdarzeń, które są mu 
            rzeczywiście potrzebne.
        </para>
        <para>
            <code>Zend_Controller_Plugin_Abstract</code> udostępnia także 
            obiekty żądania i odpowiedzi wtyczkom kontrolera za pomocą metod 
            <code>getRequest()</code> oraz <code>getResponse()</code>, odpowiednio.
        </para>
    </sect2>

    <sect2 id="zend.controller.plugins.using">
        <title>Użycie wtyczek</title>
        <para>
            Klasy wtyczek są rejestrowane za pomocą metody 
            <code>Zend_Controller_Front::registerPlugin()</code> i mogą być 
            rejestrowane w dowolnym momencie. Poniższy kod pokazuje w jaki 
            sposób wtyczka może być użyta przez kontroler:
        </para>
            
        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Controller/Front.php';
require_once 'Zend/Controller/Router.php';
require_once 'Zend/Controller/Plugin/Abstract.php';

class MyPlugin extends Zend_Controller_Plugin_Abstract
{
    public function routeStartup()
    {
        $this->getResponse()->appendBody("<p>Wywołano metodę routeStartup()</p>\n");
    }

    public function routeShutdown($request)
    {
        $this->getResponse()->appendBody("<p>Wywołano metodę routeShutdown()</p>\n");
    }

    public function dispatchLoopStartup($request)
    {
        $this->getResponse()->appendBody("<p>Wywołano metodę dispatchLoopStartup()</p>\n");
    }

    public function preDispatch($request)
    {
        $this->getResponse()->appendBody("<p>Wywołano metodę preDispatch()</p>\n");
    }

    public function postDispatch($request)
    {
        $this->getResponse()->appendBody("<p>Wywołano metodę postDispatch()</p>\n");
    }

    public function dispatchLoopShutdown()
    {
        $this->getResponse()->appendBody("<p>Wywołano metodę dispatchLoopShutdown()</p>\n");
    }
}

$front = Zend_Controller_Front::getInstance();
$front->setControllerDirectory('/path/to/controllers')
      ->setRouter(new Zend_Controller_Router_Rewrite())
      ->registerPlugin(new MyPlugin());
$front->dispatch();
]]></programlisting>

        <para>
           Assuming that no actions called emit any output, and only one action
           is called, the functionality of the above plugin would still create
           the following output:
        </para>

        <programlisting role="php"><![CDATA[
<p>Wywołano metodę routeStartup()</p>
<p>Wywołano metodę routeShutdown()</p>
<p>Wywołano metodę dispatchLoopStartup()</p>
<p>Wywołano metodę preDispatch()</p>
<p>Wywołano metodę postDispatch()</p>
<p>Wywołano metodę dispatchLoopShutdown()</p>
]]></programlisting>

        <note>
            Wtyczki mogą być zarejestrowane w dowolnym momencie ...during... 
            uruchomieniem kontrolera frontowego.
            However, if an event has passed for which the plugin has
            a registered event method, that method will not be triggered.
        </note>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
