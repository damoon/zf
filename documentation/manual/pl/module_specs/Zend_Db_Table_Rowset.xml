<sect1 id="zend.db.table.rowset">

    <title>Zend_Db_Table_Rowset</title>

    <sect2 id="zend.db.table.rowset.introduction">

        <title>Introduction</title>

        <para>
            When you run a query against a Table class using the
            <code>find()</code> or <code>fetchAll()</code> methods,
            the result is returned in an object of type Zend_Db_Table_Rowset.
            A Rowset contains a collection of Zend_Db_Table_Row objects.
            You can iterate through the Rowset and access individual Row
            objects, reading or modifying data in the Rows.
        </para>

    </sect2>

    <sect2 id="zend.db.table.rowset.fetch">

        <title>Fetching a Rowset</title>

        <para>
            Zend_Db_Table_Abstract provides methods <code>find()</code> and
            <code>fetchAll()</code>, which each return an object of type
            Zend_Db_Table_Rowset.
        </para>

        <example id="zend.db.table.rowset.fetch.example">
            <title>Example of fetching a rowset</title>
            <programlisting role="php"><![CDATA[<?php

$bugs   = new Bugs();
$rowset = $bugs->fetchAll("bug_status = 'NEW'");

?>]]></programlisting>
        </example>

        <para>
            The simplest way to access a Row from this Rowset is to use
            the <code>current()</code> method.
        </para>

        <example id="zend.db.table.rowset.fetch.example-row">
            <title>Example of reading a row from a rowset</title>
            <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$rowset = $bugs->fetchAll("bug_status = 'NEW'");
$row = $rowset->current();

?>]]></programlisting>
        </example>

        <para>
            After you have access to an individual Row object, you can
            manipulate the Row using methods described in
            <xref linkend="zend.db.table.row"/>.
        </para>

    </sect2>

    <sect2 id="zend.db.table.rowset.iterate">

        <title>Iterating Through the Rowset</title>

        <para>
            The Zend_Db_Table_Rowset object implements the iterator interface,
            which means you can loop through Zend_Db_Table_Rowset objects
            using <code>foreach()</code>.
            Each value you retrieve this way is a Zend_Db_Table_Row object
            that corresponds to one record from the table.
        </para>

        <example id="zend.db.table.rowset.iterate.example">
            <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();

// fetch all records from the table
$rowset = $bugs->fetchAll();

foreach ($rowset as $row) {

    // output 'Zend_Db_Table_Row'
    echo get_class($row) . "\n";

    // read a column in the row
    $status = $row->bug_status;

    // modify a column in the current row
    $row->assigned_to = 'mmouse';

    // write the change to the database
    $row->save();
}

?>]]>
            </programlisting>
        </example>

    </sect2>

    <sect2 id="zend.db.table.rowset.to-array">

        <title>Retrieving a Rowset as an Array</title>

        <para>
            You can access the all data in the rowset as an array using the
            <code>toArray()</code> method of the Rowset object.
            This returns an array containing one entry per row.
            Each entry is in turn an associative array of the colum names
            to the column values.
        </para>

        <example id="zend.db.table.rowset.to-array.example">
            <title>Example of using the toArray() method</title>
            <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$rowset = $bugs->fetchAll();

$rowsetArray = $rowset->toArray();

foreach ($rowsetArray as $rowArray) {
    echo $rowArray['assigned_to'] . "\n";
}

?>]]></programlisting>
        </example>

        <para>
            The array returned from <code>toArray()</code> is not updateable.
            You can modify values in the array as you can with any array, but
            you cannot save changes to this array to the database directly.
        </para>

    </sect2>

    <sect2 id="zend.db.table.rowset.other">

        <title>Using other Rowset Methods</title>

        <para>
            A legitimate query may return zero rows, because no rows
            in the database match the query conditions.
            Therefore a Rowset object might be a valid object,
            but contain zero Row objects.
            You can query if a Rowset contains any Rows using the
            <code>exists()</code> method.
            This method returns Boolean <code>true</code> or <code>false</code>
        </para>

        <example id="zend.db.table.rowset.other.example-exists">
            <title>Example of using the exists() method</title>
            <programlisting role="php"><![CDATA[<?php

$rowset = $bugs->fetchAll("bug_status = 'FIXED'"); // might return zero rows

if ($rowset->exists()) {
    // the rowset contains at least one row
}

?>]]></programlisting>
        </example>

        <para>
            You can query how many Rows the Rowset contains using the
            <code>count()</code> method.  This method returns a non-negative
            integer.
        </para>

        <example id="zend.db.table.rowset.other.example-count">
            <title>Example of using the count() method</title>
            <programlisting role="php"><![CDATA[<?php

$rowset = $bugs->fetchAll("bug_status = 'FIXED'");

$numRows = $rowset->count();

?>]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.db.table.rowset.serialize">

        <title>Serializing and Unserializing a Rowset</title>

        <para>
            Objects of type Zend_Db_Table_Rowset_Abstract are serializable.
            In a similar fashion to serializing an individual Row object,
            you can serialize a Rowset and unserialize it later.
        </para>

        <sect3 id="zend.db.table.rowset.serialize.serializing">
            <title>Serializing a Rowset</title>

            <para>
                Simply use PHP's <code>serialize()</code> function to
                create a string containing a byte-stream representation
                of the Rowset object argument.
            </para>

            <example id="zend.db.table.rowset.serialize.serializing.example">
                <title>Example of serializing a rowset</title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$rowset = $bugs->fetchAll();

// Convert object to serialized form
$serializedRowset = serialize($rowset);

// Now you can write $serializedRowset to a file, etc.

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.rowset.serialize.unserializing">
            <title>Unserializing a Rowset</title>

            <para>
                Use PHP's <code>unserialize()</code> function to
                restore a string containing a byte-stream representation
                of an object.  The function returns the original object.
            </para>

            <para>
                Note that the Rowset object returned is in a
                <emphasis>disconnected</emphasis> state.
                You can iterate through the Rowset and read the Row objects
                and their properties, but you cannot change values in the
                Rows or execute other methods that require a database 
                connection (for example, queries against related tables).
            </para>

            <example id="zend.db.table.rowset.serialize.unserializing.example">
                <title>Example of unserializing a serialized rowset</title>
                <programlisting role="php"><![CDATA[<?php

$rowsetClone = unserialize($serializedRowset);

// Now you can use object methods and properties, but read-only
$row = $rowsetClone->current();
echo $row->bug_description;

?>]]></programlisting>
            </example>

            <note>
                <title>Why do Rowsets unserialize in a disconnected state?</title>
                <para>
                    A serialized object is a string that is readable to
                    anyone who possesses it.
                    It could be a security risk to store parameters such
                    as database account and password in plain, unencrypted
                    text in the serialized string.
                    You would not want to store such data to a text file that
                    is not protected, or send it in an email or other medium
                    that is easily read by potential attackers.
                    The reader of the serialized object should not be able
                    to use it to gain access to your database without
                    knowing valid credentials.
                </para>
            </note>

        </sect3>

        <sect3 id="zend.db.table.rowset.serialize.set-table">
            <title>Reactivating a Rowset as Live Data</title>

            <para>
                You can reactivate a disconnected Rowset, using the
                <code>setTable()</code> method.  The argument to this
                method is a valid object of type Zend_Db_Table_Abstract,
                which you create.  Creating a Table object requires a
                live connection to the database, so by reassociating
                the Table with the Rowset, the Rowset gains access to 
                the database.  Subsequently, you can change values in
                the Row objects contained in the Rowset and save the
                changes to the database.
            </para>

            <example id="zend.db.table.rowset.serialize.set-table.example">
                <title>Example of reactivating a rowset</title>
                <programlisting role="php"><![CDATA[<?php

$rowsetClone = unserialize($serializedRowset);

$bugs = new Bugs();

// Reconnect the rowset to a table, and
// thus to a live database connection
$rowsetClone->setTable($bugs);

$row = $rowsetClone->current();

// Now you can make changes to the row and save them
$row->bug_status = 'FIXED';
$row->save();

?>]]></programlisting>
            </example>

            <para>
                Reactivating a Rowset with <code>setTable()</code> also
                reactivates all the Row objects contained in that Rowset.
            </para>

            <para>
                This reactivates only the one specific Rowset object,
                not any other Rowset objects, or the Rows contained
                in them, even if those Rows correspond to the same
                database rows in a Rowset you have activated.
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.rowset.extending">

        <title>Extending the Rowset class</title>

        <para>
            <emphasis>To be written.</emphasis>
        </para>

    </sect2>


</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
