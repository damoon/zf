<sect1 id="zend.cache.introduction">
    <title>Wprowadzenie</title>
    <para>
        <code>Zend_Cache</code> zapewnia proste sposoby cachowania danych.
    </para>
    <para>
        Cachowane zasoby są przechowywane przez backend (<code>File</code>, <code>Sqlite</code>...) 
        używając elastycznego systemu identyfikatorów i tagów. Dzięki temu można łatwo 
        usuwać części cachowanych danych ("wszystkie rekordy cache oznaczone danym tagiem"...).
    </para>
    <para>
        Jądro tego modułu jest naprawdę proste i elastyczne. Obecnie, zależnie od potrzeb
        możesz użyć frontendu (<code>Output</code>, <code>Function</code>...) aby
        uzyskać odpowiednie działanie.
    </para>
    <example>
        <title>Pierwszy przykład Zend_Cache</title>
        <para>
            W pierwszym przykładzie użyjemy bezpośrednio głównej klasy Zend_Cache 
            używając jako backendu pliku - <code>File</code>.
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
	'lifeTime' => 7200 // okres ważności 2 godziny
);

$backendOptions = array(
    'cacheDir' => '/tmp/' // Katalog w którym będą przechowywane pliki cache
);

// Potrzebujemy obiekt Zend_Cache_Core
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

$id = 'foo'; // nadajemy identyfikator zasobowi który cachujemy

if (!($cache->test($id))) {
	// brak cachu
	
	// require_once ... ze względów wydajnościowych wszystkie pliki powinny być 
	// ładowane tylko wtedy gdy zasób nie posiada cachu
	// require_once ...
	
	// tworzymy zasób których chcemy cachować
	// na przykład
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	} 
	
	// zapisujemy rezultat w cache
    $cache->save($data);

} else {
	// wyciągamy dane z cache
	
	$data = $cache->get($id);

}

// używanym do czegoś danych $data :)
// [...]
?>]]>       </programlisting>
       </para>
    </example>
    <note>
        Za pomocą Zend_Cache_Core, możesz sam zarządzać identyfikatorami cachu.
    </note>
</sect1>

<sect1 id="zend.cache.factory">
    <title>Fabryka Zend_Cache</title>
    <para>
        Jest tylko jedna metoda utworzenia obiektu <code>Zend_Cache_*</code>. We
        wszystkich przypadkach (backendów oraz/lub frontendów), musisz użyć 
        fabryki <code>Zend_Cache</code>. Nie używaj bezpośrednio konstruktorów
        frontendów, ponieważ nie będzie to działało prawidłowo!
    </para>
    <para>
        Dobrą metodą utworzenia użytecznej instancji obiektu <code>Zend_Cache_*</code> 
        jest ta przedstawiona w tym przykładzie:
    	<programlisting role="php"><![CDATA[<?php
    	
# Ładujemy fabrykę Zend_Cache
require 'Zend/Cache.php'; 

# Wybieramy backend (na przykład 'File' lub 'Sqlite'...)
$backendName = '[...]';

# Wybieramy frontend (na przykład 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# Ustawiamy tablicę opcji dla wybranego frontendu
$frontendOptions = array([...]);

# Ustawiamy tablicę opcji dla wybranego backendu
$backendOptions = array([...]);

# Tworzymy instancję
# (oczywiście dwa ostatnie argumenty są opcjonalne)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

[...]

?>]]>   </programlisting> 
    </para> 
    <para>
        W dalszej części dokumentacji założymy, że zmienna <code>$cache</code>
        została utworzona w taki sposób jak w powyższym przykładzie.
    </para> 
</sect1>

<sect1 id="zend.cache.core">
    <title>Zend_Cache_Core</title>
    <sect2 id="zend.cache.core.introduction">
    	<title>Wprowadzenie</title>
    	<para>
    		<code>Zend_Cache_Core</code> jest specjalnym frontendem, ponieważ jest
    		aktualnie jądrem modułu. Wszystkie frontendy dziedziczą po tej klasie,
    		więc większość metod i opcji opisanych poniżej jest także dostępna 
    		w innych frontendach.
    	</para>
    </sect2>
    <sect2 id="zend.cache.core.options">
    	<title>Dostępne opcje (dla frontendu z Zend_Cache)</title>
	    <table>
    		<title>Dostępne opcje</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Opcja</entry>
				        <entry>Typ danych</entry>
				        <entry>Domyślna wartość</entry>
				        <entry>Opis</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>caching</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
      						Włącza / wyłącza cachowanie (może być bardzo użyteczne
      						przy szukaniu błędów w cachowanych skryptach)
      					</entry>
      				</row>
      				<row>
      					<entry><code>lifeTime</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>3600</code></entry>
      					<entry>
        					Okres ważności (w sekundach), jeśli ustawiony na 
        					<code>null</code>, to cache jest ważny cały czas.
      					</entry>
      				</row>
      				<row>
      					<entry><code>logging</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>false</code></entry>
      					<entry>
        					Jeśli ustawione na true, aktywowane jest logowanie za
        					pomocą <code>Zend_Log</code> (ale zwalnia to system)
      					</entry>
      				</row>
      				<row>
      					<entry><code>writeControl</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Włącza / wyłącza kontrolę zapisu (cache jest odczytywany
        					zaraz po zapisaniu w celu sprawdzenia poprawności). Włączenie
        					opcji writeControl może lekko zwolnić czas zapisywania cachu, ale
        					nie ma wpływu na odczytywanie. (wykrywa to niektóre uszkodzone 
        					pliki cachu, ale nie zapewnia to perfekcyjnej kontroli)
      					</entry>
      				</row>
      				<row>
      					<entry><code>automaticSerialization</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>false</code></entry>
      					<entry>
        					Włącza / wyłącza automatyczną serializację, może być użyta
        					w celu bezpośredniego zapisywania danych nie będących łańcuchami
        					znaków (ale jest to wolniejsze).
      					</entry>
      				</row>
      				<row>
      					<entry><code>automaticCleaningFactor</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0</code></entry>
      					<entry>
                            Wyłącza / włącza proces automatycznego czyszczecnia cachu (garbage collector) :
        					0 oznacza brak automatycznego czyszczenia, 1 oznacza systematyczne czyszczenie cachu,
        					a x (liczba całkowita) &gt; 1 oznacza automatyczne czyszczenie losowo 1 raz na x
        					zapisań cachu.
      					</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    </sect2>
    <sect2 id="zend.cache.core.examples">
    	<title>Przykłady</title>
    	<para>
    	    Pierwszy przykład został pokazany na samym początku rozdziału.
    	</para>
    	<para>
    	    Jeśli w cachu przechowujesz jedynie łańcuchy znaków (dzięki opcji
    	    "automaticSerialization", możliwe jest przechowywane wartości 
    	    logicznych), możesz użyć bardziej zwięzłej konstrukcji:
     	    <programlisting role="php"><![CDATA[<?php  
     	    
// [...] // wymagane: konfiguracja i tworzenie obiektu

$id = 'foo'; // identyfikator cachowanego zasobu

if (!($data = $cache->get($id))) {
	// brak cachu
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	}
	
    $cache->save($data);
    
} 

// [...] robimy coś z danymi $data (na przykład "echo $data;")
     	    
?>]]>       </programlisting> 
        </para>  
        <para>
            Jeśli chcesz cachować wiele bloków lub danych, idea jest ta sama:
     	    <programlisting role="php"><![CDATA[<?php  
     	    
// [...] // wymagane: konfiguracja i tworzenie obiektu

$id1 = 'foo'; // cachowany zasób o identyfikatorze block1
$id2 = 'bar'; // cachowany zasób o identyfikatorze block2

// BLOCK1
if (!($data = $cache->get($id1))) {
	// brak cachu
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	}
	
    $cache->save($data);
    
} 
echo($data);

// BLOK NIGDY NIE CACHOWANY
echo('NEVER CACHED !');

// BLOCK2
if (!($data = $cache->get($id2))) {
	// brak cachu
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . '!';
	}
	
    $cache->save($data);
    
} 
echo($data);


?>]]>       </programlisting>         	
        </para>   	 	
    </sect2>   
    <sect2 id="zend.cache.core.idandtags">
    	<title>Identyfikatory cachu i tagi</title>
    	<para>
    		Identyfikator cachu jest unikatowym kluczem nadanym rekordowi cache. 
    		W niektórych frontendach (Core, Output...), musisz sam zarządzać 
    		identyfikatorami, więc musisz być ostrożny aby dla danej strony
    		czy bloku użyć unikatowego id.
    	</para>
    	<para>
    		"Tagi" są sposobem kategoryzowania rekordów. Kiedy zapisujesz cache za
    		pomocą metody <code>save()</code>, możesz ustawić tablicę tagów dla danego
    		rekordu. Teraz będziesz w stanie wyczyścić rekordy cachu, które mają przypisany
    		konkretny tag. Jest to bardzo skuteczna metoda zarządzania grupami rekordów.
    	</para>
    	<para>
    		Oto przykładowa składnia metody <code>save()</code>:
    		<programlisting role="php"><![CDATA[<?php
     	    
    /**
     * Save some data in a cache 
     * 
     * @param mixed $data data to put in cache (can be another type than string if automaticSerialization is on)
     * @param cache $id cache id (if not set, the last cache id will be used)
     * @param array $tags cache tags
     * @return boolean true if no problem
     */
    public function save($data, $id = null, $tags = array()) {}
    		
?>]]>       </programlisting>    	 
			Na przykład możesz użyć:
			<programlisting role="php"><![CDATA[<?php
			
// [...]
$cache->save('dane do cachowania', 'uniqueID', array('tag1', 'tag4', 'tag5'));
// [...]	
			
?>]]>       </programlisting> 						   	
    	</para>
    </sect2>
    <sect2 id="zend.cache.core.clean">
    	<title>Czyszczenie cachu</title>
    	<para>
    		Aby usunąć rekord o określonym id, możesz użyć metody
    		<code>remove()</code>:
     	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->remove('idDoUsuniecia');
// [...]
    		
?>]]>       </programlisting>    		
    	</para>
    	<para>
    		Aby usunąć więcej rekordów w jednej operacji możesz użyć metody 
    		<code>clean()</code>. Na przykład tak możesz usunąć wszystkie rekordy:
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);
// [...]
    		
?>]]>       </programlisting>     		
            Jeśli chcesz usunąć jedynie rekordy, które straciły ważność:
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
// [...]
    		
?>]]>       </programlisting>
            Jeśli chcesz usunąć rekordy cache odpowiadające tagom 'tag1' oraz 'tag3':
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tag1', 'tag3'));
// [...]
    		
?>]]>       </programlisting>
			[...]	
    	</para>
    </sect2>
</sect1>
<sect1 id="zend.cache.output">
    <title>Zend_Cache_Output</title>
    <para>
    	DO NAPISANIA
    </para>
</sect1>    
<sect1 id="zend.cache.page">
    <title>Zend_Cache_Page</title>
    <para>
    	DO NAPISANIA
    </para>
</sect1>  
<sect1 id="zend.cache.file">
    <title>Zend_Cache_File</title>
    <para>
    	DO NAPISANIA
    </para>
</sect1> 
<sect1 id="zend.cache.function">
    <title>Zend_Cache_Function</title>
    <para>
    	DO NAPISANIA
    </para>
</sect1> 
<sect1 id="zend.cache.class">
    <title>Zend_Cache_Class</title>
    <para>
    	DO NAPISANIA
    </para>
</sect1> 
<sect1 id="zend.cache.backends">
    <title>Backendy dostępne dla Zend_Cache</title>
    <sect2 id="zend.cache.backends.file">
    	<title>Zend_Cache_Backend_File</title>
    	<para>
    		Ten backend przechowuje rekordy cachu w plikach (w wybranycm katalogu). 
    	</para>
    	<para>
    		Dostępne opcje to:
    	</para>  		
	    <table>
    		<title>Dostępne opcje</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Opcja</entry>
				        <entry>Typ danych</entry>
				        <entry>Domyślna wartość</entry>
				        <entry>Opis</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>cacheDir</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>'/tmp/'</code></entry>
      					<entry>
      						Katalog w którym będą przechowywane pliki cache.
      					</entry>
      				</row>
      				<row>
      					<entry><code>fileLocking</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Włącza / wyłącza blokowanie dostępu do plików: w pewnych
        					okolicznościach może to zapobiec uszkodzeniom cachu, ale 
        					nie pomaga to w serwerach wielowątkowych oraz w systemach
        					plików NFS.
      					</entry>
      				</row>
      				<row>
      					<entry><code>readControl</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Włącza / wyłącza kontrolę odczytu: jeśli włączona, klucz kontrolny
        					zostaje osadzony w pliku cachu i ten klucz jest porównywany z kluczem
        					obliczonym podczas odczytu.
      					</entry>
      				</row>
      				<row>
      					<entry><code>readControlType</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>'crc32'</code></entry>
      					<entry>
        					Typ kontroli odczytu (tylko jeśli kontrola odczytu jest włączona). Dostępne wartości
        					to: 'md5' (najlepsza ale najwolniejsza), 'crc32' (trochę mniej bezpieczna, ale szybsza, 
        					jest to lepsza opcja), 'strlen' (sprawdza tylko długość, jest najszybsza).
        				</entry>
      				</row>
      				<row>
      					<entry><code>hashedDirectoryLevel</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0</code></entry>
      					<entry>
        					Poziom podziału struktury katalogów: 0 oznacza "brak podziału
     						struktury", 1 oznacza "jeden poziom katalogów", 2 oznacza "dwa poziomy"... 
     						Ta opcja może przyspieszyć cache wtedy gdy masz wiele tysięcy plików
     						cache. Tylko specyficzne testy mogą pomóc wybrać odpowiednią
     						wartość. Możliwe, że na początek dobrą wartością może być 1 lub 2.
      					</entry>
      				</row>
      				<row>
      					<entry><code>hashedDirectoryUmask</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0700</code></entry>
      					<entry>
      						Prawa dostępu dla struktury katalogów.
        				</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
    	<title>Zend_Cache_Backend_Sqlite</title>
    	<para>
    		Ten backend przechowuje rekordy cache w bazie SQLite.
    	</para>
    	<para>
    		Dostępne opcje to:
    	</para>
    	<table>
    		<title>Dostępne opcje</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Opcja</entry>
				        <entry>Typ danych</entry>
				        <entry>Domyślna wartość</entry>
				        <entry>Opis</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>cacheDBCompletePath (wymagane)</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>null</code></entry>
      					<entry>
      					    Kompletna ścieżka (wraz z nazwą pliku) do bazy SQLite.
      					</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->