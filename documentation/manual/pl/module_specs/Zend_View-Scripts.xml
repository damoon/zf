<sect1 id="zend.view.scripts">
    
    <title>Skrypty widoków</title>
        
    <para>
        Kiedy już kontroler przypisze zmienne i wywoła metodę render(),
        Zend_View dołącza wymagany skrypt widoku i wykonuje go "wewnątrz"
        instancji Zend_View. Dlatego w skrypcie widoku, odwołania do zmiennych
        i metod obsługiwane są za pomocą $this.
    </para>
    
    <para>
        Zmienne przypisane do widoku przez kontroler odnoszszą się do właściwości
        tej instancji. Na przykład, jeśli kontroler przypisał zmienną 'cos', w
        skrypcie widoku możesz odwołać się do niej za pomocą $this->cos.
        (To pozwala Ci na śledzenie zmiennych które zostały przypisane do skryptu 
        i tych które są zmiennymi wewnętrznymi skryptu).
    </para>
    
    <para>
        W celu przypomnienia, oto przykład skryptu widoku pokazanego we wprowadzeniu
        do Zend_View.
    </para>
    
    <programlisting role="php"><![CDATA[<?php if ($this->books): ?>
    
    <!-- Tabela z książkami. -->
    <table>
        <tr>
            <th>Autor</th>
            <th>Tytuł</th>
        </tr>
        
        <?php foreach ($this->books as $key => $val): ?>
        <tr>
            <td><?php echo $this->escape($val['author']) ?></td>
            <td><?php echo $this->escape($val['title']) ?></td>
        </tr>
        <?php endforeach; ?>
        
    </table>
    
<?php else: ?>
    
    <p>Nie ma żadnych książek do wyświetlenia.</p>
    
<?php endif; ?>]]>
    </programlisting>
        
    <sect2 id="zend.view.scripts.escaping">
        
        <title>Filtrowanie danych wyjściowych</title>

        <para>
            Jedną z najważniejszych rzeczy do zrobienia w skrypcie widoku
            jest uzyskanie pewności, że dane wyjściowe zostały prawidłowo
            przefiltrowane. Pomaga to w przeciwdziałaniu atakom XSS. Jeśli
            nie używasz funkcji, metody lub pomocnika (helper) w celu 
            filtrowania danych wyjściowych, powinieneś zawsze je filtrować 
            wtedy gdy chcesz je wyświetlić.
        </para>
        
        <para>
            Zend_View dostarcza metodę zwaną escape() która filtruje dane 
            wyjściowe.
        </para>
        
        <programlisting role="php"><![CDATA[<?php
// zły zwyczaj wyświetlania zmiennej:
echo $this->variable;

// dobryy zwyczaj wyświetlania zmiennej:
echo $this->escape($this->variable);
?>]]>
        </programlisting>
        
        <para>
            Domyślnie metoda escape() używa funkcji PHP htmlspecialchars() do
            filtrowania danych wyjściowych. Jakkolwiek, zależenie od Twojego
            środowiska możesz chciec filtrować dane wyjściowe w inny sposób.
            Użyj metody setEscape() na poziomie kontrolera by przekazać istancji
            Zend_View informację o tym, jakiej metody filtrowania ma używać.
        </para>
        
        <programlisting role="php"><![CDATA[<?php
// utwórz instancje Zend_View
$view = new Zend_View();

// wybierz funkcję htmlentities() jako metodę filtrowania 
$view->setEscape('htmlentities');

// lub wybierz statyczną klasę jako metodę filtrowania
$view->setEscape(array('SomeClass', 'methodName'));

// lub instancję
$obj = new SomeClass();
$view->setEscape(array($obj, 'methodName'));

// a teraz wygeneruj skrypt widoku
echo $view->render(...);
?>]]>
        </programlisting>
        
        <para>
            Metoda lub funkcja filtrująca powinna przyjmować wartość do 
            przefiltrowania jako pierwszy parametr, a wszystkie inne parametry 
            powinny być opcjonalne.
        </para>
        
    </sect2>

    <sect2 id="zend.view.scripts.templates">
    
        <title>System szablonów</title>
        
        <para>
            Chociaż PHP jest sam w sobie potężnym systemem szablonów, wielu
            programistów czuje, że jest on jednak zbyt potężny lub skomplikowany
            dla projektantów szablonów. Jako taki, skrypt widoku może być użyty
            do utworzenia instancji odrębnego systemu szablonów, a następnie 
            do manipulowania nią. Może to być na przykład system taki jak w 
            PHPLIB. Skrypt widoku mógłby wtedy wyglądać w ten sposób:
        </para>
        
        <programlisting role="php"><![CDATA[<?php
include_once 'template.inc';
$tpl = new Template();

if ($this->books) {
    $tpl->setFile(array(
        "booklist" => "booklist.tpl",
        "eachbook" => "eachbook.tpl",
    ));
    
    foreach ($this->books as $key => $val) {
        $tpl->set_var('author', $this->escape($val['author']);
        $tpl->set_var('title', $this->escape($val['title']);
        $tpl->parse("books", "eachbook", true);
    }
    
    $tpl->pparse("output", "booklist");
} else {
    $tpl->setFile("nobooks", "nobooks.tpl")
    $tpl->pparse("output", "nobooks");
}
?>]]>
        </programlisting>
        
        <para>
            I mogłoby to być powiązane z takim plikiem szablonu:
        </para>
        
        <programlisting role="html"><![CDATA[

<!-- booklist.tpl -->
<table>
    <tr>
        <th>Autor</th>
        <th>Tytuł</th>
    </tr>
    {books}
</table>

<!-- eachbook.tpl -->
    <tr>
        <td>{author}</td>
        <td>{title}</td>
    </tr>

<!-- nobooks.tpl -->
<p>Nie ma żadnych książek do wyświetlenia.</p>
]]>
        </programlisting>
        
    </sect2>
    
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->