<sect1 id="zend.controller.action">
	<title>Action Controllers</title>

	<sect2 id="zend.controller.action.introduction">
		<title>Wprowadzenie</title>
		<para>
            <code>Zend_Controller_Action</code> jest klasą abstrakcyjną, której
            możesz użyć do implementacji kontrolerów akcji, których wraz z
            kontrolerem frontowym użyjesz do budowania aplikacji opartej na 
            wzorcu Model-View-Controller (MVC).
		</para>

		<para>
            Aby użyć klasy Zend_Controller_Action, powinieneś ją rozszerzyć
            w swoich kontrolerach akcji (lub rozszerzyć ją aby utworzyć swoją
            własną bazową klasę dla kontrolerów akcji). Najbardziej podstawową
            operacją jest rozszerzenie tej klasy oraz utworzenie metod akcji,
            które odpowiadają różnym akcjom jakie ma obsługiwać kontroler na
            twojej stronie. Obsługa routingu i uruchamiania w Zend_Controller
            automatycznie przeszuka wszystkie metody twojej klasy, których 
            nazwa zakończona jest wyrazem 'Action', aby znaleźć odpowiednią 
            akcję kontrolera.
        </para>

        <para>
            Na przykład, załóżmy, że twoja klasa jest zdefiniowana w ten sposób:
        </para>

        <programlisting role="php"><![CDATA[
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // zrób coś
    }

    public function bazAction()
    {
        // zrób coś
    }
}
]]></programlisting>
            
        <para>
            Powyższa klasa FooController (kontroler 'foo') definiuje dwie akcje,
            'bar' oraz 'baz'.
        </para>

        <para>
            Można tu osiągnąć dużo więcej, na przykład: utworzyć własne akcje
            inicjalizacyjne, utworzyć domyślne akcje do wywołania gdy nie ma
            określonej akcji (lub określona jest nieprawidłowa), użyć metod 
            pre- oraz post-dispatch oraz użyć wielu różnych metod pomocników.
            Ten rozdział jest rozeznaniem w funkcjonalnościach kontrolera akcji.
        </para>
    </sect2>

	<sect2 id="zend.controller.action.initialization">
        <title>Inicjalizacja obiektu</title>

        <para>
            O ile zawsze możesz nadpisać konstruktor kontrolera akcji, nie 
            zalecamy tego. Zend_Controller_Action::__construct() przeprowadza
            kilka ważnych zadań, takich jak zarejestrowanie obiektów żądania i
            odpowiedzi, oraz przekazanie argumentów wywołania przez kontroler 
            frontowy. Jeśli musisz nadpisać konstruktor, upewnij się że 
            wywołasz parent::__construct($request, $response, $invokeArgs).
        </para>

        <para>
            Bardziej odpowiednim sposobem skonfigurowania instancji jest użycie
            metody init(), która jest wywoływana jako ostatnie zadanie konstruktora
            __construct(). Na przykład jeśli chcesz połączyć się z bazą danych:
        </para>

        <programlisting role="php"><![CDATA[
class FooController extends Zend_Controller_Action
{
    public function init()
    {
        $this->db = Zend_Db::factory('Pdo_Mysql', array(
            'host'     => 'myhost',
            'username' => 'user',
            'password' => 'XXXXXXX',
            'dbname'   => 'website'
        ));
    }
}
]]></programlisting>

    </sect2>

    <sect2 id="zend.controller.action.prepostdispatch">
        <title>Metody Pre-Dispatch oraz Post-Dispatch</title>

        <para>
            Klasa Zend_Controller_Action definiuje dwie metody, preDispatch() 
            oraz postDispatch(), które mogą być wywołane przed i po wywołaniu 
            akcji. Mogą one być użyteczne w wielu sytuacjach: weryfikowanie
            autentykacji oraz kontroli dostępu ACL odnośnie uruchamianej akcji,
            (przez wywołanie metody _forward() w metodzie preDispatch(), dzięki 
            czemu akcja może być pominięta), lub na przykład umieszczenie
            wygenerowanej zawartości w głównym szablonie (postDispatch()).
        </para>
    </sect2>

    <sect2 id="zend.controller.action.accessors">
        <title>Metody dostępowe</title>

        <para>
            W obiekcie zarejestrowanych jest wiele obiektów oraz zmiennych i 
            wszystkie mają metody dostępowe..
        </para>

        <itemizedlist>
            <listitem><para>
                <emphasis>Obiekt żądania</emphasis>: metoda getRequest() może
                być użyta do odebrania obiektu żądania używanego do wywoływania 
                akcji.
            </para></listitem>

            <listitem>
                <para>
                    <emphasis>Obiekt odpowiedzi</emphasis>: metoda getResponse() 
                    może być użyta do odebrania obiektu odpowiedzi 
                    przechowującego finalną odpowiedź. Niektóre typowe wywołania 
                    mogą wyglądać tak:
                </para>

                <programlisting role="php"><![CDATA[
$this->getResponse()->setHeader('Content-Type', 'text/xml');
$this->getResponse()->appendBody($content);
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    <emphasis>Argumenty wywołania</emphasis>: kontroler frontowy
                    może przekazać parametry do routera, obiektu uruchamiającego
                    oraz do kontrolera akcji. Aby je odebrać użyj metody
                    getInvokeArg($key); alternatywnie pobierz całą listę 
                    używając metody getInvokeArgs().
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>Parametry żądania</emphasis>: Obiekt żądania 
                    przechowuje parametry żądania takie jak dowolne parametry z
                    tablic _GET lub _POST oraz parametry użytkownika zdefiniowane
                    w ścieżce adresu URL. Aby je odebrać, użyj metody 
                    _getParam($key) lub _getAllParams(). Możesz także ustawić
                    parametry żądania używając metody _setParam(); jest to 
                    użyteczne gdy przenosimy do innych akcji.
                </para>

                <para>
                    Aby sprawdzić czy parametr istnieje czy nie (co jest 
                    użyteczne przy wywołaniach logicznych), użyj _hasParam($key).
                </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.controller.action.utilmethods">
        <title>Metody narzędziowe</title>

        <para>
            Oprócz metod dostępowych, klasa Zend_Controller_Action posiada kilka 
            metod narzędziowych używanych do przeprowadzania ważnych zadań 
            wewnątrz twoich metod akcji (lub wewnątrz metod pre-/post-dispatch).
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis>_forward($action, $controller = null, $module =
                        null, array $params = null)</emphasis>: 
                    wykonuje inną akcję. Jeśli zostanie wywołana w metodzie 
                    preDispatch(), obecnie zażądana akcja zostanie pominięta,
                    na rzecz nowej akcji. W przeciwnym wypadku, po wykonaniu 
                    obecnej akcji, będzie wywołana akcja zażądana w metodzie 
                    _forward().
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>_redirect($url, array $options =
                        array())</emphasis>: 
                    przekierowuje do innej lokacji. Ta metoda przyjmuje w 
                    parametrze URL oraz opcjonalny zestaw opcji. Domyślnie
                    przeprowadzane jest przekierowanie HTTP 302.
                </para>

                <para>
                    Zestaw opcji może zawierać jeden lub więcej z poniższych 
                    kluczy:
                </para>
                
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>exit:</emphasis> whether or not to exit
                            immediately. If requested, it will cleanly close any
                            open sessions and perform the redirect.
                        </para>

                        <para>
                            You may set this option globally within the
                            controller using the <code>setRedirectExit()</code>
                            accessor.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis>prependBase:</emphasis> whether or not to
                            prepend the base URL registered with the request
                            object to the URL provided.
                        </para>

                        <para>
                            You may set this option globally within the
                            controller using the
                            <code>setRedirectPrependBase()</code> accessor.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis>code:</emphasis> what HTTP code to utilize
                            in the redirect. By default, an HTTP 302 is
                            utilized; any code between 301 and 306 may be used.
                        </para>

                        <para>
                            You may set this option globally within the
                            controller using the
                            <code>setRedirectCode()</code> accessor.
                        </para>
                    </listitem>
                </itemizedlist>
            </listitem>

            <listitem>
                <para>
                    <emphasis>render($action = null, $name = null, $noController
                    = false)</emphasis>: render a view script. If no arguments
                    are passed, it assumes that the script requested is
                    <code>[controller]/[action].phtml</code> (where
                    <code>.phtml</code> is the value of the
                    <code>$viewSuffix</code> property). Passing a value for
                    <code>$action</code> will render that template in the
                    <code>[controller]</code> subdirectory. To override using
                    the <code>[controller]</code> subdirectory, pass a true
                    value for <code>$noController</code>. Finally, templates are
                    rendered into the response object; if you wish to render to
                    a specific named segment in the response object, pass a
                    value to <code>$name</code>.
                </para>

                <para>
                    Some examples:
                </para>

                <programlisting role="php"><![CDATA[<?php
class MyController extends Zend_Controller_Action
{
    public function fooAction()
    {
        // Renders my/foo.phtml
        $this->render();

        // Renders my/bar.phtml
        $this->render('bar');

        // Renders baz.phtml
        $this->render('baz', null, true);

        // Renders foo/login.phtml to the 'form' segment of the response object
        $this->render('login', 'form');
        
        // Renders site.phtml to the 'page' segment of the response object
        $this->render('site', 'page', true);
    }
}
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    <emphasis>initView()</emphasis>: initialize the view object.
                    <code>render()</code> calls <code>initView()</code> in order
                    to retrieve the view object, but it may be initialized at
                    any time; by default it populates the <code>$view</code>
                    property.  By default, it uses <code>Zend_View</code>, but
                    any class implementing <code>Zend_View_Interface</code> may
                    be used.
                </para>

                <para>
                    The default implementation makes the following assumption of
                    the directory structure:
                </para>

                <programlisting role="php"><![CDATA[
applicationOrModule/
    controllers/
        IndexController.php
    views/
        scripts/
            index/
                index.phtml
        helpers/
        filters/
]]></programlisting>
                
                <para>
                    In other words, view scripts are assumed to be in the
                    <code>views/scripts/</code> subdirectory, and the
                    <code>views</code> subdirectory is assumed to be a sibling
                    of the controllers subdirectory.
                </para>

                <para>
                    Call <code>initView()</code> in either <code>init()</code>
                    or your action methods if you need to be able to assign
                    variables, register filters, etc. As examples:
                </para>

                <programlisting role="php"><![CDATA[<?php
class MyController extends Zend_Controller_Action
{
    public function init()
    {
        // Initialize view object immediately
        $this->initView();
    }

    public function fooAction()
    {
        // Initialize some variables
        $this->view->foo = 'bar';
        $this->view->bar = 'baz';

        // render the view, with the 'foo' and 'bar' assigned variables
        $this->render();
    }
}

class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // Initialize view on a per-action basis:
        $view = $this->initView();

        // Initialize some variables
        $view->foo = 'bar';
        $view->bar = 'baz';

        // render the view, with the 'foo' and 'bar' assigned variables
        $this->render();
    }
}
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    <emphasis>getViewScript($action = null, $noController =
                        false):</emphasis> retrieve a view script path.
                    Primarily used by <code>render()</code>, you can call this
                    at any time to grab a view script path, or override the
                    method to change how your controller determines the path to
                    a view script.
                </para>

                <para>
                    As detailed under <code>render()</code>, above, the default
                    functionality is to look for a view script named
                    <code>[controller]/[action].phtml</code>. Providing
                    <code>$action</code> will override the filename of the view
                    script, and passing a true value to
                    <code>$noController</code> will override looking in the
                    controller subdirectory. You may also override the
                    <code>$viewSuffix</code> property to change the file
                    extension used (defaults to .phtml).
                </para>

                <para>
                    Override this method to provide alternate functionality when
                    determining the view script name and path.
                </para>
            </listitem>
        </itemizedlist>
    </sect2>
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->
