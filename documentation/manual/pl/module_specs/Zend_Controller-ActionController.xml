<sect1 id="zend.controller.action">
	<title>Action Controllers</title>

	<sect2 id="zend.controller.action.introduction">
		<title>Wprowadzenie</title>
		<para>
            <code>Zend_Controller_Action</code> jest klasą abstrakcyjną, której
            możesz użyć do implementacji kontrolerów akcji, których wraz z
            kontrolerem frontowym użyjesz do budowania aplikacji opartej na 
            wzorcu Model-View-Controller (MVC).
		</para>

		<para>
            Aby użyć klasy <code>Zend_Controller_Action</code>, powinieneś ją 
            rozszerzyć w swoich klasach kontrolerów akcji (lub rozszerzyć ją aby 
            utworzyć swoją własną bazową klasę dla kontrolerów akcji). 
            Najbardziej podstawową operacją jest rozszerzenie tej klasy oraz 
            utworzenie metod akcji, które odpowiadają różnym akcjom jakie ma 
            obsługiwać kontroler na twojej stronie. Obsługa routingu i 
            uruchamiania w Zend_Controller automatycznie przeszuka wszystkie 
            metody twojej klasy, których nazwa zakończona jest wyrazem 'Action', 
            aby znaleźć odpowiednią akcję kontrolera.
        </para>

        <para>
            Na przykład, załóżmy, że twoja klasa jest zdefiniowana w ten sposób:
        </para>

        <programlisting role="php"><![CDATA[
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // zrób coś
    }

    public function bazAction()
    {
        // zrób coś
    }
}
]]></programlisting>
            
        <para>
            Powyższa klasa <code>FooController</code> (kontroler <code>foo</code>) 
            definiuje dwie akcje, <code>bar</code> oraz <code>baz</code>.
        </para>

        <para>
            Można tu osiągnąć dużo więcej, na przykład: utworzyć własne akcje
            inicjalizacyjne, utworzyć domyślne akcje do wywołania gdy nie ma
            określonej akcji (lub określona jest nieprawidłowa), użyć metod 
            pre- oraz post-dispatch oraz użyć wielu różnych metod pomocników.
            Ten rozdział jest rozeznaniem w funkcjonalnościach kontrolera akcji.
        </para>
    </sect2>

	<sect2 id="zend.controller.action.initialization">
        <title>Inicjalizacja obiektu</title>

        <para>
            O ile zawsze możesz nadpisać konstruktor kontrolera akcji, nie 
            zalecamy tego. Zend_Controller_Action::__construct() przeprowadza
            kilka ważnych zadań, takich jak zarejestrowanie obiektów żądania i
            odpowiedzi, oraz przekazanie argumentów wywołania przez kontroler 
            frontowy. Jeśli musisz nadpisać konstruktor, upewnij się że 
            wywołasz metodę <code>parent::__construct($request, $response, 
            $invokeArgs)</code>.
        </para>

        <para>
            Bardziej odpowiednim sposobem skonfigurowania instancji jest użycie
            metody <code>init()</code>, która jest wywoływana jako ostatnie 
            zadanie konstruktora <code>__construct()</code>. Na przykład jeśli 
            chcesz połączyć się z bazą danych:
        </para>

        <programlisting role="php"><![CDATA[
class FooController extends Zend_Controller_Action
{
    public function init()
    {
        $this->db = Zend_Db::factory('Pdo_Mysql', array(
            'host'     => 'myhost',
            'username' => 'user',
            'password' => 'XXXXXXX',
            'dbname'   => 'website'
        ));
    }
}
]]></programlisting>

    </sect2>

    <sect2 id="zend.controller.action.prepostdispatch">
        <title>Metody Pre-Dispatch oraz Post-Dispatch</title>

        <para>
            Klasa <code>Zend_Controller_Action</code> definiuje dwie metody, 
            <code>preDispatch()</code> oraz <code>postDispatch()</code>, które 
            mogą być wywołane przed i po wywołaniu akcji. Mogą one być użyteczne 
            w wielu sytuacjach: weryfikowanie autentykacji oraz kontroli dostępu 
            ACL odnośnie uruchamianej akcji, (przez wywołanie metody 
            <code>_forward()</code> w metodzie <code>preDispatch()</code>, 
            dzięki czemu akcja może być pominięta), lub na przykład umieszczenie 
            wygenerowanej zawartości w głównym szablonie 
            (<code>postDispatch()</code>).
        </para>
    </sect2>

    <sect2 id="zend.controller.action.accessors">
        <title>Metody dostępowe</title>

        <para>
            W obiekcie zarejestrowanych jest wiele obiektów oraz zmiennych i 
            wszystkie mają metody dostępowe..
        </para>

        <itemizedlist>
            <listitem><para>
                <emphasis>Obiekt żądania</emphasis>: metoda 
                <code>getRequest()</code> może być użyta do odebrania obiektu 
                żądania używanego do wywoływania akcji.
            </para></listitem>

            <listitem>
                <para>
                    <emphasis>Obiekt odpowiedzi</emphasis>: metoda 
                    <code>getResponse()</code> może być użyta do odebrania 
                    obiektu odpowiedzi przechowującego finalną odpowiedź. 
                    Niektóre typowe wywołania mogą wyglądać tak:
                </para>

                <programlisting role="php"><![CDATA[
$this->getResponse()->setHeader('Content-Type', 'text/xml');
$this->getResponse()->appendBody($content);
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    <emphasis>Argumenty wywołania</emphasis>: kontroler frontowy
                    może przekazać parametry do routera, obiektu uruchamiającego
                    oraz do kontrolera akcji. Aby je odebrać użyj metody
                    <code>getInvokeArg($key)</code>; alternatywnie pobierz całą 
                    listę używając metody <code>getInvokeArgs()</code>.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>Parametry żądania</emphasis>: Obiekt żądania 
                    przechowuje parametry żądania takie jak dowolne parametry z
                    tablic _GET lub _POST oraz parametry użytkownika zdefiniowane
                    w ścieżce adresu URL. Aby je odebrać, użyj metody 
                    <code>_getParam($key)</code> lub <code>_getAllParams()</code>. 
                    Możesz także ustawić parametry żądania używając metody 
                    <code>_setParam()</code>; jest to użyteczne gdy przenosimy 
                    do innych akcji.
                </para>

                <para>
                    Aby sprawdzić czy parametr istnieje czy nie (co jest 
                    użyteczne przy wywołaniach logicznych), użyj 
                    <code>_hasParam($key)</code>.
                </para>
                
                <note>
                    <para>
                        <code>_getParam()</code> may take an optional second
                        argument containing a default value to use if the
                        parameter is not set or is empty. Using it eliminates
                        the need to call <code>_hasParam()</code> prior to
                        retrieving a value:
                    </para>

                    <programlisting role="php"><![CDATA[<?php
// Use default value of 1 if id is not set
$id = $this->_getParam('id', 1);

// Instead of:
if ($this->_hasParam('id') {
    $id = $this->_getParam('id');
} else {
    $id = 1;
}
?>]]></programlisting>
                </note>
            </listitem>
        </itemizedlist>
    </sect2>
    
    <sect2 id="zend.controller.action.viewintegration">
        <title>View Integration</title>

        <para>
            <code>Zend_Controller_Action</code> provides a rudimentary and
            flexible mechanism for view integration. Two methods accomplish
            this, <code>initView()</code> and <code>render()</code>; the former
            method lazy-loads the <code>$view</code> public property, and the
            latter renders a view based on the current requested action, using
            the directory hierarchy to determine the script path.
        </para>

        <sect3 id="zend.controller.action.viewintegration.initview">
            <title>View Initialization</title>

            <para>
                <code>initView()</code> initializes the view object.
                <code>render()</code> calls <code>initView()</code> in order to
                retrieve the view object, but it may be initialized at any time;
                by default it populates the <code>$view</code> property with a
                <code>Zend_View</code> object, but any class implementing
                <code>Zend_View_Interface</code> may be used. If
                <code>$view</code> is already initialized, it simply returns
                that property.
            </para>

            <para>
                The default implementation makes the following assumption of
                the directory structure:
            </para>

            <programlisting role="php"><![CDATA[
applicationOrModule/
    controllers/
        IndexController.php
    views/
        scripts/
            index/
                index.phtml
        helpers/
        filters/
]]></programlisting>
            
            <para>
                In other words, view scripts are assumed to be in the
                <code>views/scripts/</code> subdirectory, and the
                <code>views</code> subdirectory is assumed to contain sibling 
                functionality (helpers, filters). When determining the view
                script name and path, the <code>views/scripts/</code> directory
                will be used as the base path, with a directories named after the
                individual controllers providing a hierarchy of view scripts.
            </para>
        </sect3>

        <sect3 id="zend.controller.action.viewintegration.render">
            <title>Rendering Views</title>

            <para>
                <code>render()</code> has the following signature:
            </para>

            <programlisting role="php"><![CDATA[<?php
string render(string $action = null, string $name = null, bool $noController = false);
?>]]></programlisting>

            <para>
                <code>render()</code> renders a view script. If no arguments are
                passed, it assumes that the script requested is
                <code>[controller]/[action].phtml</code> (where
                <code>.phtml</code> is the value of the <code>$viewSuffix</code>
                property). Passing a value for <code>$action</code> will render
                that template in the <code>[controller]</code> subdirectory. To
                override using the <code>[controller]</code> subdirectory, pass
                a true value for <code>$noController</code>. Finally, templates
                are rendered into the response object; if you wish to render to
                a specific <link
                    linkend="zend.controller.response.namedsegments">named
                    segment</link> in the response object, pass a value to
                <code>$name</code>.
            </para>

            <para>
                Some examples:
            </para>

            <programlisting role="php"><![CDATA[<?php
class MyController extends Zend_Controller_Action
{
    public function fooAction()
    {
        // Renders my/foo.phtml
        $this->render();

        // Renders my/bar.phtml
        $this->render('bar');

        // Renders baz.phtml
        $this->render('baz', null, true);

        // Renders foo/login.phtml to the 'form' segment of the response object
        $this->render('login', 'form');
        
        // Renders site.phtml to the 'page' segment of the response object
        $this->render('site', 'page', true);
    }
}
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.controller.action.utilmethods">
        <title>Metody narzędziowe</title>

        <para>
            Oprócz metod dostępowych i metod integracji z widokiem, klasa 
            <code>Zend_Controller_Action</code> posiada kilka metod 
            narzędziowych używanych do przeprowadzania ważnych zadań wewnątrz 
            twoich metod akcji (lub wewnątrz metod pre-/post-dispatch).
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>_forward($action, $controller = null, $module =
                        null, array $params = null)</code>: 
                    wykonuje inną akcję. Jeśli zostanie wywołana w metodzie 
                    <code>preDispatch()</code>, obecnie zażądana akcja zostanie 
                    pominięta, na rzecz nowej akcji. W przeciwnym wypadku, po 
                    wykonaniu obecnej akcji, będzie wywołana akcja zażądana w 
                    metodzie _forward().
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>_redirect($url, array $options =
                        array())</code>: 
                    przekierowuje do innej lokacji. Ta metoda przyjmuje w 
                    parametrze URL oraz opcjonalny zestaw opcji. Domyślnie
                    przeprowadzane jest przekierowanie HTTP 302.
                </para>

                <para>
                    Zestaw opcji może zawierać jeden lub więcej z poniższych 
                    kluczy:
                </para>
                
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>exit:</emphasis> określa czy skrypt ma 
                            zakończyć działanie od razu po przekierowaniu. Jeśli
                            tak, to skrypt zamknie wszystkie otwarte sesje i
                            przeprowadzi przekierowanie.
                        </para>

                        <para>
                            Możesz ustawić tę opcję globalnie wewnątrz 
                            kontrolera używając metody dostępowej 
                            <code>setRedirectExit()</code>.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis>prependBase:</emphasis> określa czy bazowy
                            adres URL zarejestrowany w obiekcie żądania ma być 
                            dołączony do adresu URL przekierowania.
                        </para>

                        <para>
                            Możesz ustawić tę opcję globalnie wewnątrz 
                            kontrolera używając metody dostępowej 
                            <code>setRedirectPrependBase()</code>.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis>code:</emphasis> kod HTTP do użycia 
                            podczas przekierowania. Domyślnie użyty jest kod 
                            HTTP 302; może być użyty dowolny kod pomiędzy 301
                            a 306.
                        </para>

                        <para>
                            Możesz ustawić tę opcję globalnie wewnątrz 
                            kontrolera używając metody dostępowej 
                            <code>setRedirectCode()</code>.
                        </para>
                    </listitem>
                </itemizedlist>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.controller.action.subclassing">
        <title>Subclassing the Action Controller</title>

        <para>
            By design, <code>Zend_Controller_Action</code> must be subclassed
            in order to create an action controller. At the minimum, you will
            need to define action methods that the controller may call.
        </para>

        <para>
            Besides creating useful functionality for your web applications, you
            may also find that you're repeating much of the same setup or
            utility methods in your various controllers; if so, creating a
            common base controller class that extends
            <code>Zend_Controller_Action</code> could solve such redundancy.
        </para>

        <sect3 id="zend.controller.action.subclassing.call">
            <title>How to Handle Non-Existent Actions</title>

            <para>
                If a request to a controller is made that includes an undefined
                action method, <code>Zend_Controller_Action::__call()</code>
                will be invoked. <code>__call()</code> is, of course, PHP's
                magic method for method overloading.
            </para>

            <para>
                By default, this method throws a
                <code>Zend_Controller_Action_Exception</code> indicating the
                requested action was not found in the controller. You should
                override this functionality if you wish to perform other
                operations.
            </para>

            <para>
                For instance, if you wish to display an error message, you might
                write something like this:
            </para>

            <programlisting role="php"><![CDATA[<?php
class MyController extends Zend_Controller_Action
{
    public function __call($method, $args)
    {
        if ('Action' == substr($method, -6)) {
            // If the action method was not found, render the error template
            return $this->render('error');
        }

        // all other methods throw an exception
        throw new Exception('Invalid method "' . $method . '" called');
    }
}
?>]]></programlisting>

            <para>
                Another possibility is that you may want to forward on to a
                default controller page:
            </para>

            <programlisting role="php"><![CDATA[<?php
class MyController extends Zend_Controller_Action
{
    public function indexAction()
    {
        $this->render();
    }

    public function __call($method, $args)
    {
        if ('Action' == substr($method, -6)) {
            // If the action method was not found, forward to the index action
            return $this->_forward('index');
        }

        // all other methods throw an exception
        throw new Exception('Invalid method "' . $method . '" called');
    }
}
?>]]></programlisting>
        </sect3>

        <para>
            Besides overriding <code>__call()</code>, each of the
            initialization, utility, accessor, view, and dispatch hook methods
            mentioned previously in this chapter may be overridden in order to
            customize your controllers. As an example, if you are storing your
            view object in a registry, you may want to modify your
            <code>initView()</code> method with code resembling the following:
        </para>

        <programlisting role="php"><![CDATA[<?php
abstract class My_Base_Controller extends Zend_Controller_Action
{
    public function initView()
    {
        if (null === $this->view) {
            if (Zend_Registry::isRegistered('view')) {
                $this->view = Zend_Registry::get('view');
            } else {
                $this->view = new Zend_View();
                $this->view->setBasePath(dirname(__FILE__) . '/../views');
            }
        }

        return $this->view;
    }
}
?>]]></programlisting>

        <para>
            Hopefully, from the information in this chapter, you can see the
            flexibility of this particular component and how you can shape it to
            your application's or site's needs.
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
