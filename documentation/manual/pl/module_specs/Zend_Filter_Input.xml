<sect1 id="zend.filter.input">

    <title>Zend_Filter_Input</title>

    <sect2 id="zend.filter.input.introduction">

        <title>Wprowadzenie</title>

        <para>
            Klasa <literal>Zend_Filter_Input</literal> dostarcza metody, które zapewniają 
            strukturalne podejście do filtrowania danych przychodzących. Jej przeznaczenie 
            jest różnorodne, ponieważ zaspokaja ona potrzeby trzech różnych grup ludzi:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Programiści
                </para>
                <para>
                    Chociaż filtrowanie danych wejściowych nigdy nie może być tak łatwe jak nierobienie niczego, programiści potrzebują zapewnić
                    integralną czystość swoim danym nie dodając w tym celu niepotrzebnej złożoności kodu.
                </para>
            </listitem>
            <listitem>
                <para>
                    Menadżerzy
                </para>
                <para>
                    Menadżerzy którzy chcą zachować kontrolę nad dużą grupą programistów mogą narzucić gotowy sposób filtrowania danych
                    wejściowych, a także mogą wyeliminować dostęp to niefiltrowanych danych wejściowych.
                </para>
            </listitem>
            <listitem>
                <para>
                    Audytorzy
                </para>
                <para>
                    Ci, którzy sprawdzają kod aplikacji potrzebują szybko i solidnie sprawdzić kiedy 
                    i gdzie używane są dane wejściowe w czystej postaci. Zasady, które sprzyjają 
                    pisaniu przejrzystego kodu wspierają także audytorów zapewniając im jasne 
                    odróżnienie pomiędzy różnymi sposobami filtrowania danych wejściowych.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Jest wiele różnych zdań na temat filtrowania danych przychodzących i jest wiele 
            różnych metod, których programiści mogą użyć. Filtrowanie whitelist, filtrowanie 
            blacklist, wyrażenia regularne, wyrażenia warunkowe oraz natywne funkcje PHP 
            są tylko kilkoma przykładami filtrowania danych przychodzących.
        </para>

    </sect2>

    <sect2 id="zend.filter.input.theory_of_operation">

        <title>Opis działania</title>

        <para>
            In order to provide a structured approach to input filtering, by default,
            <literal>Zend_Filter_Input</literal> attempts to enforce controlled access to input by setting the
            reference to the source data array to <code>null</code>.
        </para>

        <para>
            In the default (strict) approach, a single argument is passed to the constructor - an array of data to filter. Unfiltered data may only be accessed through the <code>getRaw()</code> method:
        </para>

        <programlisting role="php"><![CDATA[<?php
// $_POST['email'] === 'webmaster@example.com'

// Filtruje dane z tablicy $_POST
require_once 'Zend/Filter/Input.php';
$filterPost = new Zend_Filter_Input($_POST);

// $_POST ma teraz wartość null
echo null === $_POST ? 'yes' : 'no'; // wyświetla 'yes'

// Pobiera niefiltrowaną wartość e-mail
echo $filterPost->getRaw('email'); // wyświetla 'webmaster@example.com']]></programlisting>

        <para>
            <literal>Zend_Filter_Input</literal> sets the array that is passed (<literal>$_POST</literal>) to
            <literal>null</literal>, so direct access is no longer possible. (The raw data are only available
            through the <literal>getRaw()</literal> method, which is much easier to monitor and/or avoid
            altogether.)
        </para>

        <para>
            In the optional (non-strict) approach, <literal>false</literal> is passed as the second argument
            to the constructor:
        </para>

        <programlisting role="php"><![CDATA[<?php
// $_POST['email'] === 'webmaster@example.com'

// Filtruje dane z tablicy $_POST
require_once 'Zend/Filter/Input.php';
$filterPost = new Zend_Filter_Input($_POST, false);

// tablica $_POST wciąż jest zdefiniowana
echo null === $_POST ? 'yes' : 'no'; // wyświetla 'no'

// Pobiera niefiltrowaną wartość e-mail
echo $filterPost->getRaw('email'); // wyświetla 'webmaster@example.com']]></programlisting>

        <para>
            The use of the filter is exactly the same, but <literal>Zend_Filter_Input</literal> does not set
            the original array (<literal>$_POST</literal>) to <literal>null</literal>, so developers can
            still access it directly. This approach is discouraged in favor of the strict approach.
        </para>

        <para>
            <literal>Zend_Filter_Input</literal> is designed primarily with arrays in mind. Many sources of
            input are already covered by PHP's superglobal arrays (<literal>$_GET</literal>,
            <literal>$_POST</literal>, <literal>$_COOKIE</literal>, etc.), and arrays are a common construct
            used to store input from other sources. If you need to filter a scalar, see
            <xref linkend="zend.filter" />.
        </para>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->