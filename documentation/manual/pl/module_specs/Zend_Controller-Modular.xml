<sect1 id="zend.controller.modular">
    <title>Użycie konwencjonalnej modularnej struktury katalogów</title>

	<sect2 id="zend.controller.modular.introduction">
		<title>Wprowadzenie</title>
        <para>
            Konwencjonalna modularna struktura katalogów pozwala ci na 
            oddzielenie różnych aplikacji MVC w osobne jednostki i użycie ich
            z różnymi kontrolerami frontowymi. Przykładem może być taka 
            struktura katalogów:
        </para>

        <programlisting role="php"><![CDATA[
docroot/
    index.php
application/
    controllers/
        IndexController.php
        FooController.php
    blog/
        controllers/
            IndexController.php
        models/
        views/
    news/
        controllers/
            IndexController.php
            ListController.php
        models/
        views/
]]></programlisting>
        
        <para>
            W tym modelu, nazwa modułu uwidacznia się jako przedrostek nazw 
            kontrolerów, ktore zawiera moduł. Powyższy przykład zawiera trzy
            kontrolery modułów, 'Blog_IndexController', 'News_IndexController',
            oraz 'News_ListController'. Dwa globalne kontrolery, 'IndexController'
            oraz 'FooController' są także zdefiniowane; żaden z nich nie posiada
            własnej przestrzeni nazw. Ta struktura katalogów będzie używana w 
            przykładach w tym rozdziale.
        </para>

        <para>
            Więc jak implementujesz taką strukturę katalogów używając 
            komponentów MVC Zend Framework?
        </para>
    </sect2>

    <sect2 id="zend.controller.modular.directories">
        <title>Określanie ścieżek kontrolera modułów</title>

        <para>
            Pierwszym krokiem użycia modułów jest zmodyfikowanie sposobu 
            określania listy ścieżek do kontrolerów w kontrolerze frontowym.
            W podstawowej wersji MVC, przekazujesz tablicę lub łańcuch znaków
            do metody setControllerDirectory(), lub ścieżkę do metody 
            addControllerDirectory(). Gdy używasz modułów, musisz także 
            odpowiednio zmienić wywołania tych metod.
        </para>

        <para>
            W metodzie setControllerDirectory(), musisz przekazać tablicę 
            asocjacyjną i określić pary klucz/wartość w postaci 
            moduł/ścieżka. Specjalny klucz 'default' będzie użyty dla globalnych 
            kontrolerów (tych, które nie potrzebują przestrzeni nazw), i może on 
            zawierać tablicę ścieżek. Wszystkie inne potrzebują łańcucha znaków 
            wskazującego na pojedyncza ścieżkę. Na przykład:
        </para>

        <programlisting role="php"><![CDATA[
$front->setControllerDirectory(array(
      'default' => array('/path/to/application/controllers'),
      'blog'    => '/path/to/application/blog/controllers'
));
]]></programlisting>

        <para>
            Metoda addControllerDirectory() przyjmuje opcjonalny drugi argument.
            Gdy używasz modułów, przekaż nazwę modułu jak drugi argument; jeśli
            nie określisz drugiego argumentu, ścieżka zostanie dodana dla 
            domyślnej przestrzeni nazw. Na przykład:
        </para>

        <programlisting role="php"><![CDATA[
$front->addControllerDirectory('/path/to/application/news/controllers', 'news');
]]></programlisting>
    </sect2>

    <sect2 id="zend.controller.modular.directories">
        <title>ModuleRouter, ModuleRewriteRouter, oraz ModuleDispatcher</title>

        <para>
            Oprócz zmiany sposobu określania ścieżek kontrolerów powinieneś
            także użyć routera oraz obiektu uruchamiającego działających z 
            modułami. Możesz wybrać Zend_Controller_ModuleRouter lub
            Zend_Controller_ModuleRewriteRouter jako router, oraz
            Zend_Controller_ModuleDispatcher jako obiekt uruchamiający. Aby to
            zrobić, zmodyfikuj plik ładujący kontroler frontowy w ten sposób:
        </para>

        <programlisting role="php"><![CDATA[
require_once 'Zend/Controller/ModuleRouter.php';
require_once 'Zend/Controller/ModuleDispatcher.php';

$front->setRouter(new Zend_Controller_ModuleRouter())
      ->setDispatcher(new Zend_Controller_ModuleDispatcher())
]]></programlisting>

        <para>
            Od tego momentu możesz uruchamwiać kontroler frontowy w ten sam
            sposób co zwykle:
        </para>

        <programlisting role="php"><![CDATA[
$front->dispatch();
]]></programlisting>
        
        <para>
            Zend_Controller_ModuleRouter jedynie dopasuje moduł wtedy, jeśli
            odpowiedni klucz istnieje w tablicy ze ścieżkami kontrolerów; w
            przeciwnym wypadku, zachowa się według domyślnego dopasowania
            /controller/action.
        </para>
    </sect2>

    <sect2 id="zend.controller.modular.defaultcontroller">
        <title>Moduł lub globalny domyślny kontroler</title>

        <para>
            W domyślnym routerze jeśli w URL nie został określony kontroler, 
            użyty zostanie domyślny kontroler (IndexController, jeśli nie 
            określono inaczej). Gdy używamy kontrolerów modularnych, jeśli moduł
            został określony, ale kontroler nie, obiekt uruchamiający wpierw
            będzie szukał domyślnego kontrolera w ścieżce modułu, a w drugiej
            kolejności będzie szukał w ścieżce dla domyślnej globalnej 
            przestrzeni nazw 'default'.
        </para>

        <para>
            Jeśli chcesz zawsze używać domyślnej przestrzeni nazw, ustaw 
            parametr 'useGlobalDefault' w kontrolerze frontowym:
        </para>

        <programlisting role="php"><![CDATA[
$front->setParam('useGlobalDefault', true);
]]></programlisting>
    </sect2>
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->
