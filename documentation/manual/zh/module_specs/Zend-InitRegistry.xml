<sect1 id="zend.initregistry">

    <title>Zend::initRegistry($registry = 'Zend_Registry')</title>

    <para>
      如果你想扩展现有的注册表（对象仓库）功能，可以使用这个类方法。这个方法允许程序继承Zend_Registry类，包括增加别名方法offsetGet()和offsetExists()，如has(), getval(), setval()等等。你可以在bootstrap代码中（index.php）创建一个Zend_Registry的子类的实例，然后把实例传递给initRegistry()，这些操作要在其它注册相关的方法使用之前完成。注意initRegistry()只能使用一次，这是为了避免在初始化覆盖了已经存在的注册表。同样，使用Zend::registry()或者 Zend::register()会自动调用initRegistry()，如果它没被调用过的话。
    </para>

    <example>
        <title>register() / offsetSet() Example</title>
<programlisting role="php"><![CDATA[<?php
class Zend_RegistryMine extends Zend_Registry
{
    public function getval($index)
    {
        return $this->offsetGet($index);
    }
}

# in your bootstrap code:
# 在bootstrap代码中：

$ini_array = parse_ini_file('your_stuff.ini'); // purely optional
$registry = new Zend_RegistryMine($ini_array);
Zend::initRegistry($registry);

# now the normal Zend::registry(), Zend::register(), and Zend::isRegistered() work as expected
# 现在Zend::registry(), Zend::register()和Zend::isRegistered()都按预期的工作正常
?>]]></programlisting>
    </example>

    <para>
        Use the constant <code>ArrayObject::ARRAY_AS_PROPS</code> in the constructor to enable accessing values
        using <code>$registry->$indexName</code>, in addition to <code>$registry[$indexName]</code>.
        However, beware of name collisions, if you extend Zend_Registry and add private variables.
		在构造方法中使用常量<code>ArrayObject::ARRAY_AS_PROPS</code>允许使用<code>$registry->$indexName</code>的方式来访问值，而不只能够用<code>$registry[$indexName]</code>的方式。但是如果你扩展了Zend_Registry并添加了private的变量，要注意避免出现命名冲突。
    </para>

    <example>
        <title>使用OO方式代替数组方式来访问值</title>
<programlisting role="php"><![CDATA[<?php
$registry = new Zend_Registry(array(), ArrayObject::ARRAY_AS_PROPS); 
Zend::initRegistry($registry);
?>]]></programlisting>
    </example>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
