<sect1 id="zend.session.advancedusage">

    <title>高级用法</title>

    <para>
	    虽然Zend_Session的基本用法是完全可以接受的，但还有些最佳实践需要去考虑。考虑在<link linkend="zend.auth.introduction.using"><code>Zend_Auth</code>的例子</link>中默认是怎样透明地使用了Zend_Session来持久化鉴别标识符（authentication token)。这个例子展示了快速而简便的整合Zend_Session和Zend_Auth的一个方法。
    </para>

    <sect2 id="zend.session.startingasession">

        <title>开启会话</title>

        <para>
             如何你希望所有的请求都有个会话值并且使用Zend_Session，那么请在程序的引导文件中开启它：
        </para>

        <example>
            <title>开启全局会话</title>
<programlisting role="php">
<![CDATA[<?php
...
require_once 'Zend/Session.php';
Zend_Session_Core::start();
...
?>]]></programlisting>
        </example>

        <para>
            在程序的引导文件中开启会话，可以避免引发会话开启之前已经有HTTP头发向用户浏览器的异常，那样可能会破坏web页面的美观。许多高级的特性需要先执行<code>Zend_Session_Core::start()</code>（更多高级的特性之后会展开）。
        </para>

        <para>
            使用Zend_Session组件，有4种开启会话的方法，其中2种是错误的。
        </para>

        <itemizedlist mark='opencircle'>
            <listitem>
                <para>
                    1. 错误的：没有在php.ini或.htaccess文件中关闭session.auto_start选项。如果在php.ini中已经开启了该选项，而你又没有权限去关闭该选项，你可以在.htaccess文件中增加<code>php_value session.auto_start 0</code>这一句。
                </para>
            </listitem>
            <listitem>
                <para>
				    2. 错误的：直接调用<code><ulink url="http://www.php.net/session_start">session_start()</ulink></code>开启会话。如果你直接调用<code>session_start()</code>开启了会话，之后再使用Zend_Session，那么<code>Zend_Session::start()</code>会抛出"会话已经开始"的异常。如果你在开启Zend_Session之后调用<code>session_start()</code>函数开启会话，那么会产生一个E_NOTICE级别的错误，该调用将会被忽略。
                </para>
            </listitem>
            <listitem>
                <para>
                    3. 正确的：使用<code>Zend_Session_Core::start()</code>开启会话。如果你想让每个页面请求都开启会话，那么应该在ZF应用程序的引导文件（index.php）中尽早的调用这个函数。开启会话有些额外的开销，如果只有部分页面请求需要开启会话，那么就：
                </para>
                <itemizedlist mark='opencircle'>
                    <listitem>
                        <para>
						    在ZF应用程序的引导文件中，无条件的设置<code>strict</code>选项为true（参考<link linkend="zend.session.startingasession"><code>Zend_Session_Core::setOptions()</code></link>）。
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            在需要使用会话的页面请求中，先调用<code>Zend_Session_Core::start()</code>开启会话，后调用<code>new Zend_Session()</code>。
                        </para>
                    </listitem>
                    <listitem>
                        <para>
						    向往常一样，在需要会话的地方，使用<code>new Zend_Session()</code>，但必须确认先前已经调用过<code>Zend_Session_Core::start()</code>了。
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    <code>strict</code>选项阻止了当调用<code>new Zend_Session()</code>时自动开启<code>Zend_Session_Core</code>。因此，这个选项有利于ZF应用程序的开发者强制执行一个设计原则以避免在某些页面请求中使用会话，因为在调用<code>Zend_Session_Core::start()</code>之前，又开启了<code>strict</code>选项，实例化<code>Zend_Session</code>时，会抛出一个异常。不要在ZF的核心代码中开启这个选项，因为只有应用程序的开发者才能决定是否执行这个设计原则。同样地，所有“程序库”的开发者，需小心地考虑在它们库代码中使用<code>Zend_Session_Core::setOptions()</code>方法所引起的冲突，因为这些选项具有全局副作用。
                </para>
            </listitem>
            <listitem>
                <para>
				    4. 正确的：只要有需要使用会话的地方，就调用<code>new Zend_Session()</code>，会话会由<code>Zend_Session_Core</code>自动的开启。这个方法非常的简单，且在大多数的情形下能很好地工作。然而，如果你使用地是默认的基于cookie的会话（被推荐的），你必须确保在第一次调用<code>new Zend_Session()</code>在任何向客户端输出（也就是<ulink url="http://www.php.net/headers_sent">HTTP headers</ulink>）<emphasis role="strong">之前</emphasis>。使用<ulink url="http://php.net/outcontrol">输出缓存（output buffering）</ulink>可以防止第一次调用new Zend_Session()在向客户端输出之后，同时也有利于改善执行效率。例如，在<code>php.ini</code>中，"<code>output_buffering = 65535</code>"设置了输出缓存为64K。
                </para>
            </listitem>
        </itemizedlist>

    </sect2>

    <sect2 id="zend.session.locking">

        <title>锁住会话命名空间</title>

        <para>
		    会话的命名空间可以加锁，以防止意外的变更该命名空间下的会话变量值。调用<code>lock()</code>方法使该命名空间下会话变量为只读，<code>unlock()</code>方法使该命名空间下会话变量值可读可写，<code>isLocked()</code>方法测试该命名空间是否已经被加锁。加锁是短暂的，且只在此页面请求内有效，不会持续到下一个页面请求。给命名空间加锁不会影响到存储在该命名空间下对象的setter方法，但是阻止了命名空间下的setter方法的移除或替换对象。也就是说，虽给Zend_Session命名空间加了锁，但还是不能阻止它处同样引用了命名空间下数据的对它的变更（参见<ulink url="http://www.php.net/references">PHP references</ulink>)。
        </para>

        <example>
            <title>锁住会话命名空间</title>
<programlisting role="php">
<![CDATA[<?php
    // assuming:
    $my_session = new Zend_Session('my_session');

    // marking session as read only locked
    $my_session->lock();

    // unlocking read-only lock
    if ($my_session->isLocked()) {
        $my_session->unLock();
    }
?>]]></programlisting>
        </example>

        <para>
            关于管理MVC模式中的模型(models)已经存在着大量不同的思想，包括创建视图所使用的表现层模型。有时已存在的数据，无论是否属于领域模型的数据，已经足够完成任务。为了阻止在视图中辑修改那些数据，可以考虑在允许视图访问表现层模型前给会话命名空间加锁。
        </para>

        <example>
            <title>锁住视图中的会话</title>
<programlisting role="php">
<![CDATA[<?php
class FooModule_View extends Zend_View
{
    public function show($name)
    {
        if (!isset($this->session)) {
            $this->session = Zend::registry('FooModule');
        }

        if ($this->session->isLocked()) {
            return parent::render($name);
        }

        $this->session->lock();
        $return = parent::render($name);
        $this->session->unLock();

        return $return;
    }
}
?>]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.session.controllers">

        <title>会话封装和控制器</title>

        <para>
            命名空间可以被用来保护控制器对会话的访问，以免被污染。例如， 'Zend_Auth'控制器可以保持它的会话状态数据与其他控制器分离。通过使用getInstance()方法获取 Zend_Session_Core实例和调用_startNamespace($namespace)方法来完成与其他控制器的分离。
        </para>

        <example>
            <title>给控制器会话赋于命名空间及生命期</title>
<programlisting role="php">
<![CDATA[<?php
require_once 'Zend/Session.php';
// question view controller
$test_session = new Zend_Session('test');
$test_session->setExpirationSeconds(300, "accept_answer"); // expire only this variable
$test_session->accept_answer = true;

-- 

// answer processing controller
$test_session = new Zend_Session('test');

if ($test_session->accept_answer === true) {
    // within time
}
else {
    // not within time
}
?>]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.session.limitinginstances">

        <title>限制每个命名的Zend_Session实例</title>

        <para>
            我们推荐使用会话加锁（上面的）来代替下面讲到的特性，因为它额外地加重了开发者的负担，需要传递Zend_Session的实例给需要存取会话变量的函数和对象。
        </para>

        <para>
            当你构造第一个Zend_Session实例并把它绑定到一个具体的命名空间上时，你可以指出不允许在该命名空间下构造更多的Zend_Session实例。因此，任何试图再次构造该命名空间下的Zend_Session实例都将抛出一个异常。这样的行为是可选的，且不是默认的行为，是留给喜欢为每个命名空间传递一个单一实例的人用的。这样增强了保护，免受来自其他组件的非法变更，因为他们很难访问。然而，限制一个命名空间只能有一个实例可能会导致编写更多的代码或使得代码复杂化，同时在第一个实例创建后，将不能调用<code>$session = new Zend_Session('aNamespace');</code>，就像下面例子中所述的：
            below:
        </para>

        <example>
            <title>限制为单一实例</title>
<programlisting role="php">
<![CDATA[<?php
    require_once 'Zend/Session.php';
    $authSessionAccessor1 = new Zend_Session('Zend_Auth');
    $authSessionAccessor2 = new Zend_Session('Zend_Auth', Zend_Session::SINGLE_INSTANCE);
    $authSessionAccessor1->foo = 'bar';
    assert($authSessionAccessor2->foo, 'bar'); // passes
    doSomething($options, $authSessionAccessor2); // pass the accessor to wherever it is needed
    .
    .
    .
    $aSessionObject = new Zend_Session('Zend_Auth'); // this will throw an error
?>]]></programlisting>
        </example>

        <para>
		    上述构造器中的第二个参数告诉Zend_Session，之后任何实例化命名空间为'Zend_Auth'的Zend_Session对象都是不允许的，且将会抛出异常。因为，执行过上面一段代码后，将不允许执行<code>new Zend_Session('Zend_Auth')</code>，如果当前页面请求的剩余时间段还需要访问该命名空间，则开发人员有责任在某处储存该命名空间的实例对象（上例中的<code>$componentAuthState</code>）。例如，开发者可以把该实例对象储存在静态变量中，或者把它传递给需要访问该命名空间的函数。会话加锁（参见上面的）为限制访问命名空间，提供了一个更加轻便合理的方法。
        </para>

    </sect2>

</sect1>
