<sect1 id="zend.db.adapter">

    <title>Zend_Db_Adapter</title>

    <sect2 id="zend.db.adapter.introduction">

        <title>Introdução</title>

        <para>
			<code>Zend_Db_Adapter</code> é a API para camada de abstração de dados do Framework Zend.
            O <code>Zend_Db_Adapter</code> é baseado no PDO e permite conectar e trabalhar com 
            os sistemas de banco de dados disponíveis usando a mesma API. Isso inclui 
			Microsoft SQL Server, MySQL, PostgreSQL, SQLite e outros.
        </para>

        <para>
			Para criar uma instância do <code>Zend_Db_Adapter</code> para um banco de dados 
			específico, execute <code>Zend_Db::factory()</code> passando como parâmetros o nome do
			adaptador e uma matriz de valores descrevendo a conexão. O exemplo abaixo mostra como
			conectar uma base de dados MySQL chamada "camelot" no servidor local através do usuário
			"malory":
		</para>

        <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Db.php';

$params = array ('host'     => '127.0.0.1',
                 'username' => 'malory',
                 'password' => '******',
                 'dbname'   => 'camelot');

$db = Zend_Db::factory('pdoMysql', $params);

?>]]></programlisting>

        <para>
            Do mesmo modo, para conectar um banco de dados SQLite chamado "camelot":
        </para>

        <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Db.php';

$params = array ('dbname' => 'camelot');

$db = Zend_Db::factory('pdoSqlite', $params);

?>]]></programlisting>

        <para>
            Em ambos os casos, você usa exatamente a mesma API para 
			manipular o banco de dados.
        </para>
    </sect2>

    <sect2 id="zend.db.adapter.quoting">

        <title>Protegendo-se contra SQL Injection</title>

        <para>
            Você deve sempre colocar entre aspas valores que serão usados em um comando 
			SQL; isto previne ataques de SQL injection.
            <code>Zend_Db_Adapter</code> oferece dois métodos (através do objeto PDO)
            que ajudam você a colocar valores entre aspas manualmente.
        </para>

        <para>
            O primeiro deles é o método <code>quote()</code>.  Ele coloca um valor escalar 
			entre aspas apropriadamente de acordo com o adaptador utilizado; se você tentar
			executá-lo em uma matriz, ele retornará uma lista separada por vírgulas com os
			valores da matriz, cada um devidamente entre aspas (útil para funções que 
			recebem uma lista de parâmetros).
        </para>

        <programlisting role="php"><![CDATA[<?php

// crie um objeto $db usando Mysql como adaptador.

// protege o valor escalar
$value = $db->quote('St John"s Wort');
// $value é agora '"St John\"s Wort"' (perceba as aspas em volta)

// protege uma matriz
$value = $db->quote(array('a', 'b', 'c');
// $value é agora '"a", "b", "c"' (uma string separada por vírgulas)

?>]]></programlisting>

        <para>
            O segundo é o método <code>quoteInto()</code>.  Você fornece uma string
			usando um ponto de interrogação como espaço reservado e um valor escalar
			ou uma matriz.  Isso é útil para fazer consultas e cláusulas por partes.  
			Valores escalares e matrizes funcionam como no método <code>quote()</code>.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// crie um objeto $db usando Mysql como adaptador.

// protege um valor escalar em uma cláusula WHERE
$where = $db->quoteInto('id = ?', 1);
// $where é agora 'id = "1"' (perceba as aspas em volta)

// protege uma matriz em uma cláusula WHERE
$where = $db->quoteInto('id IN(?)', array(1, 2, 3));
// $where é agora 'id IN("1", "2", "3")' (uma string separada por vírgulas)

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.queries">

        <title>Consultas diretas</title>

        <para>
            Uma vez que você tem uma instância de <code>Zend_Db_Adapter</code>,
			você pode executar consultas diretamente em SQL.  
			<code>Zend_Db_Adapter</code> passa estas consultas para o objeto PDO, 
			que as prepara e executa, e então devolve um objeto PDOStatement
			para você manipular os resultados (se houver algum).
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// crie um objeto $db, e então consulte o banco de dados
// com um comando SQL devidamente protegido.
$sql = $db->quoteInto(
    'SELECT * FROM example WHERE date > ?',
    '2006-01-01'
);
$result = $db->query($sql);

// use o PDOStatement $result para pegar todas as linhas em uma matriz
$rows = $result->fetchAll();

?>]]></programlisting>

        <para>
            Você pode vincular dados à sua consulta automaticamente.
			Isto significa que você pode definir noms para múltiplos
			espaços reservados e na consulta, e então passar uma matriz
			de dados que é substituída por aqueles espaços reservados.
			Os valores substituídos são colocados entre aspas 
			automaticamente para você, garantindo mais segurança
			contra ataques de injeção de SQL.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// crie um objeto $db, e então consulte o banco de dados
// desta vez, use vínculos com espaços reservados.
$result = $db->query(
    'SELECT * FROM example WHERE date > :placeholder',
    array('placeholder' => '2006-01-01')
);

// use o PDOStatement $result para pegar todas as linhas em uma matriz
$rows = $result->fetchAll();

?>]]></programlisting>

        <para>
            Opcionalmente, você pode querer preparar e vincular dados a 
			instruções SQL manualmente.  Para fazer isso, use o método 
			<code>prepare()</code> para pegar um <code>PDOStatement</code> 
			preparado que você pode manipular diretamente.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// cria um objeto $db, e então consulta o banco de dados
// desta vez, prepara um PDOStatement para vínculo manual.
$stmt = $db->prepare('SELECT * FROM example WHERE date > :placeholder');
$stmt->bindValue('placeholder', '2006-01-01');
$stmt->execute();

// use o PDOStatement para pegar todas as linhas em uma matriz
$rows = $stmt->fetchAll();

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.transactions">

        <title>Transações</title>

        <para>
            Por padrão, o PDO (e portanto o <code>Zend_Db_Adapter</code>) trabalham
			em modo de "auto-submissão". Isso significa que todas as consultas são 
			executadas conforme são submetidas. Se você quiser executar consultas 
			dentro de uma transação, simplesmente chame o método <code>beginTransaction()</code>,
			e então o método <code>commit()</code> para submeter ou o <code>rollBack()</code>
            para cancelar suas mudanças.  <code>Zend_Db_Adapter</code> volta para o modo
			de "auto-submissão" até que você chame <code>beginTransaction()</code> novamente.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// crie um objeto $db, e então inicie uma transação.
$db->beginTransaction();

// tente uma consulta.
// se bem sucedida, submeta as alterações;
// se falhar, rollback().
try {
    $db->query(...);
    $db->commit();
} catch (Exception $e) {
    $db->rollBack();
    echo $e->getMessage();
}

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.insert">

        <title>Inserindo Linhas</title>

        <para>
            Como conveniência, você pode usar o método <code>insert()</code> para criar
            um comando INSERT e vincular dados a serem inseridos nele.
            (O dado vinculado é protegido automaticamente para ajudar a prevenir ataques 
            de SQL injection.)
        </para>

        <para>
            O valor retornado <emphasis>não é</emphasis> o último ID inserido, pois a tabela
            pode não ter uma coluna auto-incrementável; ao invés disso, o valor retornado
            é o número de linhas afetadas (normalmente 1).  se você quer o
            ID odo último registro inserido, chame o método <code>lastInsertId()</code> depois
			da inserção.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// INSERT INTO round_table
//     (noble_title, first_name, favorite_color)
//     VALUES ("King", "Arthur", "blue");
//

// crie um objeto $db, e então...
// os dados da linha no formato coluna => valor
$row = array (
    'noble_title'    => 'King',
    'first_name'     => 'Arthur',
    'favorite_color' => 'blue',
);

// a tabela na qual a linha será inserida
$table = 'round_table';

// insira a linha e pegue o ID
$rows_affected = $db->insert($table, $row);
$last_insert_id = $db->lastInsertId();

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.update">

        <title>Atualizando Linhas</title>

        <para>
            Como conveniência, você pode usar o método <code>update()</code> para criar
            um comando UPDATE e vincular dados a serem atualizados nele.
            (O dado vinculado é protegido automaticamente para ajudar a prevenir ataques 
            de SQL injection.)
        </para>

        <para>
            Você pode definir uma cláusula WHERE opcional
            para to especificar quais linhas atualizar.  (Note que a cláusula 
			WHERE não é um parâmetro vinvulado, por isso você precisa proteger
			os valores.)
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// UPDATE round_table
//     SET favorite_color = "yellow"
//     WHERE first_name = "Robin";
//

// crie um objeto $db, e então...
// os novos valires paar definir no UPDATE, no formato coluna => valor
$set = array (
    'favorite_color' => 'yellow',
);

// a tabela na qual a linha será atualizada
$table = 'round_table';

// a cláusula WHERE
$where = $db->quoteInto('first_name = ?', 'Robin');

// atualize a tabela e pegue o npumero de linhas afetadas
$rows_affected = $db->update($table, $set, $where);

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.delete">

        <title>Deleting Rows</title>

        <para>
			Como conveniência, você pode usar o método <code>delete()</code> para criar
            um comando DELETE; você pode definir uma cláusula WHERE opcional
            para to especificar quais linhas apagar.  (Note que a cláusula 
			WHERE não é um parâmetro vinvulado, por isso você precisa proteger
			os valores.)
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// DELETE FROM round_table
//     WHERE first_name = "Patsy";
//

// crie um objeto $db, e então...
// defina a tabela de onde apagar
$table = 'round_table';

// a cláusula WHERE
$where = $db->quoteInto('first_name = ?', 'Patsy');

// execute o comando e pegue o npumero de linhas apagadas
$rows_affected = $db->delete($table, $where);

?>]]></programlisting>
    </sect2>

    <sect2 id="zend.db.adapter.fetch">

        <title>Buscando linhas</title>

        <para>
            Apesar de você poder consultar o banco de dados diretamente com o
			método <code>query()</code>, frequentemente tudo o que você precisa 
			fazer é selecionar linhas e pegar os resultados. A série de métodos
            <code>fetch*()</code> faz isso para você.
            Para cada um dos métodos <code>fetch*()</code>, você passa um comando
			SQL SELECT; se voc~e definir lugares reservados nomeados no comando,
			você pode também passar uma matriz de valores vinculados para serem
			protegidos e substituídos no comando para você.
			Os métodos <code>fetch*()</code> são:
        </para>

        <itemizedlist>
            <listitem><para><code>fetchAll()</code></para></listitem>
            <listitem><para><code>fetchAssoc()</code></para></listitem>
            <listitem><para><code>fetchCol()</code></para></listitem>
            <listitem><para><code>fetchOne()</code></para></listitem>
            <listitem><para><code>fetchPairs()</code></para></listitem>
            <listitem><para><code>fetchRow()</code></para></listitem>
        </itemizedlist>

        <programlisting role="php"><![CDATA[<?php
	
// crie um objeto $db, e então...

// busque todas as colunas de todas as linhas como uma matriz sequencial
$result = $db->fetchAll(
    "SELECT * FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// busque todas as colunas de todas as linhas como uma matriz associativa;
// a primeira coluna é usada como chave da matriz.
$result = $db->fetchAssoc(
    "SELECT * FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// busque a primeira colunas de todas as linhas retornadas
$result = $db->fetchCol(
    "SELECT first_name FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// busque apenas o primeiro valor
$result = $db->fetchOne(
    "SELECT COUNT(*) FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// busque uma série de pares chave-valor; a primeira coluna é
// a chave da matriz, a segunda é o valor da matriz
$result = $db->fetchPairs(
    "SELECT first_name, favorite_color FROM round_table WHERE noble_title = :title",
    array('title' => 'Sir')
);

// busque apenas a primeira linha retornada
$result = $db->fetchRow(
    "SELECT * FROM round_table WHERE first_name = :name",
    array('name' => 'Lancelot')
);

?>]]></programlisting>
    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
