<sect1 id="zend.view.scripts">
    
    <title>View Scripte</title>
        
    <para>
        Sobald dein Controller die Variablen übergeben und die render() Methode aufgerufen hat, 
        inkludiert Zend_View das angeforderte View Skript und führt es "innerhalb" des 
        Gültigkeitsbereichs der Zend_View Instanz aus. Deshalb weisen Referenzen auf $this in 
        deinem View Skript auf die Zend_View Instanz selber.  
    </para>
    
    <para>
        Auf Variablen, die vom Controller an den View übergeben worden sind, kann als Eigenschaften
        der Instanz zurückgegriffen werden. Wenn der Controller zum Beispiel eine Variable 
        'irgendwas' übergeben hat, würdest du in deinem View Skript über $this->irgendwas darauf
        zugreifen können. (Dies erlaubt es dir, den Überblick darüber zu behalten, welche Variablen
        an das Skript übergeben worden sind und welche Variablen intern zum Skript selber gehören.)
    </para>
    
    <para>
        Zur Erinnerung hier noch einmal das Beispiel View Skript aus der Zend_View Einführung.        
    </para>
    
    <programlisting role="php"><![CDATA[<?php if ($this->books): ?>
    
    <!-- Eine Tabelle mit einigen Büchern. -->
    <table>
        <tr>
            <th>Autor</th>
            <th>Titel</th>
        </tr>
        
        <?php foreach ($this->books as $key => $val): ?>
        <tr>
            <td><?php echo $this->escape($val['author']) ?></td>
            <td><?php echo $this->escape($val['title']) ?></td>
        </tr>
        <?php endforeach; ?>
        
    </table>
    
<?php else: ?>
    
    <p>Es gibt keine Bücher zum Anzeigen.</p>
    
<?php endif; ?>]]>
    </programlisting>
        
    <sect2 id="zend.view.scripts.escaping">
        
        <title>Ausgaben maskieren</title>
        
        <para>
            Eine der wichtigsten Aufgaben, die in einem View Skript zu erledigen sind, ist es 
            sicherzustellen, dass die Ausgaben auch richtig maskiert sind; neben anderen Dingen
            hilft dies auch Cross-Site Scripting Attacken zu vermeiden. Sofern du keine Funktion,
            Methode oder einen Helfer verwendest, der die Maskierungen selber durchführt, solltest
            Du Variablen immer maskieren, wenn du sie ausgeben möchtest.
        </para>
        
        <para>
            Zend_View stellt eine Methode escape() bereit, die das Maskieren für dich übernimmt.
        </para>
        
        <programlisting role="php"><![CDATA[<?php
// schlechte View Skript Praxis:
echo $this->variable;

// gute View Skript Praxis:
echo $this->escape($this->variable);
?>]]>
        </programlisting>
        
        <para>
            Standardmäßig verwendet escape() die PHP htmlspecialchars() Funktion für die Maskierung.
            Allerdings könntest du abhängig von deiner Umgebung den Wunsch haben, die Maskierung
            anders durchzuführen. Verwende die setEscape() Methode auf der Controller Ebene, um 
            Zend_View mitzuteilen, welche Maskierungsmöglichkeit als Callback verwendet werden soll.
        </para>
        
        <programlisting role="php"><![CDATA[<?php
// erstelle eine Zend_View Instanz
$view = new Zend_View();

// teile ihr mit, dass htmlentities für die Maskierung
// verwendet werden soll
$view->setEscape('htmlentities');

// oder teile ihr mit, eine statische Klassenmethode für
// die Maskierung zu verwenden
$view->setEscape(array('SomeClass', 'methodName'));

// sogar Instanzmethoden sind möglich
$obj = new SomeClass();
$view->setEscape(array($obj, 'methodName'));

// und dann erstelle die Ausgabe
echo $view->render(...);
?>]]>
        </programlisting>
        
        <para>
            Diese Callback Funktion oder Methode sollte den zu maskierenden Wert als ersten 
            Parameter übernehmen und alle anderen Parameter sollten optional sein.
        </para>
        
    </sect2>

    <sect2 id="zend.view.scripts.templates">
    
        <title>Templatesysteme</title>
        
        <para>
            Obwohl PHP selber eine mächtiges Templatesystem ist, haben viele Entwickler das Gefühl,
            dass es zu mächtig oder komplex für die Template Designer ist. Deshalb kann das View 
            Skript auch verwendet werden, um ein separates Templatesystem zu instanzieren und zu
            verarbeiten. Das View Skript für einen solchen Ablauf könnte wie folgt aussehen: 
        </para>
        
        <programlisting role="php"><![CDATA[<?php
include_once 'template.inc';
$tpl = new Template();

if ($this->books) {
    $tpl->setFile(array(
        "booklist" => "booklist.tpl",
        "eachbook" => "eachbook.tpl",
    ));
    
    foreach ($this->books as $key => $val) {
        $tpl->set_var('author', $this->escape($val['author']);
        $tpl->set_var('title', $this->escape($val['title']);
        $tpl->parse("books", "eachbook", true);
    }
    
    $tpl->pparse("output", "booklist");
} else {
    $tpl->setFile("nobooks", "nobooks.tpl")
    $tpl->pparse("output", "nobooks");
}
?>]]>
        </programlisting>
        
        <para>
            Dies wären die zugehörigen Template Dateien:
        </para>
        
        <programlisting role="html"><![CDATA[
<!-- booklist.tpl -->
<table>
    <tr>
        <th>Autor</th>
        <th>Titel</th>
    </tr>
    {books}
</table>

<!-- eachbook.tpl -->
    <tr>
        <td>{author}</td>
        <td>{title}</td>
    </tr>

<!-- nobooks.tpl -->
<p>Es gibt keine Bücher zum Anzeigen.</p>
]]>
        </programlisting>
        
    </sect2>
    
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->