<sect1 id="zend.mail.read">
    <title>Lesen von Mail Nachrichten</title>

    <para>
        <code>Zend_Mail</code> kann Mail Nachrichten von verschiedenen lokalen oder entfernen Mailspeichern lesen.
        Alle von diesen haben die selbe Basis API für das Zählen und Holen von Nachrichten und einige von Ihnen
        implementieren zusätzliche Interfaces für nicht so übliche Features. Für eine Übersicht der Features der
        implementierten Speicher kann in die folgende Tabelle gesehen werden.
    </para>

    <table>
        <title>Übersicht der Lesefeatures für Mails</title>
        <tgroup cols="5">
            <thead>
                <row>
                    <entry>Feature</entry>
                    <entry>Mbox</entry>
                    <entry>Maildir</entry>
                    <entry>Pop3</entry>
                    <entry>IMAP</entry>
                </row>
            </thead>
            <tbody>
                <row>
                    <entry>Speichertyp</entry>
                    <entry>lokal</entry>
                    <entry>lokal</entry>
                    <entry>entfernt</entry>
                    <entry>entfernt</entry>
                </row>
                <row>
                    <entry>Nachrichten holen</entry>
                    <entry>Yes</entry>
                    <entry>Yes</entry>
                    <entry>Yes</entry>
                    <entry>Yes</entry>
                </row>
                <row>
                    <entry>Mime-Part holen</entry>
                    <entry>emulated</entry>
                    <entry>emulated</entry>
                    <entry>emulated</entry>
                    <entry>emulated</entry>
                </row>
                <row>
                    <entry>Ordner</entry>
                    <entry>Yes </entry>
                    <entry>Yes</entry>
                    <entry>No</entry>
                    <entry>Yes</entry>
                </row>
                <row>
                    <entry>Erstellen von Nachrichten/Ordnern</entry>
                    <entry>No</entry>
                    <entry>todo</entry>
                    <entry>No</entry>
                    <entry>todo</entry>
                </row>
                <row>
                    <entry>Merker</entry>
                    <entry>No</entry>
                    <entry>Yes</entry>
                    <entry>No</entry>
                    <entry>Yes</entry>
                </row>
            </tbody>
        </tgroup>
    </table>

    <sect2 id="zend.mail.read-example">
        <title>Einfaches Beispiel für POP3</title>

        <programlisting role="php"><![CDATA[<?php
$mail = new Zend_Mail_Storage_Pop3(array('host'     => 'localhost',
                                         'user'     => 'test',
                                         'password' => 'test'));

echo $mail->countMessages() . " Nachrichten gefunden\n";
foreach ($mail as $message) {
    echo "Mail von '{$message->from}': {$message->subject}\n";
}
]]></programlisting>

    </sect2>
    <sect2 id="zend.mail.read-open-local">
        <title>Öffnen eines lokalen Speichers</title>

        <para>
            Mbox und Maildir sind zwei unterstützte Formate für lokale Mailspeicher, beide in Ihrem einfachsten
            Format.
        </para>
        <para>
            Wenn von einer Mbox Datei gelesen werden soll muß nur der Dateiname an den Konstruktor von
            <code>Zend_Mail_Storage_Mbox</code> übergeben werden:
        </para>

        <programlisting role="php"><![CDATA[<?php
$mail = new Zend_Mail_Storage_Mbox(array('filename' => '/home/test/mail/inbox'));
]]></programlisting>

        <para>Maildir ist sehr einfach benötigt aber einen Verzeichnisnamen:</para>

        <programlisting role="php"><![CDATA[<?php
$mail = new Zend_Mail_Storage_Maildir(array('dirname' => '/home/test/mail/'));
]]></programlisting>

        <para>Beide Konstruktoren werfen eine <code>Zend_Mail_Exception</code> Ausnahme wenn der Speicher nicht
        gelesen werden kann.</para>

    </sect2>
    <sect2 id="zend.mail.read-open-remote">
        <title>Öffnen eines entfernten Speichers</title>

        <para>
            Für entfernte Speicher werden die zwei populärsten Protokolle unterstützt: Pop3 und Imap. Beide
            benötigen mindestens einen Host und einen Benutzer für das Verbinden und das Login. Das Standardpasswort
            ist ein leerer String, der Standardport wie im RFC Protokoll definiert.
        </para>

        <programlisting role="php"><![CDATA[<?php
// Verbinden mit Pop3
$mail = new Zend_Mail_Storage_Pop3(array('host'     => 'example.com'
                                         'user'     => 'test',
                                         'password' => 'test'));

// Verbinden mit Imap
$mail = new Zend_Mail_Storage_Imap(array('host'     => 'example.com'
                                         'user'     => 'test',
                                         'password' => 'test'));

// Beispiel für einen nicht Standardport
$mail = new Zend_Mail_Storage_Pop3(array('host'     => 'example.com',
                                         'port'     => 1120
                                         'user'     => 'test',
                                         'password' => 'test'));
]]></programlisting>

        <para>
            Für beide Speicher werden SSL und TLS unterstützt. Wenn SSL verwendet wird, wird der Standardport laut
            RFC geändert.
        </para>

        <programlisting role="php"><![CDATA[<?php
// Beispiel für Zend_Mail_Storage_Pop3, funktioniert auch für Zend_Mail_Storage_Imap

// SSL mit einem unterschiedlichen Port verwenden (Standard ist 995 für Pop3 und 993 für Imap)
$mail = new Zend_Mail_Storage_Pop3(array('host'     => 'example.com'
                                         'user'     => 'test',
                                         'password' => 'test',
                                         'ssl'      => 'SSL'));

// Verwenden von TLS
$mail = new Zend_Mail_Storage_Pop3(array('host'     => 'example.com'
                                         'user'     => 'test',
                                         'password' => 'test',
                                         'ssl'      => 'TLS'));
]]></programlisting>

        <para>
            Beide Konstruktoren können eine <code>Zend_Mail_Exception</code> oder
            <code>Zend_Mail_Protocol_Exception</code> werfen (erweitert <code>Zend_Mail_Exception</code>),
            abhängig vom Typ des Fehlers.
        </para>

    </sect2>
    <sect2 id="zend.mail.read-fetching">
        <title>Nachrichten holen und einfache Methoden</title>

        <para>
            Wenn der Speicher einmal geöffnet wurde können Nachrichten geholt werden. Man benötigt die
            Nachrichtennummer, welche ein Zähler ist der mit 1 für die erste Nachricht beginnt. Um die Nachrichten
            zu holen muß die Methode <code>getMessage()</code> verwendet werden:
        </para>

        <programlisting role="php"><![CDATA[<?php
$message = $mail->getMessage($messageNum);
]]></programlisting>

        <para>
            Zugriff über Arrays ist auch möglich, unterstützt aber nicht jeden zusätzlichen Parameter der zu
            <code>getMessage()</code> hinzugefügt werden könnte:
        </para>

        <programlisting role="php"><![CDATA[<?php
$message = $mail[$messageNum];
]]></programlisting>

        <para>Um über alle Nachrichten zu iterieren wurde das Iterator Interface implementiert:</para>

        <programlisting role="php"><![CDATA[<?php
foreach ($mail as $messageNum => $message) {
    // mach was ...
}
]]></programlisting>

        <para>
            Um die Nachrichten im Speicher zu zählen kann entweder die Methode <code>countMessages()</code> oder
            der Zugriff auf Arrays verwendet werden:
        </para>

        <programlisting role="php"><![CDATA[<?php
// Methode
$maxMessage = $mail->countMessages();

// Array Zugriff
$maxMessage = count($mail);
]]></programlisting>

        <para>Um eine Mail zu entfernen kann die Methode <code>removeMessage()</code> oder auch der Array Zugriff
        verwendet werden:</para>

        <programlisting role="php"><![CDATA[<?php
// Methode
$mail->removeMessage($messageNum);

// Array Zugriff
unset($mail[$messageNum]);
]]></programlisting>

    </sect2>
    <sect2 id="zend.mail.read-message">
        <title>Arbeiten mit Nachrichten</title>

        <para>Nachdem die Nachrichten mit <code>getMessage()</code> geholt wurden, wird man die Kopfzeilen, den
        Inhalt oder einzelne Teile einer Mehrteiligen Nachricht holen wollen. Auf alle Kopfzeilen kann über die
        Eigenschaften oder die Methode <code>getHeader()</code>, wenn man mehr Kontrolle oder ungewöhnliche
        Kopfzeilen hat, zugegriffen werden. Die Kopfzeilen sind intern kleingeschrieben, weswegen die Groß- und
        Kleinschreibung der Kopfzeilen in der Mail Nachricht egal ist. Kopfzeilen mit einem Bindestrich können auch
        in camel-case Schreibweise geschrieben werden.</para>

        <programlisting role="php"><![CDATA[<?php
// Nachrichten Objekt holen
$message = $mail->getMessage(1);

// Betreff der Nachricht holen
echo $message->subject . "\n";

// Inhalts-Typ der Kopfzeile holen
$type = $message->contentType;
]]></programlisting>

        <para>Wenn mehrere Kopfzeilen mit dem selben Namen vorhanden sind z.B. die empfangenen Kopfzeilen
        kann es gewünscht sein diese als Array statt als String zu haben, was mit der <code>getHeader()</code>
        Methode möglich ist.</para>

        <programlisting role="php"><![CDATA[<?php
// Kopfzeilen als Eigenschaft holen - das Ergebnis ist immer ein String, mit Zeilenumbruch zwischen den einzelnen Vorkommen in der Nachricht
$received = $message->received;

// Das gleiche über die getHeader() Methode
$received = $message->getHeader('received', 'string');

// Besser ein Array mit einem einzelnen Eintrag für jedes Vorkommen
$received = $message->getHeader('received', 'array');
foreach ($received as $line) {
    // irgendwas tun
}

// Wenn kein Format definiert wurde wird die interne Repräsentation ausgegeben (String für einzelne Kopfzeilen, Array für mehrfache)
$received = $message->getHeader('received');
if (is_string($received)) {
    // Nur eine empfangene Kopfzeile in der Nachricht gefunden
}
]]></programlisting>

        <para>Die Methode <code>getHeaders()</code> gibt alle Kopfzeilen als Array mit den kleingeschriebenen Namen
        als Schlüssel und den Wert als Array für mehrere Kopfzeilen oder als String für einzelne Kopfzeilen.</para>

        <programlisting role="php"><![CDATA[<?php
// Alle Kopfzeilen wegschmeißen
foreach ($message->getHeaders as $name => $value) {
    if (is_string($value)) {
        echo "$name: $value\n";
        continue;
    }
    foreach ($value as $entry) {
        echo "$name: $entry\n";
    }
}
]]></programlisting>

        <para>Wenn keine Nachricht aus mehreren Teilen vorlieg kann der Inhalt sehr einfach über
        <code>getContent()</code> geholt werden. Anders als die Kopfzeilen wird der Inhalt nur geholt wenn dies
        benötigt wird (wie spätes-holen).</para>

        <programlisting role="php"><![CDATA[<?php
// Inhalt der Nachricht für HTML ausgeben
echo '<pre>';
echo $message->getContent();
echo '</pre>';
]]></programlisting>

        <para>Die Prüfung auf mehrteilige Nachrichten wird in der Methode <code>isMultipart()</code> gemacht.
        Wenn eine mehrteilige Nachricht vorliegt kann eine Instanz von <code>Zend_Mail_Part</code> mit der
        Methode <code>getPart()</code> geholt werden. <code>Zend_Mail_Part</code> ist die Basisklasse von
        <code>Zend_Mail_Message</code>, sie hat also die gleichen Methoden: <code>getHeader()</code>,
        <code>getHeaders()</code>, <code>getContent()</code>, <code>getPart()</code>, <code>isMultipart</code>
        und die Eigenschaften der Kopfzeilen.</para>

        <programlisting role="php"><![CDATA[<?php
// Hole den ersten nicht geteilten Teil
$part = $message;
while ($part->isMultipart()) {
    $part = $message->getPart(1);
}
echo 'Der Typ des Teils ist ' . strtok($part->contentType, ';') . "\n";
echo "Inhalt:\n";
echo $part->getContent();
]]></programlisting>

        <para>Zend_Mail_Part implementiert auch den RecursiveIterator, welcher es sehr einfach macht alle Teile
        zu durchsuchen. Und für die einfache Ausgabe wurde auch die magische Methode __toString() implementiert,
        welche den Inhalt zurückgibt.</para>

        <programlisting role="php"><![CDATA[<?php
// Gibt den ersten text/plain Teil aus
$foundPart = null;
foreach (RecursiveIteratorIterator($mail->getMessage(1)) as $part) {
    try {
        if (strtok($part->contentType, ';') == 'text/plain') {
            $foundPart = $part;
            break;
        }
    } catch (Zend_Mail_Exception $e) {
        // ignorieren
    }
}
if (!$foundPart) {
    echo 'kein reiner Text-Teil gefunden';
} else {
    echo "Reiner Text-Teil: \n" . $foundPart;
}
]]></programlisting>

    </sect2>
    <sect2 id="zend.mail.read-flags">
        <title>Auf Flags prüfen</title>

        <para>Maildir und IMAP unterstützen das Speichern von Flags. Die Klasse Zend_Mail_Storage hat Konstanten für
        alle bekannten maildir und IMAP System Flags, welche <code>Zend_Mail_Storage::FLAG_&lt;flagname&gt;</code>
        heißen. Um auf Flags zu prüfen hat <code>Zend_Mail_Message</code> eine Methode die <code>hasFlag()</code>
        heißt. Mit <code>getFlags()</code> erhält man alle gesetzten Flags.</para>

        <programlisting role="php"><![CDATA[<?php
// Finde ungelesene Nachrichten
echo "Ungelesene Nachrichten:\n";
foreach ($mail as $message) {
    if ($message->hasFlag(Zend_Mail_Storage::FLAG_SEEN)) {
        continue;
    }
    // Vorherige/Neue Nachrichten markieren
    if ($message->hasFlag(Zend_Mail_Storage::FLAG_RECENT)) {
        echo '! ';
    } else {
        echo '  ';
    }
    echo $message->subject . "\n";
}


// Prüfen auf bekannte Flags
$flags = $message->getFlags();
echo "Nachricht wurde markiert als: ";
foreach ($flags as $flag) {
    switch ($flag) {
        case Zend_Mail_Storage::FLAG_ANSWERED:
            echo 'Beantwortet ';
            break;
        case Zend_Mail_Storage::FLAG_FLAGGED:
            echo 'Markiert ';
            break;

        // ...
        // Auf andere Flags prüfen
        // ...

        default:
            echo $flag . '(unbekanntes Flag) ';
    }
}
]]></programlisting>

        <para>As IMAP allows user or client defined flags you could get flags, that don't have a constant in
        <code>Zend_Mail_Storage</code>. Instead they are returned as string and can be checked the same way with
        <code>hasFlag()</code>.</para>

        <programlisting role="php"><![CDATA[<?php
// check message for client defined flags $IsSpam, $SpamTested
if (!$message->hasFlag('$SpamTested')) {
    echo 'message has not been tested for spam';
} else if ($message->hasFlag('$IsSpam')) {
    echo 'this message is spam';
} else {
    echo 'this message is ham';
}
]]></programlisting>

    </sect2>
    <sect2 id="zend.mail.read-folders">
        <title>Using folders</title>

        <para>
            All storages, except Pop3, support folders, also called mailboxes. The interface implemented by all storages
            supporting folders is called <code>Zend_Mail_Storage_Folder_Interface</code>. Also all of these classes have an
            additional optional parameter called folder, which is the folder selected after login, in the constructor.
        </para>
        <para>
            For the local storages you need to use separate classes called <code>Zend_Mail_Storage_Folder_Mbox</code> or
            <code>Zend_Mail_Storage_Folder_Maildir</code>. Both need one parameter called dirname with the name of the base dir.
            The format for maildir is as defined in maildir++ (with a dot as default delimiter), Mbox is a directory
            hierarchy with Mbox files. If you don't have a Mbox file called INBOX in your Mbox base dir you need to set
            an other folder in the constructor.
        </para>
        <para>
            <code>Zend_Mail_Storage_Imap</code> already supports folders by default. Examples for opening these storages:
        </para>

        <programlisting role="php"><![CDATA[<?php
// mbox with folders
$mail = new Zend_Mail_Storage_Folder_Mbox(array('dirname' => '/home/test/mail/'));

// mbox with a default folder not called INBOX, also works
// with Zend_Mail_Storage_Folder_Maildir and Zend_Mail_Storage_Imap
$mail = new Zend_Mail_Storage_Folder_Mbox(array('dirname' => '/home/test/mail/',
                                                'folder'  => 'Archive'));

// maildir with folders
$mail = new Zend_Mail_Storage_Folder_Maildir(array('dirname' => '/home/test/mail/'));

// maildir with colon as delimiter, as suggested in Maildir++
$mail = new Zend_Mail_Storage_Folder_Maildir(array('dirname' => '/home/test/mail/'
                                                   'delim'   => ':'));

// imap is the same with and without folders
$mail = new Zend_Mail_Storage_Imap(array('host'     => 'example.com'
                                         'user'     => 'test',
                                         'password' => 'test'));
]]></programlisting>

        <para>
            With the method getFolders($root = null) you can get the folder hierarchy starting with the root folder or
            the given folder. It's returned as instance of <code>Zend_Mail_Storage_Folder</code>, which implements
            <code>RecursiveIterator</code> and all children are also instances of <code>Zend_Mail_Storage_Folder</code>. Each of
            these instances has a local and a global name returned by the methods <code>getLocalName()</code> and
            <code>getGlobalName()</code>. The global name is the absolute name from the root folder (including
            delimiters), the local name is the name in the parent folder.
        </para>

        <table>
            <title>Mail Folder Names</title>
            <tgroup cols="2">
                <thead>
                    <row>
                        <entry>Global Name</entry>
                        <entry>Local Name</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>/INBOX</entry>
                        <entry>INBOX</entry>
                    </row>
                    <row>
                        <entry>/Archive/2005</entry>
                        <entry>2005</entry>
                    </row>
                    <row>
                        <entry>List.ZF.General</entry>
                        <entry>General</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <para>
            If you use the iterator the key of the current element is the local name. The global name is also returned
            by the magic method <code>__toString()</code>. Some folders may not be selectable, which means they can't
            store messages and selecting them results in an error. This can be checked with the method
            <code>isSelectable()</code>. So it's very easy to output the whole tree in a view:
        </para>

        <programlisting role="php"><![CDATA[<?php
$folders = new RecursiveIteratorIterator($this->mail->getFolders(),
                                         RecursiveIteratorIterator::SELF_FIRST);
echo '<select name="folder">';
foreach ($folders as $localName => $folder) {
    $localName = str_pad('', $folders->getDepth(), '-', STR_PAD_LEFT) . $localName;
    echo '<option';
    if (!$folder->isSelectable()) {
        echo ' disabled="disabled"';
    }
    echo ' value="' . htmlspecialchars($folder) . '">'
        . htmlspecialchars($localName) . '</option>';
}
echo '</select>';
]]></programlisting>

        <para>
            The current selected folders is returned by the method <code>getSelectedFolder()</code>. Changing the folder
            is done with the method <code>selectFolder()</code>, which needs the global name as parameter. If you want
            to avoid to write delimiters you can also use the properties of a <code>Zend_Mail_Storage_Folder</code> instance:
        </para>

        <programlisting role="php"><![CDATA[<?php
// depending on your mail storage and its settings $rootFolder->Archive->2005
// is the same as:
//   /Archive/2005
//  Archive:2005
//  INBOX.Archive.2005
//  ...
$folder = $mail->getFolders()->Archive->2005;
echo 'Last folder was ' . $mail->getSelectedFolder() . "new folder is $folder\n";
$mail->selectFolder($folder);
]]></programlisting>

    </sect2>
    <sect2 id="zend.mail.read-advanced">
        <title>Advanced Use</title>

        <sect3>
            <title>Using NOOP</title>

            <para>
                If you're using a remote storage and have some long tasks you might need to keep the connection alive
                via noop:
            </para>

            <programlisting role="php"><![CDATA[<?php
foreach ($mail as $message) {

    // do some calculations ...

    $mail->noop(); // keep alive

    // do something else ...

    $mail->noop(); // keep alive
}
]]></programlisting>

        </sect3>
        <sect3>
            <title>Caching instances</title>

            <para>
            <code>Zend_Mail_Storage_Mbox</code>, <code>Zend_Mail_Storage_Folder_Mbox</code>, <code>Zend_Mail_Storage_Maildir</code> and
            <code>Zend_Mail_Storage_Folder_Maildir</code> implement the magic methods <code>__sleep()</code> and
            <code>__wakeup()</code>, which means they are serializable. This avoids parsing the files or directory tree
            more than once. The disadvantage is that your Mbox or Maildir storage should not change. Some easy checks
            are done, like reparsing the current Mbox file if the modification time changes or reparsing the folder
            structure if a folder has vanished (which still results in an error, but you can search for an other folder
            afterwards). It's better if you have something like a signal file for changes and check it before using the
            cached instance.
            </para>

            <programlisting role="php"><![CDATA[<?php
// there's no specific cache handler/class used here,
// change the code to match your cache handler
$signal_file = '/home/test/.mail.last_change';
$mbox_basedir = '/home/test/mail/';
$cache_id = 'example mail cache ' . $mbox_basedir . $signal_file;

$cache = new Your_Cache_Class();
if (!$cache->isCached($cache_id) || filemtime($signal_file) > $cache->getMTime($cache_id)) {
    $mail = new Zend_Mail_Storage_Folder_Pop3(array('dirname' => $mbox_basedir));
} else {
    $mail = $cache->get($cache_id);
}

// do stuff ...

$cache->set($cache_id, $mail);
]]></programlisting>

        </sect3>
        <sect3>
            <title>Extending Protocol Classes</title>

            <para>
                Remote storages use two classes: <code>Zend_Mail_Storage_&lt;Name&gt;</code> and
                <code>Zend_Mail_Protocol_&lt;Name&gt;</code>. The protocol class translates the protocol commands and
                responses from and to PHP, like methods for the commands or variables with different structures for
                data. The other/main class implements the common interface.
            </para>

            <para>
                If you need additional protocol features you can extend the protocol class and use it in the
                constructor of the main class. As an example assume we need to knock different ports before we can
                connect to POP3.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Loader.php';
Zend_Loader::loadClass('Zend_Mail_Storage_Pop3');

class Example_Mail_Exception extends Zend_Mail_Exception
{
}

class Example_Mail_Protocol_Exception extends Zend_Mail_Protocol_Exception
{
}

class Example_Mail_Protocol_Pop3_Knock extends Zend_Mail_Protocol_Pop3
{
    private $host, $port;

    public function __construct($host, $port = null)
    {
        // no auto connect in this class
        $this->host = $host;
        $this->port = $port;
    }

    public function knock($port)
    {
        $sock = @fsockopen($this->host, $port);
        if ($sock) {
            fclose($sock);
        }
    }

    public function connect($host = null, $port = null, $ssl = false)
    {
        if ($host === null) {
            $host = $this->host;
        }
        if ($port === null) {
            $port = $this->port;
        }
        parent::connect($host, $port);
    }
}

class Example_Mail_Pop3_Knock extends Zend_Mail_Storage_Pop3
{
    public function __construct(array $params)
    {
        // ... check $params here! ...
        $protocol = new Example_Mail_Protocol_Pop3_Knock($params['host']);

        // do our "special" thing
        foreach ((array)$params['knock_ports'] as $port) {
            $protocol->knock($port);
        }

        // get to correct state
        $protocol->connect($params['host'], $params['port']);
        $protocol->login($params['user'], $params['password']);

        // initialize parent
        parent::__construct($protocol);
    }
}

$mail = new Example_Mail_Pop3_Knock(array('host'        => 'localhost',
                                          'user'        => 'test',
                                          'password'    => 'test',
                                          'knock_ports' => array(1101, 1105, 1111)));
]]></programlisting>

            <para>
                As you see we always assume we're connected, logged in and, if supported, a folder is selected in the
                constructor of the main class. Thus if you assign your own protocol class you always need to make sure
                that's done or the next method will fail if the server doesn't allow it in the current state.
            </para>

        </sect3>
    </sect2>
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->
