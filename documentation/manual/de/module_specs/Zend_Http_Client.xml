<sect1 id="zend.http.client">
    <title>Zend_Http_Client</title>

    <sect2 id="zend.http.client.introduction">
        <title>Einführung</title>
        <para>
            Zend_Http_Client stellt eine einfache Schnittstelle für das Durchführen von Hyper-Text 
            Transfer Protocol (HTTP) Anfragen. Zend_Http_Client unterstützt die meisten einfachen
            Funktionen, die man von einem HTTP Client erwartet, sowie einige komplexere Funktionen,
            wie z.B. HTTP Authentifizierung und Dateiuploads. Erfolgreiche Anfragen (und die meisten
            nicht erfolgreichen ebenfalls) liefern ein Zend_Http_Response Objekt zurück, welches den
            Zugriff auf die Header und den Hauptteil der Antwort ermöglichen (siehe
            <xref linkend="zend.http.response" />).
        </para>
        <para>
            Der Klassenkonstruktor akzeptiert optional eine URL als seinen ersten Parameter (kann
            entweder ein String oder ein Zend_Uri_Http Objekt sein) und ein optionales Array mit
            Konfigurationsparametern. Beides kann ausgelassen und später durch Verwendung der 
            setUri() and setConfig() Methoden gesetzt werden.
            <example>
                <title>Ein Zend_Http_Client Objekt instanzieren</title>
                <programlisting role="php">
<![CDATA[<?php
    require_once 'Zend/Http/Client.php';

    $client = new Zend_Http_Client('http://example.org', array(
        'maxredirects' => 0,
        'timeout'      => 30));
        
    // Dies macht genau das selbe:
    $client = new Zend_Http_Client();
    $client->setUri('http://example.org');
    $client->setConfig(array(
        'maxredirects' => 0,
        'timeout'      => 30));

?>]]></programlisting>
            </example>
        </para>
    </sect2>
    <sect2 id="zend.http.client.configuration">
        <title>Konfigurationsparameter</title>
        <para>
            Der Konstruktor und die setConfig() Methode akzeptieren ein assoziatives Array mit 
            Konfigurationsparametern. Das Setzen dieser Parameter ist optional, da alle einen 
            Standardwert haben.
            <table>
                <title>Zend_Http_Client Konfigurationsparameter</title>
                <tgroup cols="3">
                    <thead>
                        <row>
                            <entry>Parameter</entry>
                            <entry>Beschreibung</entry>
                            <entry>Erwartete Werte</entry>
                            <entry>Standardwert</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>maxredirects</entry>
                            <entry>Maximale Anzahl von zu folgenden Umleitungen (0 = keine)</entry>
                            <entry>integer</entry>
                            <entry>5</entry>
                        </row>
                        <row>
                            <entry>strictredirects</entry>
                            <entry>Ob beim Umleiten genau dem RFC zu folgen ist (siehe 
                            <xref linkend="zend.http.client.redirections" />)</entry>
                            <entry>boolean</entry>
                            <entry>false</entry>
                        </row>
                        <row>
                            <entry>useragent</entry>
                            <entry>String zu Identifizierung des User Agents (gesendet in den 
                            Anfrageheadern)</entry>
                            <entry>string</entry>
                            <entry>'Zend_Http_Client'</entry>
                        </row>
                        <row>
                            <entry>timeout</entry>
                            <entry>Zeitüberschreitung für Verbindungen (Sekunden)</entry>
                            <entry>integer</entry>
                            <entry>10</entry>
                        </row>
                        <row>
                            <entry>httpversion</entry>
                            <entry>Version des HTTP Protokolls</entry>
                            <entry>float (1.1 or 1.0)</entry>
                            <entry>1.1</entry>
                        </row>
                        <row>
                            <entry>adapter</entry>
                            <entry>Zu verwendene Adapterklasse für die Verbindung (siehe 
                            <xref linkend="zend.http.client.adapters" />)</entry>
                            <entry>mixed</entry>
                            <entry>'Zend_Http_Client_Adapter_Socket'</entry>
                        </row>
                        <row>
                            <entry>keepalive</entry>
                            <entry>Ob keep-alive Verbindungen mit dem Server aktiviert werden 
                            sollen. Nützlich und kann die Performance verbessern, wenn mehrere 
                            aufeinanderfolgend Anfragen an den selben Server ausgeführt werden.</entry>
                            <entry>boolean</entry>
                            <entry>false</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>
    </sect2>
    <sect2 id="zend.http.client.basic-requests">
        <title>Durchführen von einfachen HTTP Anfragen</title>
        <para>
            Das Durchführen von einfachen HTTP Anfragen kann sehr leicht durch Verwendung der 
            request() Methode gemacht werden und benötigt selten mehr als drei Codezeilen:
            <example>
                <title>Durchführen einer einfache GET Anfrage</title>
                <programlisting role="php">
<![CDATA[<?php
    require_once 'Zend/Http/Client.php';

    $client = new Zend_Http_Client('http://example.org');
    $response = $client->request();
?>]]></programlisting>
            </example>
            Die request() Methode akzeptiert einen optionalen Parameter - die Anfragemethode. 
            Diese kann GET, POST, PUT, HEAD, DELETE, TRACE, OPTIONS oder CONNECT sein, wie im HTTP 
            Protokoll definiert.
            <footnote>
              <para>
                Siehe RFC 2616 - <ulink url="http://www.w3.org/Protocols/rfc2616/rfc2616.html" />.
              </para>
            </footnote>.
            Zur Erleichterung sind alle als Klassenkonstanten definiert: 
            Zend_Http_Request::GET, Zend_Http_Request::POST und so weiter.
        </para>
        <para>
            Wenn keine Methode angegeben worden ist, wird die durch den letzten Aufruf von 
            setMethod() gesetzte Methode verwendet. Wenn setMethod() vorher nicht aufgerufen worden
            ist, wird als Standardmethode GET verwendet (siehe obiges Beispiel).
            <example>
                <title>Andere Anfragemethoden als GET verwenden</title>
                <programlisting role="php">
<![CDATA[<?php
    // Durchführen einer POST Anfrage
    $response = $client->request('POST');
    
    // Ein weiterer Weg, eine POST Anfrage durchzuführen
    $client->setMethod(Zend_Http_Client::POST);
    $response = $client->request();
?>]]></programlisting>            
            </example>
        </para>
    </sect2>
        
    <sect2 id="zend.http.client.parameters">
        <title>Hinzufügen von GET und POST Parametern</title>
        <para>
            Das Hinzufügen von GET Parametern zu einer HTTP Anfrage ist recht einfach und kann
            entweder über die Angabe als Teil der URL oder durch Verwendung der setParameterGet() 
            Methode erfolgen.
            Diese Methode benötigt den Namen des GET Parameter als seinen ersten Parameter und den
            Wert des GET Parameter als seinen zweiten Parameter. Zur Erleichterung akzeptiert die 
            setParameterGet() Methode auch ein einzelnes assoziatives Array mit GET Parameter als 
            Name => Wert Variablen, was beim setzen von mehreren GET Parametern komfortabler sein
            kann.
            <example>
                <title>Setzen von GET Parametern</title>
                <programlisting role="php">
<![CDATA[<?php
    // Setzen eines GET Parameter mit der setParameterGet Methode
    $client->setParameterGet('knight', 'lancelot');

    // Dies ist äquivalent durch Setzen der URL:
    $client->setUri('http://example.com/index.php?knight=lancelot');
    
    // Hinzufügen mehrerer Parameter durch einen Aufruf
    $client->setParameterGet(array(
        'first_name'  => 'Bender',
        'middle_name' => 'Bending'
        'made_in'     => 'Mexico',
    ));
?>]]></programlisting>
            </example>
        </para>
        <para>
            Während GET Parameter bei jeder Anfragemethode gesetzt werden können, können POST 
            Parameter nur im Hauptteil von POST Anfragen versendet werden. Das Hinzufügen von POST 
            Parameter zu einer Anfrage ist sehr ähnlich wie das Hinzufügen von GET Parametern and
            kann mit der setParameterPost() Methode gemacht werden, die vom Aufbau der 
            setParameterGet() Methode ähnlich ist..
            <example>
                <title>Setzen von POST Parametern</title>
                <programlisting role="php">
<![CDATA[<?php
    // Setzen eines POST Parameters
    $client->setParameterPost('language', 'fr');
    
    // Hinzufügen von mehreren POST Parametern, eines davon mit mehreren Werten
    $client->setParameterPost(array(
        'language'  => 'es',
        'country'   => 'ar',
        'selection' => array(45, 32, 80)
    ));
?>]]></programlisting>
            </example>
            Beim Senden einer POST Anfrage ist zu beachten, dass man sowohl GET als auch POST 
            Parameter setzen kann. Auf der anderen Seite wird durch das Setzen von POST Parametern
            für andere Anfragen als POST kein Fehler ausgeworfen. Solange eine Anfrage keine POST
            Anfrage ist, werden POST Parameter einfach ignoriert.
        </para>
    </sect2>

    <sect2 id="zend.http.client.redirections">
        <title>HTTP Umleitungen</title>
        <para>
            Standardmäßig verarbeitet Zend_Http_Client HTTP Umleitungen automatisch und folgt bis
            zu 5 Umleitungen. Dies kann durch Setzen des 'maxredirects' Konfigurationsparameters 
            gändert werden.
        </para>
        <para>
            Gemäß dem HTTP/1.1 RFC sollten HTTP 301 und 302 Antworten vom Client behandelt werden,
            indem die selbe Anfrage erneut an die angebene Stelle versendet wird - unter Verwendung
            der selben Anfragemethode. Allerdings haben dies die meisten Clients nicht 
            implementiert und verwenden beim Umleiten eine GET Anfrage. Standardmäßig macht 
            Zend_Http_Client genau dasselbe - beim Umleiten einer 301 oder 302 Antwort, werden alle
            GET und POST Parameter zurückgesetzt und eine GET Anfrage wird an die neue Stelle 
            versandt. Dieses Verhalten kann durch Setzen des 'strictredirects' 
            Konfigurationsparameters auf das boolesche TRUE geändert werden.
            <example>
                <title>Strikte Umleitung von 301 und 302 Antworten nach RFC 2616 erzwingen</title>
                <programlisting role="php">
<![CDATA[<?php
    // Strikte Umleitungen
    $client->setConfig(array('strictredirects' => true)
    
    // Nicht strikte Umleitungen
    $client->setConfig(array('strictredirects' => false)
?>]]></programlisting>
            </example>
        </para>
        <para>
            Man kann immer die Anzahl der durchgeführten Umleitungen nach dem Senden einer Anfrage
            durch Verwendung der getRedirectionsCount() Methoden erhalten.
        </para>
    </sect2>
    
    <sect2 id="zend.http.client.cookies">
        <title>Hinzufügen von Cookies und Verwendung von persistenten Cookies</title>
        <para>
        	Zend_Http_Client stellt eine einfache Schnittstelle zum Hinzufügen von Cookies zu einer
        	Anfrage bereit, so dass keine direkten Header Änderungen notwendig sind. Dies wird
        	durch Verwendung der setCookie() Methode erledigt. Diese Methode kann auf mehrere
        	Arten verwendet werden:
        	<example>
                <title>Cookies setzen durch Verwendung von setCookie()</title>
                <programlisting role="php">
<![CDATA[<?php
    // Ganz einfach: durch Übergabe von Namen und Wert für den Cookie
    $client->setCookie('flavor', 'chocolate chips');
    
    // Durch direktes Übergeben eines unverarbeiteten Cookie Strings (Name=Wert)
    // Beachte, dass der Wert bereits URL kodiert sein muss
    $client->setCookie('flavor=chocolate%20chips');
    
    // Durch Übergabe eins Zend_Http_Cookie Objekts
    $cookie = Zend_Http_Cookie::factory('flavor=chocolate%20chips');
    $client->setCookie($cookie);
?>]]></programlisting>
            </example>
            Für weitere Informationen über Zend_Http_Cookie Objekte, siehe
        	<xref linkend="zend.http.cookies" />.
        </para>
        <para>
            Zend_Http_Client stellt außerdem die Möglichkeiten für "Cookie Stickiness" bereit - das
            bedeutet, dass der Client intern alle gesendeten und erhaltenen Cookies speichert und
            bei nachfolgenden Anfragen automatisch wieder mit sendet. Dies ist z.B. nützlich, wenn
            man sich bei einer entfernten Site zuerst einloggen muss und einen Authentifizierungs-
            oder Session-Cookie erhält, bevor man weitere Anfragen versenden kann.
            <example>
                <title>Cookie Stickiness aktivieren</title>
                <programlisting role="php">
<![CDATA[<?php
    // Um die Cookie Stickiness einzuschalten, setze eine Cookie Jar (Keksdose)
    $client->setCookieJar();
    
    // Erste Anfrage: einloggen und eine Session starten
    $client->setUri('http://example.com/login.php');
    $client->addParameterPost('user', 'h4x0r');
    $client->addParameterPost('password', '1337');
    $client->request('POST');
    
    // Die Cookie Jar speichert die Cookies automatisch in der Antwort
    // wie z.B. ein Session ID Cookie.
    
    // Nun können wir die nächste Anfrage senden - die gespeicherten Cookies
    // werden automatisch mit gesendet
    $client->setUri('http://example.com/read_member_news.php');
    $client->request('GET');
?>]]></programlisting>
            </example>
            Für weitere Informationen über die Zend_Http_CookieJar Klasse, siehe
        	<xref linkend="zend.http.cookies.cookiejar" />.
        </para>
    </sect2>
    
    <sect2 id="zend.http.client.custom_headers">
        <title>Setzen von individuellen Anfrageheadern</title>
        <para>
            Das Setzen von individuellen Headern kann durch Verwendung der setHeaders() Methode 
            erledigt werden. Diese Methode ist sehr facettenreich und kann auf verschiedene Arten
            verwendet werden, wie das folgende Beispiel zeigt:
            <example>
                <title>Setzen eines einzelnen individuellen Anfrageheaders</title>
                <programlisting role="php">
<![CDATA[<?php
    // Setzen eines einzelnen Headers, vorherige werden überschrieben
    $client->setHeaders('Host', 'www.example.com');
    
    // Ein anderer Weg um genau das Gleiche zu erreichen
    $client->setHeaders('Host: www.example.com');
    
    // Setzen von verschiedenen Werten für den selben Header (besonders für Cookie Header nützlich):
    $client->setHeaders('Cookie', array(
        'PHPSESSID=1234567890abcdef1234567890abcdef',
        'language=he'
    ));
?>]]></programlisting>
            </example>
        </para>
        <para>
            setHeader() kann genauso einfach für das Setzen mehrerer Header in einem Aufruf durch 
            Übergabe eines Array mit Headern als einzigen Parameter verwendet werden:
            <example>
                <title>Setzen eines mehreren individuellen Anfrageheaders</title>
                <programlisting role="php">
<![CDATA[<?php
    // Setzen von mehreren Headern, vorherige werden überschrieben
    $client->setHeaders(array(
        'Host' => 'www.example.com',
        'Accept-encoding', 'gzip,deflate',
        'X-Powered-By' => 'Zend Framework'));
    
    // Das Array kann auch komplette Array Strings enthalten:
    $client->setHeaders(array(
        'Host: www.example.com',
        'Accept-encoding: gzip,deflate',
        'X-Powered-By: Zend Framework'));
?>]]></programlisting>
            </example>
        </para>
    </sect2>
    
    <sect2 id="zend.http.client.file_uploads">
        <title>File Uploads</title>
        <para>
            You can upload files through HTTP using the setFileUpload method. 
            This method takes a file name as the first parameter, a form name 
            as the second parameter, and data as a third optional parameter. 
            If the third data parameter is null, the first file name parameter
            is considered to be a real file on disk, and Zend_Http_Client will
            try to read this file and upload it. If the data parameter is not
            null, the first file name parameter will be sent as the file name,
            but no actual file needs to exist on the disk.
            The second form name parameter is always required, and is equivalent
            to the "name" attribute of an &gt;input&lt; tag, if the file was to
            be uploaded through an HTML form.
            A fourth optional parameter provides the file's content-type. If
            not specified, and Zend_Http_Client reads the file from the disk,
            the mime_content_type function will be used to guess the file's 
            content type, if it is available. In any case, the default MIME
            type will be application/octet-stream.
            <example>
                <title>Using setFileUpload to Upload Files</title>
                <programlisting role="php">
<![CDATA[<?php
    // Uploading arbitrary data as a file
    $text = 'this is some plain text';
    $client->setFileUpload('some_text.txt', 'upload', $text, 'text/plain');
    
    // Uploading an existing file 
    $client->setFileUpload('/tmp/Backup.tar.gz', 'bufile');
    
    // Send the files
    $client->submit('POST');
?>]]></programlisting>
            </example>
            In the first example, the $text variable is uploaded and will be
            available as $_FILES['upload'] on the server side. In the second
            example, the existing file /tmp/Backup.tar.gz is uploaded to the 
            server and will be available as $_FILES['bufile']. The content type
            will be guesses automatically if possible - and if not, the content
            type will be set to 'application/octet-stream'. 
        </para>
        <note>
            <title>Uploading files</title>
            <para>
                When uploading files, the HTTP request content-type is 
                automatically set to multipart/form-data. Keep in mind that
                you must send a POST or PUT request in order to upload files. 
                Most servers will ignore the requests body on other request
                methods.
            </para>
        </note>
    </sect2>
    <sect2 id="zend.http.client.raw_post_data">
        <title>Sending Raw POST Data</title>
        <para>
            You can use a Zend_Http_Client to send raw POST data using the
            setRawData() method. This method takes two parameters: the first
            is the data to send in the request body. The second optional
            parameter is the content-type of the data. While this parameter is
            optional, you should usually set it before sending the request - 
            either using setRawData(), or with another method: setEncType().
            <example>
                <title>Sending Raw POST Data</title>
                <programlisting role="php">
<![CDATA[<?php
    $xml = '<book>' . 
           '  <title>Islands in the Stream</title>' . 
           '  <author>Ernest Hemingway</author>' . 
           '  <year>1970</year>' . 
           '</book>';
           
    $client->setRawData($xml, 'text/xml')->request('POST');
    
    // Another way to do the same thing:
    $client->setRawData($xml)->setEncType('text/xml')->request('POST');
?>]]></programlisting>
            </example>
            The data should be available on the server side through PHP's 
            $HTTP_RAW_POST_DATA variable or through the php://input stream.
        </para>
        <note>
            <title>Using raw POST data</title>
            <para>
                Setting raw POST data for a request will override any POST
                parameters or file uploads. You should not try to use both on
                the same request. Keep in mind that most servers will ignore 
                the request body unless you send a POST request.
            </para>
        </note>
    </sect2>
    
    <sect2 id="zend.http.client.http_authentication">
        <title>HTTP Authentication</title>
        <para>
            Currently, Zend_Http_Client only supports basic HTTP authentication.
            This feature is utilized using the setAuth() method. The method 
            takes 3 parameters: The user name, the password and an optional
            authentication type parameter. As mentioned, currently only basic
            authentication is supported (digest authentication support is
            planned).
            <example>
                <title>Setting HTTP Authentication User and Password</title>
                <programlisting role="php">
<![CDATA[<?php
    // Using basic authentication
    $client->setAuth('shahar', 'myPassword!', Zend_Http_Client::AUTH_BASIC);
    
    // Since basic auth is default, you can just do this:
    $client->setAuth('shahar', 'myPassword!');
?>]]></programlisting>
            </example>
        </para>
    </sect2>
    
    <sect2 id="zend.http.client.multiple_requests">
        <title>Sending Multiple Requests With the Same Client</title>
        <para>
            Zend_Http_Client was also designed specifically to handle several
            consecutive requests with the same object. This is useful in cases
            where a script requires data to be fetched from several places, or
            when accessing a specific HTTP resource requires logging in and 
            obtaining a session cookie, for example. 
        </para>
        <para>
            When performing several requests to the same host, it is highly 
            recommended to enable the 'keepalive' configuration flag. This way,
            if the server supports keep-alive connections, the connection to the
            server will only be closed once all requests are done and the Client
            object is destroyed. This prevents the overhead of opening and 
            closing TCP connections to the server.
        </para>
        <para>
            When you perform several requests with the same client, but want
            to make sure all the request-specific parameters are cleared, you
            should use the resetParameters() method. This ensures that GET and
            POST parameters, request body and request-specific headers are 
            reset and are not reused in the next request.
        </para>
        <note>
            <title>Reseting parameters</title>
            <para>
                Note that non-request specific headers are not reset when the 
                resetParameters method is used. As a matter of fact, only the
                'Content-length' and 'Content-type' headers are reset. This 
                allows you to set-and-forget headers like 'Accept-language' and
                'Accept-encoding'
            </para>
        </note>
        <para>
            Another feature designed specifically for consecutive requests is 
            the Cookie Jar object. Cookie Jars allow you to automatically save
            cookies set by the server in the first request, and send them on
            consecutive requests transparently. This allows, for example, going
            through an authentication request before sending the actual data
            fetching request.
        </para>
        <para>
            If your application requires one authentication request per user,
            and consecutive requests might be performed in more than one script
            in your application, it might be a good idea to store the Cookie Jar
            object in the user's session. This way, you will only need to 
            authenticate the user once every session.
        </para>
        <example>
            <title>Performing consecutive requests with one client</title>
            <programlisting role="php">
<![CDATA[<?php
    // First, instantiate the client 
    $client = new Zend_Http_Client('http://www.example.com/fetchdata.php', array(
        'keepalive' => true
    ));
    
    // Do we have the cookies stored in our session?
    if (isset($_SESSION['cookiejar']) && 
        $_SESSION['cookiejar'] instanceof Zend_Http_CookieJar)) {
        
        $client->setCookieJar($_SESSION['cookiejar']);
    } else {
        // If we don't, authenticate and store cookies
        $client->setCookieJar();
        $client->setUri('http://www.example.com/login.php');
        $client->setParameterPost(array(
            'user' => 'shahar',
            'pass' => 'somesecret'
        ));
        $client->request(Zend_Http_Client::POST);
        
        // Now, clear parameters and set the URI to the original one
        // (note that the cookies that were set by the server are now
        // stored in the jar)
        $client->resetParameters();
        $client->setUri('http://www.example.com/fetchdata.php');
    }
    
    $response = $client->request(Zend_Http_Client::GET);
    
    // Store cookies in session, for next page
    $_SESSION['cookiejar'] = $client->getCookieJar();
?>]]></programlisting>
        </example>
    </sect2>
    
    <sect2 id="zend.http.client.adapters">
        <title>Connection Adapters</title>
        <para>
            Zend_Http_Client is based on a connection adapter design. The
            connection adapter is the object in charge of performing the 
            actual connection to the server, as well as writing requests 
            and writing responses.
            This connection adapter can be replaced, and you can create and
            extend the default connection adapter to suite your special needs,
            without the need to extend or replace the entire HTTP client
            class, and with the same interface.
        </para>
        <para>
            Currently, the Zend_Http_Client class provides two built-in 
            connection adapters: 
            <itemizedlist>
                <listitem>
                    <para><code>Zend_Http_Client_Adapter_Socket</code>: The 
                    default adapter, which is a plain socket based adapter, 
                    and does not require any special PHP extension to use.
                    </para>
                </listitem>
                <listitem>
                    <para><code>Zend_Http_Client_Adapter_Test</code>: This is a
                    dummy adapter, that should be used for testing purposes only.
                    It does not perform any real connections, and returns a 
                    predefined response.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            The Zend_Http_Client object's adapter connection adapter is set 
            using the 'adapter' configuartion option. When instantiating the
            client object, you can set the 'adapter' configuration option to
            a string containing the adapter's name (eg. 'Zend_Http_Client_Adapter_Socket')
            or to a variable holding an adapter object (eg <code>
            new Zend_Http_Client_Adapter_test</code>). You can also set the 
            adapter later, using the Zend_Http_Client->setConfig() method.
        </para>
        <para>
            You can create your own connection adapters and use them. In order
            to do so, you must create your own class that implements the 
            Zend_Http_Client_Adapter_Interface interface. You could, for 
            example, create a connection adapter that uses persistent sockets,
            or a connection adapter with caching abilities, and use them as 
            needed in your application.
        </para>
    </sect2>
    
    <sect2 id="zend.http.client.testing">
        <title>Writing Tests With Zend_Http_Client Objects</title>
        <para>
            Sometimes, it is very hard to test code that relys on HTTP connections.
            For example, testing an application that pulls an RSS feed from a remote 
            server will require a network connection, which is not always available.
        </para>
        <para>
            For this reason, the Zend_Http_Client_Adapter_Test adapter is provided.
            You can write your application to use Zend_Http_Client, and just for 
            testing purposes, for example in your unit testing suite, you can replace
            the default adapter with a Test adapter, allowing you to run tests 
            without actually performing server connections.
        </para>
        <para>
            The Zend_Http_Client_Adapter_Test adapter provides an additional 
            method, setResponse() method. This method takes one parameter,
            which represents an HTTP response as either text or a Zend_Http_Response
            object. Once set, your Test adapter will always return this response,
            without even performing an actual HTTP request.         
        </para>
        <example>
            <title>Testing Your Code Without Accessing The Network</title>
            <programlisting role="php">
<![CDATA[<?php
    // Instantiate a new adapter and client
    $adapter = new Zend_Http_Client_Adapter_Test();
    $client = Zend_Http_Client('http://www.example.com', array(
        'adapter' => $adapter
    ));
    
    // Set the expected response
    $adapter->setResponse(
        "HTTP/1.1 200 OK"        . "\r\n" .
        "Content-type: text/xml" . "\r\n" .
                                   "\r\n" . 
        '<?xml version="1.0" encoding="UTF-8"?>' . 
        '<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"' . 
	    '     xmlns:wfw="http://wellformedweb.org/CommentAPI/"' . 
	    '     xmlns:dc="http://purl.org/dc/elements/1.1/">' . 
        '  <channel>' . 
        '    <title>Premature Optimization</title>' . 
        // and so on...
        '</rss>');
    
    $response = $client->request('GET');
    // .. continue parsing $response..
?>]]></programlisting>
        </example>
        <para>
            The above example shows how you can preset your HTTP client to 
            return the response you need. Then, you can continue testing your
            own code, without being dependent on a network connection, the server's
            response, etc. In this case, the test would continue to check how 
            the application parses the XML in the response body.
        </para>
    </sect2>
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->