<sect1 id="zend.controller.providedsubclasses">
    <title>Provided Subclasses</title>

    <sect2 id="zend.controller.providedsubclasses.introduction">
        <title>Einführung</title>

        <para>
            Das Zend Framework stellt verschiedene Alternativen zu den bereit gestellten 
            Standardklassen zur Verfügung. Dies beinhaltet altive Request Objekte, Router und 
            Response Objekte.
        </para>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.request.http">
        <title>Zend_Controller_Request_Http</title>

        <sect3 id="zend.controller.providedsubclasses.request.http.introduction">
            <title>Einführung</title>

            <para>
                <code>Zend_Controller_Request_Http</code> stellt ein Request Objekt für die 
                Verwendung in einer HTTP Umgebung bereit. Zusätzlich zur Erweiterung von 
                <code>Zend_Controller_Request_Abstract</code> ist es ein Proxy für ein 
                <code>Zend_Http_Request</code> Objekt. <code>Zend_Controller_Request_Http</code>
                ist die Standard Request Klasse, die von <code>Zend_Controller_Dispatcher</code>
                verwendet wird.
            </para>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.request.http.dataaccess">
            <title>Auf Request Daten zugreifen</title>

            <para>
                <code>Zend_Controller_Request_Http</code> kapselt den Zugriff auf relevante Werte
                wie der Schlüssel und Wert für Controller und Action Variablen des Routers und alle
                zusätzlichen Parameter, die aus der URI ermittelt wurden. Durch den Proxy zu 
                <code>Zend_Http_Request</code> erlaubt es zusätzlich den Zugriff auf superglobale 
                Werte als öffentliche Eigenschaften und verwaltet die aktuelle Basis URL und 
                Request URI. Superglobale Werte können in einem Request Objekt nicht gesetzt werden,
                stattdessen verwendet man die setParam/getParam Methoden um Benutzerparameter zu
                setzen oder zu erhalten.
            </para>

            <note>
                <title>Superglobale Daten</title>
                <para>
                    Beim Zugriff auf superglobale Daten über die öffentlichen Eigenschaften von 
                    <code>Zend_Controller_Request_Http</code> ist es notwendig, darauf zu achten, 
                    dass der Eigenschaftsname (der superglobale Arrayschlüssel) einem superglobalen
                    Wert in einer bestimmten Reihenfolge entspricht: 1. GET, 2. POST, 3. COOKIE, 
                    4. SERVER, 5. ENV.
                </para>
            </note>

            <para>
                Auf spezifische superglobale Werte kann alternativ über eine öffentliche Methode 
                zugegriffen werden. Zum Beispiel kann auf den unverarbeitete Wert von 
                <code>$_POST['user']</code> durch Aufruf der <code>getPost('user')</code> Methode 
                des Request Objekts zugegriffen werden. 
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.request.http.baseurl">
            <title>Basis Url und Unterverzeichnisse</title>

            <para>
                <code>Zend_Controller_Request_Http</code> erlaubt durch den Proxy von 
                <code>Zend_Http_Request</code>, daß Zend_Controller_RewriteBase in einem 
                Unterverzeichnis verwendet werden kann. Zend_Http_Request versucht die Basis URL
                automatisch zu erkennen und entsprechend zu setzen.
            </para>

            <para>
                Wenn man zum Beispiel seine <code>index.php</code> in einem Webserverunterverzeichnis 
                mit Namen <code>/projects/myapp/index.php</code> verwendet, sollte die Basis URL
                (die Rewrite Basis) auf <code>/projects/myapp</code> gesetzt werden. Dieser String
                wird dann vom Anfang des Pfades entfernt, bevor irgend welche Routingtreffer 
                ermittelt werden. Dies befreit einem davon, es an den Anfang jeder Route setzen zu 
                müssen. Eine Route <code>'user/:username'</code> passt auf URIs wie 
                <code>http://localhost/projects/myapp/user/martel</code> und
                <code>http://example.com/user/martel</code>.
            </para>

            <note>
                <title>URL Erkennung beachtet Groß- und Kleinschreibung</title>
                <para>
                    Die automatische Erkennung der Basis URL beachtet die Groß- und Kleinschreibung,
                    weshalb man sicherstellen sollte, dass die URL einem Unterverzeichnis im 
                    Dateisystem entspricht (sogar auf einem Windows Rechner). Andernfalls wird auf 
                    die noRoute aktion umgeleitet.
                </para>
            </note>

            <para>
                Sollte die Basis URL falsch erkannt werden, kann man diese auch mit einem eigenen
                Pfad mit Hilfe der <code>setBaseUrl()</code> Methode der 
                <code>Zend_Http_Request</code> Klasse, der <code>Zend_Controller_Request_Http</code>
                Klasse oder der <code>Zend_Controller_Front</code> Klasse überschreiben. Die 
                einfachste Methode ist die von <code>Zend_Controller_Front</code>, welche es an
                das Request Object weiter leitet. Beispiel, um eine eigene Basis URL zu setzen:
            </para>

            <programlisting role="php"><![CDATA[
/** 
 * Dispatch Request with custom base URL with Zend_Controller_Front.
 */
$router     = new Zend_Controller_RewriteRouter();
$controller = Zend_Controller_Front::getInstance();
$controller->setControllerDirectory('./application/controllers')
           ->setRouter($router)
           ->setBaseUrl('/projects/myapp'); // set the base url!
$response   = $controller->dispatch();]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.rewriterouter">
        <title>Zend_Controller_RewriteRouter</title>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.introduction">
            <title>Einführung</title>
        	<para>
        	    <code>Zend_Controller_RewriteRouter</code> ist eine neue Version des Framework 
        	    Routers. Routing ist der Prozess der Übernahme und Zerteilung einer URI, um zu 
        	    ermitteln, welcher Controller und welche Aktion des Controllers die Anfrage 
        	    erhalten soll. Die Definition des Controllers, der Aktion sowie weiterer Parameter 
        	    wird in einem Objekt mit Namen <code>Zend_Controller_Dispatcher_Token</code> 
        	    gekapselt, das dann vom <code>Zend_Controller_Dispatcher</code> verarbeitet wird. 
        	    Das Routing geschieht nur einmal: wenn zu Beginn die Anfrage erhalten wird und 
        	    bevor der erste Controller aufgerufen wird. 
        	</para>
        	<para>
        	    <code>Zend_Controller_RewriteRouter</code> wurde entwickelt, um mit reinen PHP 
        	    Strukturen eine mod_rewrite ähnliche Funktionalität zu erlauben. Es richtet sich 
        	    sehr frei nach dem Ruby on Rails Routing und benötigt kein tieferes Wissen über 
        	    URL Weiterleitung des Webservers. Es wurde entwickelt, um mit einer einzigen 
        	    mod_rewrite Regel zu arbeiten. 
        	</para>

            <programlisting role="php"><![CDATA[
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php]]></programlisting>

            <para>
            or:
            </para>

            <programlisting role="php"><![CDATA[
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 ]]></programlisting>
            
            <para>
                The RewriteRouter can also be used with the IIS webserver
                if <ulink url="http://www.isapirewrite.com">Isapi_Rewrite</ulink>
                has been installed as an Isapi extension with the following rewrite rule:
            </para>

            <programlisting role="php"><![CDATA[
RewriteRule ^[\w/\%]*(?:\.(?!(?:js|ico|gif|jpg|png|css)$)[\w\%]*$)? /index.php [I]]]></programlisting>

            <note>
                <title>IIS Isapi_Rewrite</title>
                <para>
                    When using IIS, <code>$_SERVER['REQUEST_URI']</code>
                    will either not exist, or be set as an empty string. In
                    this case, <code>Zend_Http_Request</code> will
                    attempt to use the <code>$_SERVER['HTTP_X_REWRITE_URL']</code>
                    value set by the Isapi_Rewrite extension.
                </para>
            </note>

            <para>If using Lighttpd, the following rewrite rule is valid:</para>

            <programlisting role="php"><![CDATA[
url.rewrite-once = ( ".*\.(js|ico|gif|jpg|png|css)$" => "$0", "" => "/index.php")]]></programlisting>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.usage">
            <title>Einen Router verwenden</title>

            <para>
        	    Um den RewriteRouter richtig zu verwenden, mußt du ihn instanziieren, einige 
        	    benutzerdefinierte Routen hinzufügen und in den Controller einbinden. Der folgende 
        	    Code veranschaulicht die Vorgehensweise:
            </para>

            <programlisting role="php"><![CDATA[
/* Erstelle einen Router */

$router = new Zend_Controller_RewriteRouter();
$router->addRoute(
	'user',
	new Zend_Controller_Router_Route('user/:username', array('controller' => 'user', 'action' => 'info'))
);

/* binde ihn in den Controller ein */

$ctrl = Zend_Controller_Front::getInstance();
$ctrl->setRouter($router);]]></programlisting>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.basic">
            <title>Einfache Routen</title>

            <para>
                Das Herz des RewriteRouter ist die Definition der benutzerdefinierten Routen. 
                Routen werden durch Aufruf der <code>addRoute</code> Methode des RewriteRouter 
                und der Übergabe einer neuen Instanz von <code>Zend_Controller_Router_Route</code>
                erstellt:
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute('user', new Zend_Controller_Router_Route('user/:username'));]]></programlisting>

            <para>
                Der erste Parameter ist der Name der Route. Zum derzeitigen Zeitpunkt ist er 
                redundant aber wird in Zukunft in einem URL View Helper verwendet, um eine einfache 
                Erstellung von URLs in deinen Views zu ermöglichen. Wenn du die vorher 
                konfigurierte, benannte Route verwenden möchtest, kannst du sie mit den 
                <code>getRoute</code> Methode des RewriteRouter  erhalten. Der zweite Parameter ist 
                eine Instanz von <code>Zend_Controller_Router_Route</code>.
            </para>

            <para>
                The erste Parameter für den <code>Zend_Controller_Router_Route</code> Konstruktur 
                ist eine Route, die auf eine URL passt - zum Beispiel passt die obige Route 
                auf <code>http://example.com/user/martel</code>. Der Doppelpunkt in einer Route 
	            markiert eine URL Variable, die durch die 
	            <code>Zend_Controller_Action::_getParam</code> Methode zugänglich ist. In unserem 
	            Beispiel wird der mit 'username' benannte Parameter auf den Wert 'martel' gesetzt. 
            </para>

        	<note>
        	    <title>Reihenfolge der Definitionen</title>
        	    <para>
            	    Routen werden in umgekehrter Reihenfolge abgeglichen, so dass man sicherstellen 
            	    muss, dass die allgemeinste Route als erstes definiert ist.
        	    </para>
        	</note>
        
        	<note>
        	    <title>Erlaubte Zeichen</title>
        	    <para>
            	    Fürs Erste erlaubt die aktuelle Implementation die Verwendung jedes Zeichens 
            	    für den  Variablenbezeichner außer den Schrägstrich (/), es wird aber sehr 
            	    empfohlen, dass du nur  Zeichen verwendest, die für PHP Variablen verwendet 
            	    werden dürfen. In Zukunft wird die Implementation vermutlich angepasst und dies 
            	    könnte Fehler in deinen Code einführen.
        	    </para>
        	</note>
        
        	<para>
        	    Es gibt zwei besondere Variablen, die in deinen Routen verwendet werden können - 
        	    'controller' und 'action'. Diese besonderen Variablen werden verwendet, um einen 
        	    gewählten  Controller und/oder eine Aktion in der URL zu finden. Die 'action' 
        	    Variable muß immer  entweder in der Route oder als Standardparameter definiert 
        	    sein. Die 'controller' Variable wird standardmäßig auf IndexController verweisen, 
        	    wenn sie nicht definiert wurde.
        	</para>
            <note>
                <title>Spezielle Variablen</title>
                <para>
                    Die Namen dieser speziellen Variablen können unterschiedlich sein, wenn man 
                    die Standardwerte in <code>Zend_Controller_Request_Http</code> mit Hilfe der 
                    setControllerKey und setActionKey Methoden verändert.
                </para>
            </note>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'user', new Zend_Controller_Router_Route(':controller/:action')
);]]></programlisting>

        	<para>
        	    Wenn du deinen Browser mit dieser Route auf <code>http://example.com/news/latest</code> 
        	    richtest, wird der <code>Zend_Controller_Dispatcher</code> die Aktion latestAction 
        	    deines Controllers NewsController ausführen.
        	</para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.variable-defaults">
            <title>Vorgegebene Variablenwerte</title>

            <para>
        	    Jede Variable in der Route kann einen vorgegebenen Wert haben. Um diesen 
        	    vorzugeben, mußt du einen dritten Parameter zur <code>addRoute</code> Methode 
        	    hinzufügen. Dieser dritte Parameter ist ein Array mit den Variablennamen als 
        	    Schlüssel und den vorgegebenen Werten als Werten.
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive', new Zend_Controller_Router_Route('archive/:year', array('year' => 2006))
);]]></programlisting>

        	<para>
        	    Was nicht sofort erkennbar sein mag, ist, dass die obige Route auf URLs wie 
        		<code>http://example.com/archive/2005</code> und 
        		<code>http://example.com/archive</code> passt. Im letzteren Fall hat die Variable 
        		'year' den Wert 2006.
        	</para>
        
        	<para>
        	    Im obigen Beispiel haben wir keinen Controller angegeben, so dass immer auf die 
        	    noRoute Aktion des IndexController verwiesen wird. Damit es anwendbar ist, musst du 
        	    einen gültigen Controller und eine gültige Aktion als Standardwerte festlegen:
        	</para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' => 2006, 'controller' => 'archive', 'action' => 'show')
);]]></programlisting>

            <para>
				This route will then result in dispatching to showAction of ArchiveController.
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.variable-requirements">
            <title>Variable requirements</title>

            <para>
                Du kannst einen dritten Parameter hinzufügen, in dem Anforderungen an die Variablen 
        	    angegeben werden können. Diese werden als reguläre Ausdrücke definiert:
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' => 2006), array('year' => '\d+'))
);]]></programlisting>

            <note>
        	    <title>Routing Verhalten</title>
        	    <para>
        	        Im Gegensatz zu Ruby on Rails wird <code>Zend_Controller_RewriteRouter</code> 
        	        für eine Route Standardwerte verwenden, wenn die Anforderungen an die Variablen 
        	        im vierten Parameter nicht erfüllt werden. Also passt die URL 
        	        <code>http://example.com/archive/test</code> auf die obige Route und setzt den 
        	        Parameter 'year' auf 2006. Diese Funktionalität kann sich in Zukunft ändern, da 
        	        sie im Moment beim Schreiben dieser Dokumentation noch diskutiert wird.
        	    </para>
            </note>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.rewritebase">
            <title>Basis URL und Unterverzeichnisse</title>

            <para>
                Im Gegensatz zum ursprünglichen Route kann RewriteRouter auch in 
                Unterverzeichnissen verwendet werden. Die Methode setRewriteBase() des 
                ursprünglichen RewriteRouter existiert nicht mehr. Stattdessen wird die Basis URL
                automatisch durch Zend_Controller_Request_Http ermittelt (welches 
                Zend_Http_Request verwendet).
            </para>

            <para>
                Sollte die Basis URL falsch erkannt werden, kannst du sie mit deinem eigenen Pfad 
                mit Hilfe von Zend_Http_Request durch den Aufruf der setBaseUrl() Methode setzen 
                (siehe <xref linkend="zend.controller.providedsubclasses.request.http.baseurl" />).
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.default-routes">
            <title>Standardrouten</title>

            <para>
                <code>Zend_Controller_RewriteRouter</code> hat eine vordefinierte Standardroute, um 
                Kompatibilität mit der ersten Version des Routers zu gewährleisten. Sie
        	    passt auf URIs in Form von <code>'controller/action'</code> and erkennt außerdem 
        	    jeden zusätzlichen Parameter, der an die URI angehängt wird. Sie ist wie folgt
        	    konfiguiert:
            </para>

            <programlisting role="php"><![CDATA[
// Route for Router v1 compatibility
$compat = new Zend_Controller_Router_Route(':controller/:action/*', array('controller' => 'index', 'action' => 'index'));
$this->addRoute('default', $compat);]]></programlisting>

            <note>
                <title>Matching URIs</title>
                <para>
                    Zend_Controller_RewriteRouter wurde für Rückwärtskompatibilität konfiguriert. 
                    Es passt automatisch auf <code>controller/action</code> URIs mit zusätzlichen
                    Parameter. Die zusätzlichen Parameter benötigen keine weiteren Routen, solange
                    sie keine vorgegebenen Variablenwerte oder Variablenanforderungen benötigen.
                    Auf diese zusätzlichen Parameter kann über die Zend_Controller_Action::_getParam()
                    Methode zugegriffen werden.
                </para>
            </note>

        </sect3>    
    
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.response.http">
        <title>Zend_Controller_Response_Http</title>

        <para>
            <code>Zend_Controller_Response_Http</code> ist ein Response Objekt, das für die 
            Verwendung in einer HTTP Umgebung geeignet ist. Es enthält Methoden für das Setzen,
            Erhalten und Entfernen von Headern und die <code>__toString()</code> Methode sendet
            alle Header auf einmal bevor die Reponse Inhalte zurückgegeben werden.
        </para>

        <para>
            <code>setHeader()</code> nimmt zwei Argumente entgegen, einen Header Typ und den 
            Header Wert. Ein dritter, optionaler Parameter (wenn übergeben und true) erzwingt das 
            Überschreiben des vorhandenen Headers gleichen Typs mit dem neuen Header.
        </para>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.response.cli">
        <title>Zend_Controller_Response_Cli</title>

        <para>
            <code>Zend_Controller_Response_Cli</code> is ein Response Object, das für die
            Verwendung in einer CLI Umgebung geeignet ist. Es hat keine Methoden für die Behandlung
            von Headern und gibt nur alle Inhalte zurück, wenn <code>__toString()</code> 
            aufgerufen wird.
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
