<sect1 id="zend.gdata.gapps">
    <title>Google Apps Provisionierung verwenden</title>
    
    <para>
        Google Apps ist ein Service der es Domain Administratoren erlaubt Ihren Benutzern einen gemanagten
        Zugriff auf Google Services wie Mail, Kalender und Dokumente &amp; Tabellenkalkulationen zu bieten.
        Die Provisionierungs API bietet ein programmmäßiges Interface um dieses Service zu konfigurieren.
        Im speziellen erlaubt es diese API den Administratoren Benutzerzugänge, Nicknamen und Email Listen
        zu erstellen, zu empfangen, zu verändern und zu löschen.
    </para>
    
    <para>
        Diese Bibliothek implementiert die Version 2.0 der Provisionierungs API. Zugriff zum eigenen Konto über
        die Provisionierungs API muß manuell für jede Domain aktiviert werden die das Google Apps Kontrollpanel
        verwendet. Nur bestimmte Kontotpen sind fähig dieses Feature einzuschalten.
    </para>
    
    <para>
        Für weitere Information zur Google Apps Provisionierungs API, inklusive Anleitungen für das einschalten
        des API Zugriffs, kann in die
        <ulink url="http://code.google.com/apis/calendar/overview.html">Provisionierungs API V2.0 Referenz</ulink>
        gesehen werden.
    </para>
    
    <note>
        <title>Authentifizierung</title>
        <para>
            Die Provisionierungs API unterstützt keine Authentifizierung über AuthSub und anonymer Zugriff ist
            nicht gestattet. Alle HTTP Verbindungen müssen mit Hilfe der ClientAuth Authentifizierung
            authentifiziert werden.
        </para>
    </note>
    
    <sect2 id="zend.gdata.gapps.domain">
        <title>Die aktuelle Domain setzen</title>
        
        <para>
            Um die Provisionierungs API zu verwenden muß die Domain, die administriert werden soll, in allen
            Anfrage URIs spezifiziert werden. Um die Entwicklung zu vereinfachen, wird diese Information sowohl
            im Gapps Service und den Abfrageklassen gespeichert um Sie zu verwenden wenn Abfragen erstellt werden.
        </para>
        
        <sect3 id="zend.gdata.gapps.domain.service">
            <title>Setzen der Domain für die Serviceklasse</title>
            
            <para>
                Um die Domain für die von der Serviceklasse durchgeführten Anfragen zu setzen kann entweder
                <code>setDomain()</code> aufgerufen oder die Domain bei der Instanzierung der Serviceklasse
                spezifiziert werden. Zum Beispiel:
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$domain = "example.com";
$gdata = new Zend_Gdata_Gapps($client, $domain);
?>]]></programlisting>
        
        </sect3>
        
        <sect3 id="zend.gdata.gapps.domain.query">
            <title>Die Domain für die Abfrageklasse setzen</title>
            
            <para>
                Das Setzen der Domain für Anfrage die durch die Abfrageklasse durchgeführt werden ist ähnlich dem
                setzen für die Serviceklasse-entweder wird <code>setDomain()</code> aufgerufen, oder die Domain
                wird bei der Erstellung der Abfrage angegeben. Zum Beispiel:
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$domain = "example.com";
$query = new Zend_Gdata_Gapps_UserQuery($domain, $arg);
?>]]></programlisting>
            
            <para>
                Wenn eine Serviceklassen Factorymethode verwendet wird um eine Abfrage zu erstellen, setzt
                die Serviceklasse die Domain der Abfrage automatisch so das Sie ihrer eigenen Domain entspricht.
                Als Ergebnis ist es nicht notwendig die Domain als Teil der Konstruktorargumente zu spezifizieren.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$domain = "example.com";
$gdata = new Zend_Gdata_Gapps($client, $domain);
$query = $gdata->newUserQuery($arg);
?>]]></programlisting>
            
        </sect3>
        
    </sect2>
    
    <sect2 id="zend.gdata.gapps.users">
        <title>Interaktion mit Benutzern</title>
        
        <para>
            Jeder Benutzerzugang zu einer Google Apps gehosteten Domain wird als Instanz von
            Zend_Gdata_Gapps_UserEntry repräsentiert. Diese Klasse bietet Zugriff zu allen Zugangseigenschaften
            inklusive Name, Benutzername, Passwort, Zugriffsrehte und aktuellen Quoten.
        </para>
        
        <sect3 id="zend.gdata.gapps.users.creating">
            <title>Erstellen eines Benutzerzugangs</title>
            
            <para>
                Benutzerzugänge können durch den Aufruf der einfachen <code>createUser()</code> Methode erstellt
                werden:
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$gdata->createUser('foo', 'Random', 'User', '••••••••');
?>]]></programlisting>
                        
            <para>
                Benutzer können durch das instanzieren eines  UserEntry erstellt werden, indem ein Benutzername,
                ein Name, ein Familienname und ein Passwort angegeben werden und anschließend
                <code>insertUser()</code> am Serviceobjekt aufgerufen wird um den Eintrag zum Server zu laden.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$user = $gdata->newUserEntry();
$user->login = $gdata->newLogin();
$user->login->username = 'foo';
$user->login->password = '••••••••';
$user->name = $gdata->newName();
$user->name->givenName = 'Irgendwer';
$user->name->familyName = 'Benutzer';
$user = $gdata->insertUser($user);
?>]]></programlisting>
            
            <para>
                Das Passwort den Benutzers sollte normalerweise als Klartext angegeben werden. Operional kann
                das Passwort als SHA-1 Schlüssel angegeben werden wenn <code>login->passwordHashFunction</code>
                auf 'SHA-1' gesetzt ist.
            </para>
            
        </sect3>
        
        <sect3 id="zend.gdata.gapps.users.retrieving">
            <title>Einen Benutzerzugang erhalten</title>
            
            <para>
                Individuelle Benutzerzugänge kann man erhalten indem die einfache <code>retrieveUser()</code>
                Methode aufgerufen wird. Wenn der Benutzer nicht gefunden wird, wird <code>null</code>
                zurückgegeben.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$user = $gdata->retrieveUser('foo');

echo 'Benutzername: ' . $user->login->userName . "\n";
echo 'Name: ' . $user->login->givenName . "\n";
echo 'Familienname: ' . $user->login->familyName . "\n";
echo 'Unterbrochen: ' . ($user->login->suspended ? 'Ja' : 'Nein') . "\n";
echo 'Administrator: ' . ($user->login->admin ? 'Ja' : 'Nein') . "\n"
echo 'Muss das Passwort ändern: ' . ($user->login->changePasswordAtNextLogin ? 'Ja' : 'Nein') . "\n";
echo 'Hat den Regeln zugestimmt: ' . ($user->login->agreedToTerms ? 'Ja' : 'Nein') . "\n";
?>]]></programlisting>
            
            <para>
                Benutzer kann man auch erhalten indem eine Instanz von Zend_Gdata_Gapps_UserQuery erstellt wird,
                und dessen username Eigenschaft dem Benutzernamen des Benutzers entspricht den man erhalten will
                und <code>getUserEntry()</code> auf einem Serviceobjekt mit dieser Abfrage aufruft.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$query = $gdata->newUserQuery('foo');
$user = $gdata->getUserEntry($query);

echo 'Benutzername: ' . $user->login->userName . "\n";
echo 'Name: ' . $user->login->givenName . "\n";
echo 'Familien Name: ' . $user->login->familyName . "\n";
echo 'Unterbrochen: ' . ($user->login->suspended ? 'Ja' : 'Nein') . "\n";
echo 'Administrator: ' . ($user->login->admin ? 'Ja' : 'Nein') . "\n"
echo 'Muss das Passwort ändern: ' . ($user->login->changePasswordAtNextLogin ? 'Ja' : 'Nein') . "\n";
echo 'Hat den Regeln zugestimmt: ' . ($user->login->agreedToTerms ? 'Ja' : 'Nein') . "\n";
?>]]></programlisting>
            
            <para>
                Wenn der spezifizierte Benutzer nicht gefunden werden kann wird eine ServiceException mit einem
                Fehlercode von Zend_Gdata_Gapps_Error::ENTITY_DOES_NOT_EXIST geworfen. ServiceExceptions werden
                in <xref linkend="zend.gdata.gapps.exceptions" /> behandelt.
            </para>
            
        </sect3>
        
        <sect3 id="zend.gdata.gapps.users.retrievingAll">
            <title>Alle Benutzer in einer Domain erhalten</title>
            
            <para>
                Um alle Benutzer in einer Domäne zu erhalten kann die einfache <code>retrieveAllUsers()</code>
                Methode aufgerufen werden.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->retrieveAllUsers();

foreach ($feed as $user) {
    echo "  * " . $user->login->username . ' (' . $user->name->givenName .
        ' ' . $user->name->familyName . ")\n";
}
?>]]></programlisting>
            
            <para>
                Das wird ein Zend_Gdata_Gapps_UserFeed Objekt erstellen welches jeden Benutzer dieser Domain
                enthält.
            </para>
            
            <para>
                Alternativ kann <code>getUserFeed()</code> ohne Optionen aufgerufen werden. Es ist zu beachten
                das dieser Feed bei größeren Domains durch den Server in Seiten ausgegeben werden kann. Über
                weitere Informationen der Ausgabe in Seiten siehe
                <xref linkend="zend.gdata.introduction.paging" />.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->getUserFeed();

foreach ($feed as $user) {
    echo "  * " . $user->login->username . ' (' . $user->name->givenName .
        ' ' . $user->name->familyName . ")\n";
}

?>]]></programlisting>
                        
        </sect3>
        
        <sect3 id="zend.gdata.gapps.users.updating">
            <title>Einen Benutzerzugang aktualisieren</title>
            
            <para>
                Der einfachste Weg um einen Benutzerzugang zu aktualisieren ist es den Benutzer wie in der
                vorherigen Sektion beschrieben zu empfangen, jegliche gewünschte Änderungen durchzuführen und
                anschließend <code>save()</code> auf diesem Benutzer aufzurufen. Jede gemachte Änderung wird
                an den Server weitergegeben.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$user = $gdata->retrieveUser('foo');
$user->name->givenName = 'Foo';
$user->name->familyName = 'Bar';
$user = $user->save();
?>]]></programlisting>
            
            <sect4 id="zend.gdata.gapps.users.updating.resettingPassword">
                <title>Ein Benutzerpasswort resetieren</title>
                
                <para>
                    Ein Benutzerpasswort kann zu einem neuen Wert resetiert werden indem die
                    <code>login->password</code> Eigenschaft aktualisiert wird.
                </para>
                
                <programlisting role="php"><![CDATA[<?php
$user = $gdata->retrieveUser('foo');
$user->login->password = '••••••••';
$user = $user->save();
?>]]></programlisting>
                
                <para>
                    Es ist zu beachten das es nicht möglich ist ein Passwort auf diesem Weg wiederherzustellen da
                    gespeicherte Passwörter aus Sicherheitsgründern nicht über die Provisionierungs API
                    verfügbar gemacht werden. 
                </para>
                
            </sect4>
            
            <sect4 id="zend.gdata.gapps.users.updating.forcingPasswordChange">
                <title>Einen Benutzer zwingen sein Passwort zu ändern</title>

                <para>
                    Ein Benutzer kann dazu gezwungen werden sein Passwort bei seinem nächsten Login zu ändern,
                    indem die <code>login->changePasswordAtNextLogin</code> Eigenschaft auf <code>true</code>
                    gesetzt wird.
                </para>

                <programlisting role="php"><![CDATA[<?php
$user = $gdata->retrieveUser('foo');
$user->login->changePasswordAtNextLogin = true;
$user = $user->save();
?>]]></programlisting>

                <para>
                    Genauso kann das rückgängig gemacht werden indem die
                    <code>login->changePasswordAtNextLogin</code> Eigenschaft auf <code>false</code> gesetzt wird.
                </para>

            </sect4>
            
            <sect4 id="zend.gdata.gapps.users.updating.suspendingAccount">
                <title>Einen Benutzerzugang unterbrechen</title>

                <para>
                    Benutzer können daran gehindert werden sich anzumelden ohne das Ihr Benutzerzugang
                    gelöscht wird indem Ihr Benutzerzugang <emphasis>unterbrochen</emphasis> wird. Zugänge
                    können unterbrochen oder wiederhergestellt werden indem die einfachen
                    <code>suspendUser()</code> und <code>restoreUser()</code> Methoden verwendet werden:
                </para>

                <programlisting role="php"><![CDATA[<?php
$gdata->suspendUser('foo');
$gdata->restoreUser('foo');
?>]]></programlisting>

                <para>
                    Alternativ kann die Eigenschaft <code>login->suspended</code> des Benutzerzugangs auf
                    <code>true</code> gesetzt werden.
                </para>

                <programlisting role="php"><![CDATA[<?php
$user = $gdata->retrieveUser('foo');
$user->login->suspended = true;
$user = $user->save();
?>]]></programlisting>

                <para>
                    Um den Benutzerzugang wiederherzustellen muß die <code>login->suspended</code> Eigenschaft
                    auf <code>false</code> gesetzt werden.
                </para>

            </sect4>

            <sect4 id="zend.gdata.gapps.users.updating.grantingAdminRights">
                <title>Administrative Rechte vergeben</title>

                <para>
                    Benutzern kann die Möglichkeit gegeben werden die Domain zu verwalten durch das setzen
                    Ihrer <code>login->admin</code> Eigenschaft auf <code>true</code>.
                </para>

                <programlisting role="php"><![CDATA[<?php
$user = $gdata->retrieveUser('foo');
$user->login->admin = true;
$user = $user->save();
?>]]></programlisting>

                <para>
                    Und wie erwartet, entfernt das Setzen der Eigenschaft <code>login->admin</code>, des
                    Benutzers auf <code>false</code>, dessen administrative Rechte.
                </para>

            </sect4>
            
        </sect3>
        
        <sect3 id="zend.gdata.gapps.users.deleting">
            <title>Löschen eines Benutzerzugangs</title>
            
            <para>
                Einen Benutzerzugang zu löschen zu dem man bereits ein UserEntry hat, ist so einfach wie der
                Aufruf von <code>delete()</code> auf diesem Eintrag.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$user = $gdata->retrieveUser('foo');
$user->delete();
?>]]></programlisting>
            
            <para>
                Wenn man keinen Zugriff auf ein UserEntry Objekt für einen Zugang hat, kann die einfache
                <code>deleteUser()</code> Methode verwendet werden.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$gdata->deleteUser('foo');
?>]]></programlisting>
            
        </sect3>
        
    </sect2>
    
    <sect2 id="zend.gdata.gapps.nicknames">
        <title>Mit Spitznamen interagieren</title>
        
        <para>
            Spitznamen arbeiten als Email Aliase für bestehende Benutzer. Jeder Spitzname enthält genau zwei
            Schlüsseleigenschaften: Seinen Namen und seinen Eigentümer. Jede Email die zu einem Spitznamen
            adressiert wurde wird zu dem Benutzer weitergeleitet der diesen Spitznamen besitzt.
        </para>
        
        <para>
            Spitznamen werden repräsentiert als Instanz von Zend_Gdata_Gapps_NicknameEntry.
        </para>
        
        <sect3 id="zend.gdata.gapps.nicknames.creating">
            <title>Erstellen eines Spitznamens</title>
            
            <para>
                Spitznamen können durch den Aufruf der einfachen <code>createNickname()</code> Methode
                erstellt werden:
            </para>

            <programlisting role="php"><![CDATA[<?php
$gdata->createNickname('foo', 'bar');
?>]]></programlisting>

            <para>
                Spitznamen können auch durch das instanzieren eines NichnameEntry erstellt werden, wobei der
                Spitzname mit einem Namen und einem Eigentümer ausgestattet wird, und dann
                <code>insertNickname()</code> auf einem Service Objekt aufgerufen wird, um den Eintrag zu einem
                Server hochzuladen.
            </para>

            <programlisting role="php"><![CDATA[<?php
$nickname = $gdata->newNicknameEntry();
$nickname->login = $gdata->newLogin('foo');
$nickname->nickname = $gdata->newNickname('bar');
$nickname = $gdata->insertNickname($nickname);
?>]]></programlisting>
        
        </sect3>
        
        <sect3 id="zend.gdata.gapps.nicknames.retrieving">
            <title>Einen Spitznamen empfangen</title>
            
            <para>
                Spitznamen können durch den Aufruf der bequemen <code>retrieveNickname()</code> Methode
                empfangen werden. Sie gibt <code>null</code> zurück wenn der Benutzer nicht gefunden wurde.
            </para>

            <programlisting role="php"><![CDATA[<?php
$nickname = $gdata->retrieveNickname('bar');

echo 'Spitzname: ' . $nickname->nickname->name . "\n";
echo 'Eigentümer: ' . $nickname->login->username . "\n";
?>]]></programlisting>

            <para>
                Individuelle Spitznamen können durch Erstellung einer Zend_Gdata_Gapps_NicknameQuery Instanz
                erhalten werden, indem dessen nickname Eigenschaft dem Spitznamen gleichgesetzt wird der
                empfangen werden soll, und  <code>getNicknameEntry()</code> auf einem Server Objekt mit dieser
                Abfrage aufgerufen wird.
            </para>

            <programlisting role="php"><![CDATA[<?php
$query = $gdata->newNicknameQuery('bar');
$nickname = $gdata->getNicknameEntry($query);

echo 'Spitzname: ' . $nickname->nickname->name . "\n";
echo 'Eigentümer: ' . $nickname->login->username . "\n";
?>]]></programlisting>

            <para>
                Genau wie bei den Benutzern wird eine ServiceException geworfen wenn kein entsprechender
                Spitzname gefunden wurde und ein Fehlercode von Zend_Gdata_Gapps_Error::ENTITY_DOES_NOT_EXIST
                zurückgegeben. Auch das wird in <xref linkend="zend.gdata.gapps.exceptions" /> beschrieben.
            </para>

        </sect3>

        <sect3 id="zend.gdata.gapps.nicknames.retrievingUser">
            <title>Alle Spitznamen eines Benutzers erhalten</title>

            <para>
                Um alle Spitznamen zu erhalten die einem angegebenen Benutzer assoziiert sind, kann die
                bequeme <code>retrieveNicknames()</code> Methode aufgerufen werden.
            </para>

            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->retrieveNicknames('foo');

foreach ($feed as $nickname) {
    echo '  * ' . $nickname->nickname->name . "\n";
}
?>]]></programlisting>

            <para>
                Das erzeugt ein Zend_Gdata_Gapps_NicknameFeed Objekt welches jeden mit dem spezifizierten
                Benutzer assoziierten Spitznamen enthält.
            </para>

            <para>
                Alternatively, create a new Zend_Gdata_Gapps_NicknameQuery,
                set its username property to the desired user, and submit the
                query by calling <code>getNicknameFeed()</code> on a service
                object.
            </para>

            <programlisting role="php"><![CDATA[<?php
$query = $gdata->newNicknameQuery();
$query->setUsername('foo');
$feed = $gdata->getNicknameFeed($query);

foreach ($feed as $nickname) {
    echo '  * ' . $nickname->nickname->name . "\n";
}
?>]]></programlisting>

        </sect3>

        <sect3 id="zend.gdata.gapps.nicknames.retrievingAll">
            <title>Retrieving all nicknames in a domain</title>
            <para>
                To retrieve all nicknames in a feed, simply call the
                convenience method <code>retrieveAllNicknames()</code>
            </para>

            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->retrieveAllNicknames();

foreach ($feed as $nickname) {
    echo '  * ' . $nickname->nickname->name . ' => ' . 
        $nickname->login->username . "\n";
}
?>]]></programlisting>

            <para>
                This will create a Zend_Gdata_Gapps_NicknameFeed object which
                holds each nickname on the domain.
            </para>
            
            <para>
                Alternatively, call <code>getNicknameFeed()</code> on a 
                service object with no arguments.
            </para>

            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->getNicknameFeed();

foreach ($feed as $nickname) {
    echo '  * ' . $nickname->nickname->name . ' => ' . 
        $nickname->login->username . "\n";
}
?>]]></programlisting>

        </sect3>

        <sect3 id="zend.gdata.gapps.nicknames.deleting">
            <title>Deleting a nickname</title>

            <para>
                Deleting a nickname to which you already hold a NicknameEntry
                for is a simple as calling <code>delete()</code> on that
                entry.
            </para>

            <programlisting role="php"><![CDATA[<?php
$nickname = $gdata->retrieveNickname('bar');
$nickname->delete();
?>]]></programlisting>

            <para>
                For nicknames which you do not hold a NicknameEntry for, use
                the <code>deleteNickname()</code> convenience method.
            </para>

            <programlisting role="php"><![CDATA[<?php
$gdata->deleteNickname('bar');
?>]]></programlisting>

        </sect3>
            
    </sect2>
        
    <sect2 id="zend.gdata.gapps.emailLists">
        <title>Interacting with email lists</title>
        
        <para>
            Email lists allow several users to retrieve email addressed to a
            single email address. Users do not need to be a
            member of this domain in order to subscribe to an email list
            provided their complete email address (including domain) is used.
        </para>
        
        <para>
            Each email list on a domain is represented as an instance of
            Zend_Gdata_Gapps_EmailListEntry.
        </para>
        
        <sect3 id="zend.gdata.gapps.emailLists.creating">
            <title>Creating an email list</title>

            <para>
                Email lists can be created by calling the
                <code>createEmailList()</code> convenience method:
            </para>

            <programlisting role="php"><![CDATA[<?php
$gdata->createEmailList('friends');
?>]]></programlisting>

            <para>
                Email lists can also be created by instantiating
                EmailListEntry, providing a name for the list, then calling
                <code>insertEmailList()</code> on a service object to upload
                the entry to the server.
            </para>

            <programlisting role="php"><![CDATA[<?php
$list = $gdata->newEmailListEntry();
$list->emailList = $gdata->newEmailList('friends');
$list = $gdata->insertEmailList($list);
?>]]></programlisting>

        </sect3>
        
        <sect3 id="zend.gdata.gapps.emailList.retrieve">
            <title>Retrieving all email lists to which a recipient is
            subscribed</title>

            <para>
                To retrieve all email lists to which a particular recipient is
                subscribed, call the <code>retrieveEmailLists()</code>
                convenience method:
            </para>

            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->retrieveEmailLists('baz@somewhere.com');

foreach ($feed as $list) {
    echo '  * ' . $list->emailList->name . "\n";
}
?>]]></programlisting>

            <para>
                This will create a Zend_Gdata_Gapps_EmailListFeed object which
                holds each email list associated with the specified recipient.
            </para>
            
            <para>
                Alternatively, create a new Zend_Gdata_Gapps_EmailListQuery,
                set its recipient property to the desired email address, and
                submit the query by calling <code>getEmailListFeed()</code> on
                a service object.
            </para>

            <programlisting role="php"><![CDATA[<?php
$query = $gdata->newEmailListQuery();
$query->setRecipient('baz@somewhere.com');
$feed = $gdata->getEmailListFeed($query);

foreach ($feed as $list) {
    echo '  * ' . $list->emailList->name . "\n";
}
?>]]></programlisting>

        </sect3>

        <sect3 id="zend.gdata.gapps.emailLists.retrievingAll">
            <title>Retrieving all email lists in a domain</title>

            <para>
                To retrieve all email lists in a domain, call the convenience
                method <code>retrieveAllEmailLists()</code>.
            </para>

            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->retrieveAllEmailLists();

foreach ($feed as $list) {
    echo '  * ' . $list->emailList->name . "\n";
}
?>]]></programlisting>

            <para>
                This will create a Zend_Gdata_Gapps_EmailListFeed object which
                holds each email list on the domain.
            </para>
            
            <para>
                Alternatively, call <code>getEmailListFeed()</code> on a
                service object with no arguments.
            </para>

            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->getEmailListFeed();

foreach ($feed as $list) {
    echo '  * ' . $list->emailList->name . "\n";
}
?>]]></programlisting>
            
        </sect3>
        
        <sect3 id="zend.gdata.gapps.emailList.deleting">
            <title>Deleting an email list</title>

            <para>
                To delete an email list, call the deleteEmailList()
                convenience method:
            </para>

            <programlisting role="php"><![CDATA[<?php
$gdata->deleteEmailList('friends');
?>]]></programlisting>

        </sect3>
        
    </sect2>
    
    <sect2 id="zend.gdata.gapps.emailListRecipients">
        <title>Interacting with email list recipients</title>
        
        <para>
            Each recipient subscribed to an email list is represented by an
            instance of Zend_Gdata_Gapps_EmailListRecipient. Through this
            class, individual recipients can be added and removed from email
            lists.
        </para>
        
        <sect3 id="zend.gdata.gapps.emailListRecipients.adding">
            <title>Adding a recipient to an email list</title>
            
            <para>
                To add a recipient to an email list, simply call the
                <code>addRecipientToEmailList()</code> convenience method:
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$gdata->addRecipientToEmailList('bar@somewhere.com', 'friends');
?>]]></programlisting>
            
        </sect3>
        
        <sect3 id="zend.gdata.gapps.emailListRecipients.retrieving">
            <title>Retrieving the list of subscribers to an email list</title>

            <para>
                The convenience method <code>retrieveAllRecipients()</code>
                can be used retrieve teh list of subscribers to an email list:
            </para>

            <programlisting role="php"><![CDATA[<?php
$feed = $gdata->retrieveAllRecipients('friends');

foreach ($feed as $recipient) {
    echo '  * ' . $recipient->who->email . "\n";
}
?>]]></programlisting>
            
            <para>
                Alternatively, construct a new EmailListRecipientQuery, set
                its emailListName property to match the desired email list,
                and call <code>getEmailListRecipientFeed()</code> on a service
                object.
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$query = $gdata->newEmailListRecipientQuery();
$query->setEmailListName('friends');
$feed = $gdata->getEmailListRecipientFeed($query);

foreach ($feed as $recipient) {
    echo '  * ' . $recipient->who->email . "\n";
}
?>]]></programlisting>
            
            <para>
                This will create a Zend_Gdata_Gapps_EmailListRecipientFeed
                object which holds each recipient for the selected email list.
            </para>
            
        </sect3>
        
        <sect3 id="zend.gdata.gapps.emailListRecipients.removing">
            <title>Removing a recipient from an email list</title>
            
            <para>
                To remove a recipient from an email list, call the
                <code>removeRecipientFromEmailList()</code> convenience
                method:
            </para>
            
            <programlisting role="php"><![CDATA[<?php
$gdata->removeRecipientFromEmailList('baz@somewhere.com', 'friends');
?>]]></programlisting>
            
        </sect3>
        
    </sect2>
    
    <sect2 id="zend.gdata.gapps.exceptions">
        <title>Handling errors</title>
        
        <para>
            In addition to the standard suite of exceptions thrown by
            Zend_Gdata, requests using the Provisioning API may also throw a
            <code>Zend_Gdata_Gapps_ServiceException</code>. These exceptions
            indicate that a API specific error occurred which prevents the
            request from completing.
        </para>
        
        <para>
            Each ServiceException instance may hold one or more Error objects.
            Each of these objects contains an error code, reason, and
            (optionally) the input which triggered the exception. A complete
            list of known error codes is provided in the Zend Framework API
            documentation under Zend_Gdata_Gapps_Error. Additionally, the
            authoritative error list is available online at <ulink
            url="http://code.google.com/apis/apps/gdata_provisioning_api_v2.0_reference.html#appendix_d">Google
            Apps Provisioning API V2.0 Reference: Appendix D</ulink>.
        </para>
        
        <para>
            While the complete list of errors received is available within
            ServiceException as an array by calling <code>getErrors()</code>,
            often it is convenient to know if one specific error occurred. For
            these cases the presence of an error can be determined by calling
            <code>hasError()</code>.
        </para>
        
        <para>
            The following example demonstrates how to detect if a requested
            resource doesn't exist and handle the fault gracefully:
        </para>
        
        <programlisting role="php"><![CDATA[<?php
function retrieveUser ($username) {
    $query = $gdata->newUserQuery($username);
    try {
        $user = $gdata->getUserEntry($query);
    } catch (Zend_Gdata_Gapps_ServiceException $e) {
        // Set the user to null if not found
        if ($e->hasError(Zend_Gdata_Gapps_Error::ENTITY_DOES_NOT_EXIST)) {
            $user = null;
        } else {
            throw $e;
        }
    }
    return $user;
}
?>]]></programlisting>
        
    </sect2>
    
</sect1>
