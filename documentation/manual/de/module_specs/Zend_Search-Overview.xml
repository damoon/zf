<sect1 id="zend.search.overview">
    <title>Überblick</title>

    <sect2 id="zend.search.introduction">
        <title>Einführung</title>
        <para>
            Zend_Search_Lucene ist eine komplett in PHP 5 geschriebene Textsuchmaschine für viele 
            Zwecke. Da es seinen Index im Dateisystem ablegt und keinen Datenbankserver erfordert, 
            kann es eine Suchfunktion für nahezu jede auf PHP basierende Website bereitstellen. 
            Zend_Search_Lucene unterstützt die folgenden Funktionalitäten:
            
            <itemizedlist>
                <listitem>
                    <para>Klassifizierte Suche - die besten Ergebnisse werden zuerst zurückgegeben</para>
                </listitem>
                <listitem>
                    <para>
                        Viele mächtige Abfragearten: Phrasensuche, Platzhaltersuche, Näherungssuche,
                        Bereichssuche und mehr
                        <footnote>
                           <para>
                               Derzeit werden nur Abfragen für einzelne und mehrere Begriffe sowie für
                               Phrasen unterstützt.
                           </para>
                        </footnote>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Suche anhand eines bestimmten Feldes (z.B. Titel, Autor, Inhalt)
                    </para>
                </listitem>
            </itemizedlist>
        
            Zend_Search_Lucene wurde abgeleitet vom Apache Lucene Projekt. Für weitere Informationen
            über Lucene, besuche <ulink url="http://lucene.apache.org/java/docs/"/>.
        </para>
    </sect2>
    
	<sect2 id="zend.search.index-creation.documents-and-fields">
		<title>Dokumenten- und Feldobjekte</title>
            <para>
                Für die Indizierung verarbeitet Zend_Search_Lucene Dokumente als atomare Einheiten. 
                Ein Dokument wird in benannte Felder unterteilt und diese Felder enthalten Inhalte,
                die durchsucht werden können. 
            </para>
        
            <para>
                Ein Dokument wird durch ein Zend_Search_Lucene_Document Objekt abgebildet und dieses
                Objekt enthält Zend_Search_Lucene_Field Objekte, welche die Felder abbilden.
            </para>
        
            <para>
                Es ist wichtig zu beachten, dass dem Index jegliche Informationen hinzugefügt werden
                können. Anwendungsspezifische Informationen oder Metadaten können in den 
                Dokumentfeldern gespeichert und später bei der Suche aus dem Dokument zurückgeholt 
                werden.
            </para>
        
            <para>
                Es liegt in der Verantwortung deiner Anwendung, den Indexer zu kontrollieren. Das
                bedeutet, dass die Daten aus jeder Quelle indiziert werden können, die von deiner 
                Anwendung aus ansprechbar ist. Zum Beispiel könnten dies das Dateisystem, eine
                Datenbank, ein HTML Formular, usw. sein.
            </para>            
            
            <para>
                Die <code>Zend_Search_Lucene_Field</code> Klasse stellt verschiedene statische
                Methoden zum Erstellen mit unterschiedlichen Charakteristika bereit:
            </para>
        
            <programlisting role="php"><![CDATA[<?php
$doc = new Zend_Search_Lucene_Document();

// Feld wird nicht in Token aufgeteilt, aber indiziert und im Index
// gespeichert. Die gespeichertern Felder können aus dem Index 
// abgerufen werden.
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype', 
                                                 'autogenerated'));

// Feld wird weder in Token aufgeteilt noch indiziert, aber im Index
// gespeichert. 
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created', 
                                                   time()));

// Feld mit einer binären Zeichenkette, die weder in Token aufgeteilt 
// noch indiziert, aber im Index gespeichert wird.
$doc->addField(Zend_Search_Lucene_Field::Binary('icon', 
                                                $iconData));

// Feld wird in Token aufgeteilt und indiziert und im Index gespeichert.
$doc->addField(Zend_Search_Lucene_Field::Text('annotation', 
                                              'Document annotation text'));

// Feld wird in Token aufgeteilt und indiziert, aber nicht im Index 
// gespeichert.
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', 
                                                  'My document content'));

?>]]></programlisting>
        
            <para>
                Du kannst die Felder benennen, wie du möchtest. Standardmäßig wird für die Suche 
                ein Feld mit dem Namen "contents" verwendet. Es ist eine gute Idee, wichtige Daten 
                des Dokuments in einem Feld mit diesem Namen zu platzieren. 
            </para>
	</sect2>
	
	<sect2 id="zend.search.index-creation.understanding-field-types">
		<title>Verstehen der Feldtypen</title>
        <itemizedlist>
            <listitem>
                <para>
                    <code>Keyword</code> (Stichwort) Felder werden gespeichert und indiziert, was 
                    bedeutet, dass sie sowohl durchsucht als auch in Suchergebnissen angezeigt 
                    werden können. Sie werden nicht in einzelne Worte (Tokens) zerteilt. 
                    Datenbankfelder für Aufzählungen lassen sich normalerweise leicht in Keyword 
                    Felder für Zend_Search_Lucene überführen.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnIndexed</code> (unindizierte) Felder sind nicht durchsuchbar, werden 
                    aber bei Suchtreffern zurückgegeben. Datenbank Zeitstempel, Primärschlüssel, 
                    Pfade des Dateisystems und andere externe Identifikatoren sind gute Kandidaten 
                    für UnIndexed Felder.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Binary</code> (binäre) Felder werden nicht in Token aufgeteilt und 
                    indiziert, aber für die Rückgabe bei Suchtreffern gespeichert. Sie können für
                    die Speicherung aller Daten, die als binäre Zeichenkette kodiert sind, 
                    verwendet werden, wie z.B. eine Grafiksymbol.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Text</code> Felder werden gespeichert, indiziert und in Token aufgeteilt.
                    Text Felder sind geeignet für die Speicherung von Informationen wie Themen und
                    Überschriften, die sowohl durchsuchbar sein müssen, als auch in Suchergebnissen
                    zurückgegeben werden müssen.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnStored</code> (nicht gespeicherte) Felder werden in Token aufgeteilt und
                    indiziert, aber nicht im Index gespeichert. Umfangreiche Texte werden am besten
                    durch diesen Feldtyp indiziert. Gespeicherte Daten benötigen einen größeren 
                    Index auf der Festplatte, wenn du also Daten nur durchsuchbar aber nicht wieder
                    ausgegeben haben musst, verwende ein UnStored Feld. UnStored Felder sind 
                    geeignet, wenn ein Zend_Search_Lucene Index in Kombination mit einer relationalen
                    Datenbank verwendet wird. Du kannst große Datenfelder mit UnStored Feldern 
                    für die Suche indizieren und sie aus der relationalen Datenbank durch die 
                    Verwendung eines seperaten Feldes mithilfe eines Identifikatoren zurückholen.
    		   </para>

                <table>
                    <title>Zend_Search_Lucene_Field Typen</title>
                    <tgroup cols="4">
                        <thead>
                            <row>
                                <entry>Feldtyp</entry>
                                <entry>Gespeichert</entry>
                                <entry>Indiziert</entry>
                                <entry>In Token aufgeteilt</entry>
                                <entry>Binär</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Keyword</entry>
                                <entry>Ja</entry>
                                <entry>Ja</entry>
                                <entry>Nein</entry>
                                <entry>Nein</entry>
                            </row>
                            <row>
                                <entry>UnIndexed</entry>
                                <entry>Ja</entry>
                                <entry>Nein</entry>
                                <entry>Nein</entry>
                                <entry>Nein</entry>
                            </row>
                            <row>
                                <entry>Binary</entry>
                                <entry>Ja</entry>
                                <entry>Nein</entry>
                                <entry>Nein</entry>
                                <entry>Ja</entry>
                            </row>
                            <row>
                                <entry>Text</entry>
                                <entry>Ja</entry>
                                <entry>Ja</entry>
                                <entry>Ja</entry>
                                <entry>Nein</entry>
                            </row>
                            <row>
                                <entry>UnStored</entry>
                                <entry>Nein</entry>
                                <entry>Ja</entry>
                                <entry>Ja</entry>
                                <entry>Nein</entry>
                            </row>                        
                        </tbody>
                    </tgroup>
                </table>
    	   </listitem>
	   </itemizedlist>
	</sect2>    
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->
