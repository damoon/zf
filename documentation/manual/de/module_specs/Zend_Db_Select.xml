<sect1 id="zend.db.select">

    <title>Zend_Db_Select</title>

    <sect2 id="zend.db.select.introduction">

        <title>Einführung</title>

        <para>
            Zend_Db_Select ist ein Werkzeug, dass dich beim Erstellen von datenbankunabhängigen SQL 
            SELECT Abfragen unterstützt. Offensichtlich kann dies nicht perfekt sein, dennoch reicht
            die Unterstützung soweit, um deine Abfragen zwischen Datenbanken portierbar zu machen. 
            Zusätzlich hilft es dir dabei deine Abfragen, gegen Attacken per SQL Injection, 
            resistent zu machen.
        </para>

        <para>
            Der einfachste Weg, um eine Instanz von Zend_Db_Select zu erstellen, ist die 
            Verwendung der Zend_Db_Adapter::select() Methode.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
require_once 'Zend/Db.php';

$params = array (
    'host'     => '127.0.0.1',
    'username' => 'malory',
    'password' => '******',
    'dbname'   => 'camelot'
);

$db = Zend_Db::factory('PDO_MYSQL', $params);

$select = $db->select();
// $select ist nun ein Zend_Db_Select Objekt, das nur für die Verwendung des PDO_MYSQL 
// Adapters konfiguriert wurde.

?>]]></programlisting>

        <para>
            Du kannst deine SELECT Anfrage durch Verwendung des Objektes und seiner Methoden 
            erstellen, und danach einen String generieren, um ihn für Abfragen zurück an den 
            Zend_Db_Adapter zu übergeben.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// SELECT round_table.*
// FROM `round_table` round_table
// WHERE `noble_title` = 'Sir'
// ORDER BY `first_name`
// LIMIT 10 OFFSET 20
//

// Du kannst einen schrittweisen Stil verwenden...
$select->from('round_table');
$select->where('noble_title = ?', 'Sir');
$select->order('first_name');
$select->limit(10,20);

// ...oder einen "fließenden" Stil:
$select->from('round_table')
       ->where('noble_title = ?', 'Sir')
       ->order('first_name')
       ->limit(10,20);

// ungeachtet dessen, hole die Ergebnisse
$sql = $select->__toString();
$result = $db->fetchAll($sql);

// eine zweite Alternative: übergebe das $select Objekt selber;
$result = $db->fetchAll($select);

// eine dritte Alternative: erstelle ein Zend_Db_Statement
// oder PDOStatement direkt aus dem $select Objekt:
$stmt = $select->query();
$result = $stmt->fetchAll();

?>]]></programlisting>

        <para>
            Du kannst auch eingebundene Parameter in deinen Abfragen verwenden statt alles in
            schrittweise Anführungszeichen setzen.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
//
// SELECT round_table.*
// FROM `round_table` round_table
// WHERE noble_title = 'Sir'
// ORDER BY `first_name`
// LIMIT 10 OFFSET 20
//

$select->from('round_table', '*')
       ->where('noble_title = :title')
       ->order('first_name')
       ->limit(10,20);

// ungeachtet dessen, hole die Ergebnisse unter Verwendung von eingebundenen Parametern
$params = array('title' => 'Sir');
$result = $db->fetchAll($select, $params);

?>]]></programlisting>

    </sect2>

    <sect2 id="zend.db.select.fromcols">

        <title>Spalten einer Tabelle</title>

        <para>
            Um Spalten einer bestimmten Tabelle zu selektieren, verwende die from() Methode, unter
            Angabe der Tabelle und der Spalten, die du erhalten möchtest. Du kannst Tabellen- und 
            Spaltenpseudonyme verwenden und du kannst from() so oft wie nötig verwenden. 
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// Erstelle ein $db Objekt unter der Annahme von Mysql als Adapter.
$select = $db->select();

// SELECT some_table.`a`, some_table.`b`, some_table.`c`
// FROM `some_table` some_table

$select->from('some_table', array('a', 'b', 'c'));

// SELECT bar.`col`
// FROM `foo` bar

$select->from(array('foo' => 'bar'), 'col');

?>]]></programlisting>

        <para>
            The second argument to the from() method is a scalar
            to name a single column, or an array to name multiple
            columns.  The scalar or element of the array can be
            a string, which is interpreted as a plain column name,
            and is quoted and prepended with the table alias.
            If you omit the second argument, it defaults to <code>'*'</code>,
            which is not quoted but is prepended with the table alias.
            If you want no columns from this table to be in the result
            set, use an empty <code>array()</code>.
        </para>

        <para>
            Do not specify multiple columns as a single string of
            comma-separated column names.  This syntax used in
            earlier preview releases of Zend_Db is no longer supported.
            Use an array instead.
        </para>

        <para>
            The table alias is applied to every string element of the
            second argument, but if the element is an object of type
            Zend_Db_Expr, its string value is used without quoting
            or prepending with the table alias.
        </para>

        <programlisting role="php"><![CDATA[<?php

$select = $db->select();

// SELECT foo.col AS col1, bar.col AS col2
// FROM foo, bar
$select->from('foo', array(
    new Zend_Db_Expr('foo.col AS col1'),
    new Zend_Db_Expr('CURDATE()')
);
$select->from('bar', new Zend_Db_Expr('bar.col AS col2'));

?>]]></programlisting>

        <para>
            Use an associative array to declare table aliases.
            The key is the table name and the value is the alias.
            If you specify a table as a simple string instead of an associative
            array to declare the alias, Zend_Db_Select generates a table alias.
            By default, the generated table alias is spelled the same as each
            table name, as if you had written a SQL query
            "<code>SELECT foo.* FROM `foo` foo</code>".
            If you add the same table more than once, for example in a
            self-join, Zend_Db_Select declares unique aliases for each table
            instance, like "<code>foo_1</code>", "<code>foo_2</code>", etc.
        </para>

    </sect2>

    <sect2 id="zend.db.select.joincols">

        <title>Spalten von verbundenen Tabellen</title>

        <para>
            Um Spalten von verbundenen Tabellen zu selektieren, verwende die join() Methode. Zuerst
            gib den zu verbindenen Tabellennamen an, dann die Verbundbedingung und zuletzt die 
            Spalten, die du vom Verbund erhalten möchtest. Du kannst join() so oft wie nötig 
            verwenden.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// Erstelle ein $db Objekt unter der Annahme von Mysql als Adapter.
$select = $db->select();

// SELECT foo.*, bar.*
// FROM `foo` foo
// JOIN `bar` bar ON foo.id = bar.id

$select->from('foo');
$select->join('bar', 'foo.id = bar.id');

?>]]></programlisting>

        <para>
            The first argument to the join() method is a table specifier.
            This is the same as the first argument of the from() method,
            in that it can be a string that names a table, or it can be an
            associative array mapping the table name to an alias name.
        </para>

        <para>
            The second argument to the join() method is an expression that
            forms the join condition.  You can use table aliases here, but 
            remember that unless you specified the table alias, Zend_Db_Select
            generates one.  If you omit the join condition, this is
            equivalent to a CROSS JOIN or cartesian product.
        </para>

        <para>
            The third argument to the join() method is a list of columns from
            the joined table to include in the select-list.  This is the same
            as the second argument of the from() method, in that it can be
            a scalar that names a column, or an array of scalars to name
            multiple columns.  Each scalar can be either a string or an object
            of type Zend_Db_Expr.  If you omit the columns argument, the default
            is <code>'*'</code>.  If you want no columns from this table to
            be in the result set, use an empty <code>array()</code>.
        </para>

        <para>
            Do not specify multiple columns as a single string of
            comma-separated column names.  This syntax used in
            earlier preview releases of Zend_Db is no longer supported.
            Use an array instead.
        </para>

        <para>
            The following join types are supported:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <command>INNER JOIN</command> with the
                    <code>join()</code> or <code>joinInner()</code> methods.
                    All RDBMS brands support this join type.
                </para>
            </listitem>
            <listitem>
                <para>
                    <command>LEFT JOIN</command> with the
                    <code>joinLeft()</code> method.
                    All RDBMS brands support this join type.
                </para>
            </listitem>
            <listitem>
                <para>
                    <command>RIGHT JOIN</command> with the
                    <code>joinRight()</code> method.
                    Some RDBMS brands do not support this join type.
                </para>
            </listitem>
            <listitem>
                <para>
                    <command>FULL JOIN</command> with the
                    <code>joinFull()</code> method.
                    Some RDBMS brands do not support this join type.
                </para>
            </listitem>
            <listitem>
                <para>
                    <command>CROSS JOIN</command> with the
                    <code>joinCross()</code> method.
                    There is no parameter for this method to specify 
                    the join condition.
                    Some RDBMS brands do not support this join type.
                </para>
            </listitem>
            <listitem>
                <para>
                    <command>NATURAL JOIN</command> with the
                    <code>joinNatural()</code> method.
                    There is no parameter for this method to specify 
                    the join condition; a natural join assumes an
                    equi-join on columns of the same name in the
                    two tables.
                    Only NATURAL INNER JOIN is supported.
                </para>
            </listitem>
        </itemizedlist>

    </sect2>

    <sect2 id="zend.db.select.where">

        <title>WHERE Bedingungen</title>

        <para>
            Um WHERE Bedingungen hinzuzufügen, verwende die where() Methode. Du kannst entweder 
            einen normalen String oder einen String mit Fragezeichen als Platzhalter und einen 
            zu ersetzenden Wert übergeben (der Wert wird mittels
            Zend_Db_Adapter::quoteInto in Anführungszeichen gesetzt).
        </para>

        <para>
            Mehrfache Aufrufe von where() verbinden die Bedingungen mit einem logischen AND; wenn
            du einen Verbund mit logischem OR benötigst, verwende orWhere().
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// Erstelle ein $db Objekt, dann hole ein SELECT Werkzeug.
$select = $db->select();

// SELECT r.*
// FROM `round_table` r
// WHERE noble_title = 'Sir'
//   AND favorite_color = 'yellow'

$select->from(array('round_table' => 'r'));
$select->where("noble_title = 'Sir'"); // embedded value
$select->where('favorite_color = ?', 'yellow'); // quoted value

// SELECT foo.*
//     FROM `foo` foo
//     WHERE bar = 'baz'
//     OR id IN('1', '2', '3')

$select->from('foo');
$select->where('bar = ?', 'baz');
$select->orWhere('id IN(?)', array(1, 2, 3));

?>]]></programlisting>

        <para>
            Zend_Db_Select does not apply quoting or table aliases to
            columns named in WHERE clauses.  If you combine PHP 
            variables into the string for a WHERE expression, you
            should use the Zend_Db_Adapter quoteIdentifier() method
            to protect against illegal syntax.
        </para>
        <programlisting role="php"><![CDATA[<?php
...
$columnName = 'bar'; // or set by an untrusted source
$whereExpr = $db->quoteIdentifier($columnName) . ' = ?';
$select->where($whereExpr, 'baz');
?>]]></programlisting>

    </sect2>

    <sect2 id="zend.db.select.group">

        <title>GROUP BY Klauseel</title>

        <para>
            Um Zeilen zu gruppieren, verwende die group() Methode so oft du möchtest.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// Erstelle ein $db Objekt, dann hole ein SELECT Werkzeug.
$select = $db->select();

// SELECT COUNT(id)
// FROM `foo` foo
// GROUP BY `bar`, `baz`

$select->from('foo', new Zend_Db_Expr('COUNT(id)'));
$select->group('bar');
$select->group('baz');

// an equivalent group() call:
$select->group(array('bar', 'baz'));

?>]]></programlisting>

        <para>
            Do not specify multiple columns as a single string of
            comma-separated column names.  This syntax used in
            earlier preview releases of Zend_Db is no longer supported.
            Use an array instead.
        </para>

        <para>
            Quoting is applied to every string element of the
            group() argument, but if the element is an object of type
            Zend_Db_Expr, its string value is used without quoting.
        </para>

    </sect2>

    <sect2 id="zend.db.select.having">

        <title>HAVING Bedingungen</title>

        <para>
            Um HAVING Bedingungen zu den selektierten Ergebnissen hinzuzufügen, verwende die 
            having() Methode. Diese Methode ist identisch in der Funktion zur where() Methode.
        </para>

        <para>
            Wenn du having() mehrfach aufrufst, werden die Bedingungen per AND miteinander 
            verbunden; wenn du einen OR Verbunde benötigst, verwende orHaving().
        </para>
        <programlisting role="php"><![CDATA[<?php
	
// Erstelle ein $db Objekt, dann hole ein SELECT Werkzeug.
$select = $db->select();

// SELECT COUNT(id) AS count_id
//     FROM `foo` foo
//     GROUP BY `bar`, `baz`
//     HAVING count_id > '1'

$select->from('foo', new Zend_Db_Expr('COUNT(id) AS count_id'));
$select->group(array('bar', 'baz'));
$select->having('count_id > ?', 1);

?>]]></programlisting>

        <para>
            Zend_Db_Select does not apply quoting or table aliases to
            columns named in HAVING clauses.  If you combine PHP 
            variables into the string for a HAVING expression, you
            should use the Zend_Db_Adapter quoteIdentifier() method
            to protect against illegal syntax.
        </para>
        <programlisting role="php"><![CDATA[<?php
...
$columnName = 'count_id'; // or set by an untrusted source
$havingExpr = $db->quoteIdentifier($columnName) . ' > ?';
$select->having($havingExpr, 1);
?>]]></programlisting>

    </sect2>

    <sect2 id="zend.db.select.order">

        <title>ORDER BY Klausel</title>

        <para>
            Um Spalten zu sortieren, verwenden die order() Methode so oft du möchtest.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// Erstelle ein $db Objekt, dann hole ein SELECT Werkzeug.
$select = $db->select();

// SELECT r.*
// FROM `round_table` r
// ORDER BY `noble_title` DESC, `first_name` ASC

$select->from('round_table');
$select->order('noble_title DESC');
$select->order('first_name');

// an equivalent order() call:
$select->order(array('noble_title DESC', 'first_name'));

?>]]></programlisting>

        <para>
            Do not specify multiple columns as a single string of
            comma-separated column names.  This syntax used in
            earlier preview releases of Zend_Db is no longer supported.
            Use an array instead.
        </para>

        <para>
            Quoting is applied to every string element of the
            order() argument, but if the element is an object of type
            Zend_Db_Expr, its string value is used without quoting.
        </para>

    </sect2>

    <sect2 id="zend.db.select.limit">

        <title>LIMIT Begrenzung per Anzahl und Offset</title>

        <para>
            Zend_Db_Select bietet Unterstützung für datenbankabstrahierte LIMIT Klauseln. Für viele
            Datenbanken, wie z.B. MySQL und PostgreSQL, ist dies relativ einfach, da sie die 
            "LIMIT :count [OFFSET :offset]" Syntax unterstützen.
        </para>

        <para>
            For some other databases, this is not so easy, because they
            don't support the LIMIT clause.  Microsoft SQL Server has a
            TOP clause that can provide the same result.  Oracle and DB2
            require a query to be written in a special fashion to emulate
            a LIMIT.  Zend_Db_Select can rewrite the SELECT appropriately
            for each database adapter to provide the LIMIT functionality.
        </para>

        <para>
            Um die erhaltenen Ergebnisse zu limitieren, per Anzahl und Offset, verwende die limit()
            Methode mit einer Anzahl und optionalem Offset.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// zuerst ein einfacher "LIMIT :count"
$select = $db->select();
$select->from('foo');
$select->order('id');
$select->limit(10);

// In MySQL/PostgreSQL/SQLite wird dies wie folgt übersetzt:
//
// SELECT foo.*
// FROM "foo" foo
// ORDER BY "id" ASC
// LIMIT 10
//
// But in Microsoft SQL Server, this translates to:
//
// SELECT TOP 10 foo.*
// FROM [foo] foo
// ORDER BY [id] ASC

// nun einer etwas komplexeres "LIMIT :count OFFSET :offset"
$select = $db->select();
$select->from('foo', '*');
$select->order('id');
$select->limit(10, 20);

// In MySQL/PostgreSQL/SQLite wird dies wie folgt übersetzt:
//
// SELECT foo.*
// FROM "foo" foo
// ORDER BY "id" ASC
// LIMIT 10 OFFSET 20
//
// Microsoft SQL Server has no offset support, so this translates to:
//
// SELECT * FROM (
//     SELECT TOP 10 * FROM (
//         SELECT TOP 30 *
//         FROM [foo] foo
//         ORDER BY [id] DESC
//     ) ORDER BY id ASC
// )
//
// Zend_Db_Adapter führt die Abfrageübersetzung automatisch durch.
//

?>]]></programlisting>

    </sect2>

    <sect2 id="zend.db.select.paging">

        <title>LIMIT Begrenzung per Seite und Offset</title>

        <para>
            Zend_Db_Select bietet auch seitenbasierte Limitierung. Wenn du einen bestimmte "Seite"
            eines Ergebnisses erhalten möchtest, verwende die limitPage() Methode; zuerst übergebe
            die gewünschte Seitennummer und dann die Anzahl der Zeilen, die auf jeder Seite 
            erscheinen sollen.
        </para>

        <programlisting role="php"><![CDATA[<?php
	
// erstelle den grundlegenden Select...
$select = $db->select();
$select->from('foo');
$select->order('id');

// ... und begrenze auf Seite 3, wobei jede Seite 10 Zeilen hat
$select->limitPage(3, 10);

// In MySQL/PostgreSQL/SQLite wird dies wie folgt übersetzt:
//
// SELECT foo.*
// FROM `foo` foo
// ORDER BY `id` ASC
// LIMIT 10 OFFSET 20

?>]]></programlisting>
    </sect2>

    <sect2>
        <title>Other methods</title>

        <para>
            The distinct() method enables you to add the DISTINCT
            keyword to your SQL query.
        </para>
        <programlisting role="php"><![CDATA[<?php

// SELECT DISTINCT foo.`non_unique_column`
// FROM `foo` foo

$select = $db->select();
$select->distinct();
$select->from('foo', 'non_unique_column');

?>]]></programlisting>

        <para>
            The forUpdate() method enables you to add the FOR UPDATE
            keywords to your SQL query.
        </para>
        <programlisting role="php"><![CDATA[<?php

// SELECT FOR UPDATE foo.*
// FROM `foo` foo

$select = $db->select();
$select->forUpdate();
$select->from('foo');

?>]]></programlisting>

        <para>
            The query() method is like the query() method of
            the Zend_Db_Adapter.  It returns an object of type
            Zend_Db_Statement or PDOStatement, depending on the
            adapter type.
        </para>
        <programlisting role="php"><![CDATA[<?php

$select = $db->select();
$select->from('foo');
$stmt = $select->query();
$result = $stmt->fetchAll();

// This is equivalent to the following:
$select = $db->select();
$select->from('foo');
$stmt = $db->query($select);
$result = $stmt->fetchAll();

?>]]></programlisting>

        <para>
            The getPart() method returns the data you provided
            for part of the SQL query.  The Zend_Db_Select class
            includes constant definitions that you can use for
            parts of the SQL query.
        </para>
        <programlisting role="php"><![CDATA[<?php

// SELECT foo.*
// FROM `foo` foo
// ORDER `keyColumn`

$select = $db->select();
$select->from('foo');
$select->order('keyColumn');

print_r( $select->getPart( Zend_Db_Select::ORDER ) );

?>]]></programlisting>

        <para>
            The reset() method enables you to clear one specified
            part of the SQL query, or else clear all parts of
            the SQL query if you omit the argument.
        </para>
        <programlisting role="php"><![CDATA[<?php

// SELECT foo.*
// FROM `foo` foo
// ORDER BY `column1`

$select = $db->select();
$select->from('foo');
$select->order('column1');

// Instead we want a different order criterion:
//
// SELECT foo.*
// FROM `foo` foo
// ORDER BY `column2`

// Clear one part so we can redefine it
$select->reset( Zend_Db_Select::ORDER );
$select->order('column2');

// Clear all parts of the query
$select->reset();

?>]]></programlisting>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
