<sect1 id="zend.db.table">

    <title>Zend_Db_Table</title>

    <sect2 id="zend.db.table.introduction">

        <title>Einführung in die Table Klasse</title>

        <para>
            Die Zend_Db_Table Klasse ist eine Objekt-Orientierte Schnittstelle zu Datenbank Tabellen. Sie bietet
            Methoden für viele gängige Operationen an Tabellen. Die Basisklasse ist erweiterbar, daher kann eigene
            Logik eingeführt werden.
        </para>

        <para>
            Die Zend_Db_Table Lösung ist eine Implementation des
            <ulink url="http://www.martinfowler.com/eaaCatalog/tableDataGateway.html">Table Data Gateway</ulink>
            Patterns. Die Lösung schließt außerdem eine Klasee ein, welche das
            <ulink url="http://www.martinfowler.com/eaaCatalog/rowDataGateway.html">Row Data Gateway</ulink>
            Pattern implementiert.
        </para>

    </sect2>

    <sect2 id="zend.db.table.defining">
        <title>Definieren einer Table Klasse</title>

        <para>
            Für jede Tabelle der Datenbank auf die zugegriffen werden soll, sollte eine eine Klasse
            erzeugt werden, welche Zend_Db_Table_Abstract erweitert.
        </para>

        <sect3 id="zend.db.table.defining.table-schema">

            <title>Definieren des Tabellennamens und Schemas</title>

            <para>
                Die Tabelle der Datenbank, für welche die Klasse bestimmt ist, wird mit der protected Variablen
                <code>$_name</code> angegeben. Es ist ein String, welcher den Namen der Tabelle enthalten muss,
                wie er in der Datenbank erscheint.
            </para>

            <example id="zend.db.table.defining.table-schema.example1">
                <title>Angeben einer Table Klasse mit ausdrücklichem Tabellennamen</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';
}
]]></programlisting>
            </example>

            <para>
                Wird keine Tabellenname angegeben, so wird ein Standard verwendet, welcher dem Namen der Klasse
                entspricht. Wird sich auf diesen Standard verlassen, so muss der Klassenname der Schreibweise der
                Tabelle entsprechen, wie sie in der Datenbank erscheint.
            </para>

            <example id="zend.db.table.defining.table-schema.example">
                <title>Angeben einer Table Klasse mit inbegriffenem Tabellennamen</title>
                <programlisting role="php"><![CDATA[<?php

class bugs extends Zend_Db_Table_Abstract
{
    // Tabellenname entspricht dem Klassennamen
}]]></programlisting>
            </example>

            <para>
                Es kann auch ein Schema für die Tabelle angegeben werden. Entweder mit der protected Variablen
                <code>$_schema</code> oder mit dem Schema vorangestellt in der <code>$_name</code> Eigenschaft.
                Jedes Schema welches in der <code>$_name</code> Eigenschatf angegeben ist wird vorrangig gegenüber
                dem Schema der <code>$_schema</code> Eigenschaft behandelt. In einigen RDBMS Marken ist die
                Bezeichnung für Schema "database" oder "tablespace", wird aber ähnlich verwendet.
            </para>

            <example id="zend.db.table.defining.table-schema.example3">
                <title>Angeben einer Table Klasse mit Schema</title>
                <programlisting role="php"><![CDATA[<?php

// Erste Möglichkeit:

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_schema = 'bug_db';
    protected $_name   = 'bugs';
}

// Zweite Möglichkeit:

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bug_db.bugs';
}

// Wenn Schema sowohl in $_name als auch $_schema angegeben wird, so bekommt $_name vorrang:

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name   = 'bug_db.bugs';
    protected $_schema = 'ignored';
}]]></programlisting>
            </example>

            <para>
                Die Schema und Tabellennamen können auch mit Konstruktor Konfigurationsdirektiven angegeben werden,
                welche jegliche Standardwerte, angegeben in den <code>$_name</code> und <code>$_schema</code>
                Eigenschaften, überschreiben. Eine Schema Angabe welche mit der <code>name</code> Directive
                angegeben wurde überschreibt jeglichen Wert welcher von der <code>schema</code> Option
                bereitgestellt ist.
            </para>

            <example id="zend.db.table.defining.table-schema.example.constructor">

                <title>Angebend von Tabellen und Schemanamen während der Instanziierung</title>

                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
}

// Erste Möglichkeit:

$tableBugs = new Bugs(array('name' => 'bugs', 'schema' => 'bug_db'));

// Zweite Möglichkeit:

$tableBugs = new Bugs(array('name' => 'bug_db.bugs');

// Wenn Schema sowohl in $_name als auch $_schema angegeben wird, so bekommt $_name vorrang:

$tableBugs = new Bugs(array('name' => 'bug_db.bugs', 'schema' => 'ignored');]]></programlisting>

            </example>

            <para>
                Wenn kein Schemaname angegeben wird, so wird als Standard der Schemaname des Datenbankadapters
                verwendet.
            </para>

        </sect3>

        <sect3 id="zend.db.table.defining.primary-key">

            <title>Angebende des Tabellen Primärschlüssels</title>

            <para>
                Jede Tabelle muss einen Primärschlüssel haben. Die Spalte des Primärschlüssels kann mit der
                protected Variablen <code>$_primary</code> angegeben werden. Sie enthält entweder einen String,
                welcher die einzelen Spalte benennt, oder ein Array von Spaltennamen, wenn der Primärschlüssel ein
                zusammengesetzter Schlüssel ist.
            </para>

            <example id="zend.db.table.defining.primary-key.example">
                <title>Beispiel für das angeben eines Primärschlüssels</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';
    protected $_primary = 'bug_id';
}]]></programlisting>
            </example>

            <para>
                Wenn kein Primärschlüssel angegeben wird, versucht Zend_Db_Table_Abstract den Primärschlüssel mit
                Hilfe der <code>describeTable()</code> Methode zu ermitteln.
            </para>

            <note>
                <para>
                    Jede Table Klasse muss wissen mit welche(r/n) Spalte(n) Zeilen eindeutig identifiziert werden
                    können. Wenn keine Primärschlüssel Spalte(n) in der Klassendefinition oder als Argument für den
                    Konstruktor angegeben wurde und nicht aus den Tabellenmetadaten mit Hilfe der
                    <code>describeTable()</code> Methode ermittelt werden kann, dann kann die Tabelle nicht mit
                    Zend_Db_Table verwendet werden.
                </para>
            </note>

        </sect3>

        <sect3 id="zend.db.table.defining.setup">

            <title>Überschreiben von Table Setup Methoden</title>

            <para>
                Wenn eine Instanz einer Table Klasse erzeugt wird, ruft der Konstruktor einige protected Methoden
                auf, die Metadaten der Tabelle initialisieren. Jede dieser Methoden kann erweitert werden um
                Metadaten explizit anzugeben. Dabei darf nicht vergessen werden am Ende der eigenen Methode die
                gleichnamige Methode der Parentklasse aufzurufen.
            </para>

            <example id="zend.db.table.defining.setup.example">
                <title>Beispiel für das Überschreiben der _setupTableName() Methode</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected function _setupTableName()
    {
        $this->_name = 'bugs';
        parent::_setupTableName();
    }
}]]></programlisting>
            </example>

            <para>
                Folgende Setup Methoden sind überschreibbar:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <code>_setupDatabaseAdapter()</code> überprüft ob ein Adapter bereitgestellt wird; nimmt
                        einen Standardadapter aus der Registry, wenn benötigt. Durch das überschreiben dieser
                        Methode kann ein Datenbankadapter aus einer anderen Quelle gesetzt werden.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>_setupTableName()</code> setzt den standard Tabellennamen auf den Namen der Klasse.
                        Durch das überschreiben dieser Methode kann der Tabellenname gesetzt werden bevor dieses
                        Standardverhalten abläuft.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>_setupMetadata()</code> setzt das Schema wenn der Tabellenname dem Muster
                        "schema.table" entspricht; ruft <code>describeTable()</code> auf um Metadaten
                        Informationen zu erhalten; Standardisiert das <code>$_cols</code> Array auf die
                        Spalten wie von <code>describeTable()</code> geliefert. Durch das überschreiben dieser
                        Methode können die Spalten angegeben werden.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>_setupPrimaryKey()</code> standardisiert die Primärschlüssel Spalten zu denen
                        geliefert von <code>describeTable()</code>; prüft ob die Primärschlüssel Spalten
                        im <code>$_cols</code> Array enthalten sind. Durch das überschreiben dieser Methode
                        können die Primärschlüssel Spalten angegeben werden.
                    </para>
                </listitem>
            </itemizedlist>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.constructing">

        <title>Erzeugen einer Instanz einer Tabelle</title>

        <para>
            Bevor eine Table Klasse verwendet werden kann muss eine Instanz mit dem Konstruktor erzeugt werden. Das
            Konstruktor Argument ist ein Array von Optionen. Die wichtigste Option für einen Tabellenkonstruktor
            ist die Instanz der Adapterklasse, welche eine live Verbindung zu einem RDBMS repräsentiert. Es gibt
            drei Möglichkeiten den Datenbankadapter einer Tabellenklasse anzugeben und diese sind unten
            Beschrieben:
        </para>

        <sect3 id="zend.db.table.constructing.adapter">

            <title>Angeben eines Datenbankadapters</title>

            <para>
                Der erste Weg einen Datenbankadapter an eine Table Klasse bereitzustellen ist, ein Objekt des Typs
                Zend_Db_Adapter_Abstract im Options Array, bezeichnet mit dem Schlüssel <code>'db'</code>, zu
                übergeben.
            </para>

            <example id="zend.db.table.constructing.adapter.example">
                <title>Beispiel für das erzeugen einer Table mit Nutzung eines Adapterobjekts</title>
                <programlisting role="php"><![CDATA[<?php

$db = Zend_Db::factory('PDO_MYSQL', $options);

$table = new Bugs(array('db' => $db));]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.constructing.default-adapter">

            <title>Setzen eines Standard-Datenbankadapters</title>

            <para>
                Der zweite Weg einer Table Klasse einen Datenbankadapter bereit zu stellen ist es, ein Objekt des
                Typs Zend_Db_Adapter_Abstract zu deklarieren und als Standard für alle nachfolgenden Instanzen von
                Table der Applikation zu setzen. Dies kann mit der static Methode
                <code>Zend_Db_Table_Abstract::setDefaultAdapter()</code> getan werden. Das Argument ist ein
                Objekt des Typs Zend_Db_Adapter_Abstract.
            </para>

            <example id="zend.db.table.constructing.default-adapter.example">
                <title>Beispiel für das erstellen von Table mit einem Standardadapter</title>
                <programlisting role="php"><![CDATA[<?php

$db = Zend_Db::factory('PDO_MYSQL', $options);
Zend_Db_Table_Abstract::setDefaultAdapter($db);

// Später...

$table = new Bugs();]]></programlisting>
            </example>

            <para>
                Es kann geeignet sein den Datenbankadapter an einer zentralen Stelle der Anwendung, wie dem
                Bootstrap, zu erzeugen, und als Standardadapter zu speichern.
                Dies hilft sicher zu stellen, das der verwendete Adapter in der gesamten Anwendung der gleiche
                ist. Allerdings kann nur eine einzelne Adapterinstanz als Standardadapter verwendet werden.
            </para>

        </sect3>


        <sect3 id="zend.db.table.constructing.registry">

            <title>Speichern eines Datenbankadapters in der Registry</title>

            <para>
                Der dritte Weg einer Table Klasse einen Datenbankadapter bereit zu stellen ist es einen String in
                dem Optionsarray zu übergeben, auch mit dem <code>'db'</code> Schlüssel identifiziert. Der String
                wird als Schlüssel der statischen Zend_Registry Instanz verwendet, wo der Eintrag mit dem Schlüssel
                ein Objekt des Typs Zend_Db_Adapter_Abstract ist.
            </para>

            <example id="zend.db.table.constructing.registry.example">
                <title>Beispiel für das erzeugen von Table mit einem Registry Schlüssel</title>
                <programlisting role="php"><![CDATA[<?php

$db = Zend_Db::factory('PDO_MYSQL', $options);
Zend_Registry::set('my_db', $db);

// Später...

$table = new Bugs(array('db' => 'my_db'));]]></programlisting>
            </example>

            <para>
                Wie das Setzen eines Standardadapters, bietet auch dieses sicher zu stellen das die gleiche Adapter
                Instanz in der gesamten Applikation verwendet wird. Nutzen der Registry ist flexibler, da mehr als
                eine Adapterinstanz gepeichert werden kann. Eine angegebene Adapterinstanz ist spezifisch für eine
                bestimmte RDBMS Marke und Datenbankinstanz. Wenn die Applikation Zugriff auf mehrere Datenbanken
                benötigt oder auch mehrere Datenbank Marken, dann müssen mehrere Adapter verwendet werden.
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.insert">

        <title>Zeilen in eine Tabelle einfügen</title>

        <para>
            Tabellen Objekte können verwendet werden um Zeilen in die Datenbank Tabelle einzufügen auf der das
            Tabellen Objekt basiert. Hierzu kann die <code>insert()</code> Methode des Tabellen Objektes
            verwendet werden. Das Argument ist ein assoziatives Array, das Spalten Namen mit Werten verbindet.
        </para>

        <example id="zend.db.table.insert.example">
            <title>Beispiel vom Einfügen in eine Tabelle</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$data = array(
    'created_on'      => '2007-03-22',
    'bug_description' => 'Irgendwas falsch',
    'bug_status'      => 'NEW'
);

$table->insert($data);]]></programlisting>
        </example>

        <para>
            Standardmäßig werden Werte im Daten Array als literale Werte eingefügt durch das Verwenden von
            Parametern. Wenn es notwendig ist das diese als SQL Ausdruck behandelt werden, muß sichergestellt
            werden das Sie sich von reinen Strings unterscheiden. Es kann ein Objekt vom Typ Zend_Db_Expr
            verwendet werden um das zu bewerkstelligen.
        </para>

        <example id="zend.db.table.insert.example-expr">
            <title>Beispiel für das Einfügen von Ausdrücken in einer Tabelle</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$data = array(
    'created_on'      => new Zend_Db_Expr('CURDATE()'),
    'bug_description' => 'Irgendwas ist falsch',
    'bug_status'      => 'NEU'
);]]></programlisting>
        </example>

        <para>
            Um obigen Beispiel vom Einfügen von Reihen, wird angenommen das die Tabelle einen automatisch
            hinzugefügten Primären Schlüssel hat. Das ist das Standardverhalten von Zend_Db_Table_Abstract,
            aber es gibt auch andere Typen von Primären Schlüssel. Das folgende Kapitel beschreibt wie
            verschiedene Typen von Primären Schlüssel unterstützt werden.
        </para>

        <sect3 id="zend.db.table.insert.key-auto">

            <title>Eine Tabelle mit einem automatisch hinzugefügten Primären Schlüssel verwenden</title>

            <para>
                Ein automatisch hinzugefügter Primärer Schlüssel erzeigt einen eindeutigen Integerwert wenn die
                Spalte des Primären Typs in der eigenen SQL <code>INSERT</code> Anweisung unterdrückt wird.
            </para>

            <para>
                Wenn die geschützte Variable <code>$_sequence</code>, in Zend_Db_Table_Abstract, als
                boolscher Wert <code>true</code> definiert wird, nimmt die Klasse an das die Tabelle
                einen automatisch hinzugefügten Primären Schlüssel hat.
            </para>

            <example id="zend.db.table.insert.key-auto.example">
                <title>Beispiel des deklarierens einer Tabelle mit einem automatisch hinzugefügten Primären Schlüssel</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    // Das ist der Standardwert in der Zend_Db_Table_Abstract Klasse;
    // er muß nicht definiert werden.
    protected $_sequence = true;
}]]></programlisting>
            </example>

            <para>
                MySQL, Microsoft SQL Server, und SQLite sind Beispiele von RDBMS Marken die automatisch
                hinzugefpgte Primäre Schlüssel unterstützen.
            </para>

            <para>
                PostgreSQL hat eine <code>SERIAL</code> Notation die implizit eine sequenz definiert die auf dem
                Tabellen und Spaltennamen basiert und diese Sequenz verwendet um einen Schlüsselwert für neue
                Reihen zu erstellen. IBM DB2 hat eine <code>IDENTITY</code> Notation die ähnlich arbeitet.
                Wenn eine dieser Notationen verwendet wird, muß der Zend_Db_Table Klasse mitgeteilt werden das
                Sie eine automatisch hinzugefügte Spalte hat, indem <code>$_sequence</code> auf <code>true</code>
                gesetzt wird.
            </para>

        </sect3>

        <sect3 id="zend.db.table.insert.key-sequence">

            <title>Eine Tabelle mit einer Sequenz verwenden</title>

            <para>
                Eine Sequenz ist ein Datenbank Objekt das einen eindeutigen Wert erstellt, der als
                primärer Schlüsselwert in einer oder mehreren Tabellen der Datenbank verwendet werden kann. 
            </para>

            <para>
                Wenn <code>$_sequence</code> als String definiert wird, nimmt Zend_Db_Table_Abstract an das der
                String den Namen des Sequenz Objektes in der Datenbank benennt. Die Sequenz wird aufgerufen um
                einen neuen Wert zu erstellen, und dieser Wert wird in der <code>INSERT</code> Operation
                verwendet.
            </para>

            <example id="zend.db.table.insert.key-sequence.example">
                <title>Beispiel der Deklaration einer Tabelle mit einer Sequenz</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    protected $_sequence = 'bug_sequence';
}]]></programlisting>
            </example>

            <para>
                Oracle, PostgreSQL, und IBM DB2 sind Beispiele von RDBMS Marken die Sequenz Objekte in der
                Datenbank unterstützen.
            </para>

            <para>
                PostgreSQL und IBM DB2 haben auch einen Syntax der Sequenzen implizit definiert und diese
                mit Spalten assoziiert. Wenn diese Notation verwendet wird, muß der Tabelle gesagt werden
                das Sie einen automatisch hinzugefügte Schlüsselspalte besitzt. Der Name der Sequenz muß
                nur in den Fällen als String definiert werden in denen die Sequenz explizit aufgerufen
                wird um den nächsten Schlüsselwert zu erhalten.
            </para>

        </sect3>

        <sect3 id="zend.db.table.insert.key-natural">

            <title>Eine Tabelle mit einem natürlichen Schlüssel verwenden</title>

            <para>
                Some tables have a natural key.  This means that the key is
                not automatically generated by the table or by a sequence.
                You must specify the value for the primary key in this case.
            </para>

            <para>
                If you define the <code>$_sequence</code> to be the Boolean
                value <code>false</code>, then Zend_Db_Table_Abstract assumes
                that the table has a natural primary key.  You must provide
                values for the primary key columns in the array of data to the
                <code>insert()</code> method, or else this method throws a
                Zend_Db_Table_Exception.
            </para>

            <example id="zend.db.table.insert.key-natural.example">
                <title>Example of declaring a Table with a natural key</title>
                <programlisting role="php"><![CDATA[<?php

class BugStatus extends Zend_Db_Table_Abstract
{
    protected $_name = 'bug_status';

    protected $_sequence = false;
}]]></programlisting>
            </example>

            <note>
                <para>
                    All RDBMS brands support tables with natural keys.
                    Examples of tables that are often declared as having
                    natural keys are lookup tables, intersection tables
                    in many-to-many relationships, or most tables with
                    compound primary keys.
                </para>
            </note>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.update">

        <title>Updating Rows in a Table</title>

        <para>
            You can update rows in a database table using the
            <code>update</code> method of a Table class.  This method
            takes two arguments:  an associative array of columns to change
            and new values to assign to these columns; and an SQL expression
            that is used in a <code>WHERE</code> clause, as criteria for
            the rows to change in the <code>UPDATE</code> operation.
        </para>

        <example id="zend.db.table.update.example">
            <title>Example of updating rows in a Table</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$data = array(
    'updated_on'      => '2007-03-23',
    'bug_status'      => 'FIXED'
);

$where = $table->getAdapter()->quoteInto('bug_id = ?', 1234);

$table->update($data, $where);]]></programlisting>
        </example>

        <para>
            Since the table <code>update()</code> method proxies to the database adapter
            <link linkend="zend.db.adapter.write.update"><code>update()</code></link> method, the second argument can be an
            array of SQL expressions. The expressions are combined as Boolean terms using an <code>AND</code>
            operator.
        </para>

        <note>
            <para>
                The values and identifiers in the SQL expression are not
                quoted for you.  If you have values or identifiers that
                require quoting, you are responsible for doing this.
                Use the <code>quote()</code>, <code>quoteInto()</code>, and
                <code>quoteIdentifier()</code> methods of the database adapter.
            </para>
        </note>

    </sect2>

    <sect2 id="zend.db.table.delete">

        <title>Deleting Rows from a Table</title>

        <para>
            You can delete rows from a database table using the
            <code>delete()</code> method.  This method takes one argument,
            which is an SQL expression that is used in a <code>WHERE</code>
            clause, as criteria for the rows to delete.
        </para>

        <example id="zend.db.table.delete.example">
            <title>Example of deleting rows from a Table</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = $table->getAdapter()->quoteInto('bug_id = ?', 1235);

$table->delete($where);]]></programlisting>
        </example>

        <para>
            The second argument can be an array of SQL expressions.
            The expressions are combined as Boolean terms
            using an <code>AND</code> operator.
        </para>

        <para>
            Since the table <code>delete()</code> method proxies to the database adapter
            <link linkend="zend.db.adapter.write.delete"><code>delete()</code></link> method, the second argument can be an
            array of SQL expressions. The expressions are combined as Boolean terms using an <code>AND</code>
            operator.
        </para>

        <note>
            <para>
                The values and identifiers in the SQL expression are not
                quoted for you.  If you have values or identifiers that
                require quoting, you are responsible for doing this.
                Use the <code>quote()</code>, <code>quoteInto()</code>, and
                <code>quoteIdentifier()</code> methods of the database adapter.
            </para>
        </note>

    </sect2>

    <sect2 id="zend.db.table.find">

        <title>Finding Rows by Primary Key</title>

        <para>
            You can query the database table for rows matching specific values
            in the primary key, using the <code>find()</code> method.
            The first argument of this method is either a single value or
            an array of values to match against the primary key of the
            table.
        </para>

        <example id="zend.db.table.find.example">
            <title>Example of finding rows by primary key values</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

// Find a single row
// Returns a Rowset
$rows = $table->find(1234);

// Find multiple rows
// Also returns a Rowset
$rows = $table->find(array(1234, 5678));]]></programlisting>
        </example>

        <para>
            If you specify a single value, the method returns at most
            one row, because a primary key cannot have duplicate values
            and there is at most one row in the database table matching the
            value you specify.  If you specify multiple values in an array,
            the method returns at most as many rows as the number of distinct
            values you specify.
        </para>

        <para>
            The <code>find()</code> method might return fewer rows than
            the number of values you specify for the primary key, if some
            of the values don't match any rows in the database table.
            The method even may return zero rows.  Because the number of
            rows returned is variable, the <code>find()</code> method returns
            an object of type Zend_Db_Table_Rowset_Abstract.
        </para>

        <para>
            If the primary key is a compound key, that is, it consists
            of multiple columns, you can specify the additional columns as
            additional arguments to the <code>find()</code> method.
            You must provide as many arguments as the number of columns in
            the table's primary key.
        </para>

        <para>
            To find multiple rows from a table with a compound primary key,
            provide an array for each of the arguments.  All of these arrays
            must have the same number of elements.  The values in each array
            are formed into tuples in order; for example, the first element in
            all the array arguments define the first compound primary key
            value, then the second elements of all the arrays define the second
            compound primary key value, and so on.
        </para>

        <example id="zend.db.table.find.example-compound">
            <title>Example of finding rows by compound primary key values</title>
            <para>
                The call to <code>find()</code> below to match multiple rows
                can match two rows in the database.  The first row must have
                primary key value (1234, 'ABC'), and the second row must have
                primary key value (5678, 'DEF').
            </para>
            <programlisting role="php"><![CDATA[<?php

class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs_products';
    protected $_primary = array('bug_id', 'product_id');
}

$table = new BugsProducts();

// Find a single row with a compound primary key
// Returns a Rowset
$rows = $table->find(1234, 'ABC');

// Find multiple rows with compound primary keys
// Also returns a Rowset
$rows = $table->find(array(1234, 5678), array('ABC', 'DEF'));]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.db.table.fetch-all">

        <title>Querying for a Set of Rows</title>

        <para>
            You can query for a set of rows using any criteria other than
            the primary key values, using the <code>fetchAll()</code> method
            of the Table class.  This method returns an object of type
            Zend_Db_Table_Rowset_Abstract.
        </para>

        <example id="zend.db.table.fetch-all.example1a">
            <title>Example of finding rows by an expression</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW');

$rows = $table->fetchAll($where);]]></programlisting>
        </example>

        <para>
            The first argument to this method is an SQL expression that
            is used in a <code>WHERE</code> clause, like those used in the
            <code>update()</code> and <code>delete()</code> methods
            described earlier.
        </para>

        <para>
            The argument for the <code>WHERE</code> clause may be a string
            as shown in the previous example, or it may be an array.
            For each element of the array, if the key is a string, the key of
            the array element is an SQL expression containing a placeholder,
            and the value of the array element is a value to be interpolated
            into the expression in place of the placeholder.
        </para>

        <example id="zend.db.table.fetch-all.example1b">
            <title>Example of finding rows by an expression array</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = array('bug_status = ?' => 'NEW');

$rows = $table->fetchAll($where);]]></programlisting>
        </example>

        <para>
            If the array has multiple elements, the elements are combined in
            the query in <code>AND</code> expressions.
        </para>

        <example id="zend.db.table.fetch-all.example1c">
            <title>Example of finding rows by an expression array with multiple terms</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = array(
            'bug_status = ?'  => 'NEW',
            'reported_by = ?' => 'dduck'
        );

$rows = $table->fetchAll($where);
// generated SQL contains:
// WHERE bug_status = 'NEW' AND reported_by = 'dduck'
]]></programlisting>
        </example>

        <note>
            <para>
                The values and identifiers in the SQL expression are not
                quoted for you.  If you have values or identifiers that
                require quoting, you are responsible for doing this.
                Use the <code>quote()</code>, <code>quoteInto()</code>, and
                <code>quoteIdentifier()</code> methods of the database adapter.
            </para>
        </note>

        <para>
            The second argument is an expression or array of expressions
            used as sorting criteria in an <code>ORDER BY</code> clause.
        </para>

        <para>
            The third and fourth arguments are the count and offset integer
            values, used to make the query return a specific subset of rows.
            These values are used in a <code>LIMIT</code> clause, or in
            equivalent logic for RDBMS brands that do not support the
            <code>LIMIT</code> syntax.
        </para>

        <example id="zend.db.table.fetch-all.example2">
            <title>Example of finding rows by an expression</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where  = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW');

$order  = 'bug_id';

// Return the 21st through 30th rows
$count  = 10;
$offset = 20;

$rows = $table->fetchAll($where, $order, $count, $offset);]]></programlisting>
        </example>

        <para>
            All of the arguments above are optional.  If you omit these
            arguments, the result set includes all rows from the table
            in an unpredictable order.
        </para>

    </sect2>

    <sect2 id="zend.db.table.fetch-row">

        <title>Querying for a Single Row</title>

        <para>
            You can query for a single row using any criteria other than
            the primary key values, using the <code>fetchRow()</code> method
            of the Table class.  Usage of this method is similar to that
            of the <code>fetchAll()</code> method, in that its arguments
            include the <code>WHERE</code> expression and the sorting criteria.
        </para>

        <example id="zend.db.table.fetch-row.example1">
            <title>Example of finding a single row by an expression</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where  = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW');

$order  = 'bug_id';

$row = $table->fetchRow($where, $order);]]></programlisting>
        </example>

        <para>
            This method returns an object of type Zend_Db_Table_Row_Abstract.
            If the search criteria you specified match no rows in the
            database table, then <code>fetchRow()</code> returns PHP's
            <code>null</code> value.
        </para>

    </sect2>

    <sect2 id="zend.db.table.info">

        <title>Retrieving Table Metadata Information</title>

        <para>
            The Zend_Db_Table_Abstract class provides some information
            about its metadata.  The <code>info()</code> method returns
            an array structure with information about the table, its
            columns and primary key, and other metadata.
        </para>

        <example id="zend.db.table.info.example">
            <title>Example of getting the table name</title>
            <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$info = $table->info();

echo "The table name is " . $info['name'] . "\n";]]></programlisting>
        </example>

        <para>
            The keys of the array returned by the <code>info()</code>
            method are described below:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="strong">name</emphasis> =>
                    the name of the table.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">cols</emphasis> =>
                    an array, naming the column(s) of the table.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">primary</emphasis> =>
                    an array, naming the column(s) in the primary key.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">metadata</emphasis> =>
                    an associative array, mapping column names to
                    information about the columns.  This is the information
                    returned by the <code>describeTable()</code> method.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">rowClass</emphasis> =>
                    the name of the concrete class used for Row objects
                    returned by methods of this table instance.
                    This defaults to Zend_Db_Table_Row.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">rowsetClass</emphasis> =>
                    the name of the concrete class used for Rowset objects
                    returned by methods of this table instance.
                    This defaults to Zend_Db_Table_Rowset.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">referenceMap</emphasis> =>
                    an associative array, with information about
                    references from this table to any parent tables.
                    See <xref linkend="zend.db.table.relationships.defining" />.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">dependentTables</emphasis> =>
                    an array of class names of tables that reference this table.
                    See <xref linkend="zend.db.table.relationships.defining" />.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">schema</emphasis> =>
                    the name of the schema (or database or tablespace)
                    for this table.
                </para>
            </listitem>
        </itemizedlist>

    </sect2>

    <sect2 id="zend.db.table.metadata.caching">

        <title>Caching Table Metadata</title>

        <para>
            By default, <code>Zend_Db_Table_Abstract</code> queries the underlying database for
            <link linkend="zend.db.table.info">table metadata</link> upon instantiation of a table object. That is,
            when a new table object is created, the object's default behavior is to fetch the table metadata from
            the database using the adapter's <code>describeTable()</code> method.
        </para>

        <para>
            In some circumstances, particularly when many table objects are instantiated against the same database
            table, querying the database for the table metadata for each instance may be undesirable from a
            performance standpoint. In such cases, users may benefit by caching the table metadata retrieved from the
            database.
        </para>

        <para>
            There are two primary ways in which a user may take advantage of table metadata caching:

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis role="strong">Call Zend_Db_Table_Abstract::setDefaultMetadataCache()</emphasis> -
                        This allows a developer to once set the default cache object to be used for all table classes.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="strong">Configure Zend_Db_Table_Abstract::__construct()</emphasis> - This
                        allows a developer to set the cache object to be used for a particular table class instance.
                    </para>
                </listitem>
            </itemizedlist>

            In both cases, the cache specification must be either <code>null</code> (i.e., no cache used) or an
            instance of <link linkend="zend.cache.frontends.core"><code>Zend_Cache_Core</code></link>. The methods may be used
            in conjunction when it is desirable to have both a default metadata cache and the ability to change the
            cache for individual table objects.
        </para>

        <example id="zend.db.table.metadata.caching-default">

            <title>Using a Default Metadata Cache for all Table Objects</title>

            <para>
                The following code demonstrates how to set a default metadata cache to be used for all table objects:
            </para>

            <programlisting role="php"><![CDATA[<?php

// First, set up the Cache

require_once 'Zend/Cache.php';

$frontendOptions = array(
    'automatic_serialization' => true
    );

$backendOptions  = array(
    'cacheDir'                => 'cacheDir'
    );

$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);


// Next, set the cache to be used with all table objects

require_once 'Zend/Db/Table/Abstract.php';

Zend_Db_Table_Abstract::setDefaultMetadataCache($cache);


// A table class is also needed

class Bugs extends Zend_Db_Table_Abstract
{
    // ...
}


// Each instance of Bugs now uses the default metadata cache

$bugs = new Bugs();]]></programlisting>

        </example>

        <example id="zend.db.table.metadata.caching-instance">

            <title>Using a Metadata Cache for a Specific Table Object</title>

            <para>
                The following code demonstrates how to set a metadata cache for a specific table object instance:
            </para>

            <programlisting role="php"><![CDATA[<?php

// First, set up the Cache

require_once 'Zend/Cache.php';

$frontendOptions = array(
    'automatic_serialization' => true
    );

$backendOptions  = array(
    'cacheDir'                => 'cacheDir'
    );

$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);


// A table class is also needed

require_once 'Zend/Db/Table/Abstract.php';

class Bugs extends Zend_Db_Table_Abstract
{
    // ...
}


// Configure an instance upon instantiation

$bugs = new Bugs(array('metadataCache' => $cache));]]></programlisting>

        </example>

        <note>

            <title>Automatic Serialization with the Cache Frontend</title>

            <para>
                Since the information returned from the adapter's describeTable() method is an array, ensure that the
                <code>automatic_serialization</code> option is set to <code>true</code> for the
                <code>Zend_Cache_Core</code> frontend.
            </para>

        </note>

        <para>
            Though the above examples use <code>Zend_Cache_Backend_File</code>, developers may use whatever cache
            backend is appropriate for the situation. Please see <link linkend="zend.cache">Zend_Cache</link> for more
            information.
        </para>

    </sect2>

    <sect2 id="zend.db.table.extending">

        <title>Customizing and Extending a Table Class</title>

        <sect3 id="zend.db.table.extending.row-rowset">

            <title>Using Custom Row or Rowset Classes</title>

            <para>
                By default, methods of the Table class return a
                Rowset in instances of the concrete class
                Zend_Db_Table_Rowset, and Rowsets contain a
                collection of instances of the concrete class
                Zend_Db_Table_Row.  You can specify an alternative
                class to use for either of these, but they must
                be classes that extend Zend_Db_Table_Rowset_Abstract
                and Zend_Db_Table_Row_Abstract, respectively.
            </para>

            <para>
                You can specify Row and Rowset classes using the
                Table constructor's options array, in keys
                <code>'rowClass'</code> and
                <code>'rowsetClass'</code> respectively.
                Specify the names of the classes using strings.
            </para>

            <example id="zend.db.table.extending.row-rowset.example">
                <title>Example of specifying the Row and Rowset classes</title>
                <programlisting role="php"><![CDATA[<?php

class My_Row extends Zend_Db_Table_Row_Abstract
{
    ...
}

class My_Rowset extends Zend_Db_Table_Rowset_Abstract
{
    ...
}

$table = new Bugs(
    array(
        'rowClass'    => 'My_Row',
        'rowsetClass' => 'My_Rowset'
    )
);

$where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW')

// Returns an object of type My_Rowset,
// containing an array of objects of type My_Row.
$rows = $table->fetchAll($where);]]></programlisting>
            </example>

            <para>
                You can change the classes by specifying
                them with the <code>setRowClass()</code> and
                <code>setRowsetClass()</code> methods.  This applies to
                rows and rowsets created subsequently; it does not change
                the class of any row or rowset objects you have created
                previously.
            </para>

            <example id="zend.db.table.extending.row-rowset.example2">
                <title>Example of changing the Row and Rowset classes</title>
                <programlisting role="php"><![CDATA[<?php

$table = new Bugs();

$where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW')

// Returns an object of type Zend_Db_Table_Rowset
// containing an array of objects of type Zend_Db_Table_Row.
$rowsStandard = $table->fetchAll($where);

$table->setRowClass('My_Row');
$table->setRowsetClass('My_Rowset');

// Returns an object of type My_Rowset,
// containing an array of objects of type My_Row.
$rowsCustom = $table->fetchAll($where);

// The $rowsStandard object still exists, and it is unchanged.]]></programlisting>
            </example>

            <para>
                For more information on the Row and Rowset classes,
                see <xref linkend="zend.db.table.row" /> and
                <xref linkend="zend.db.table.rowset" />.
            </para>

        </sect3>

        <sect3 id="zend.db.table.extending.insert-update">

            <title>Defining Custom Logic for Insert, Update, and Delete</title>

            <para>
                You can override the <code>insert()</code> and
                <code>update()</code> methods in your Table class.
                This gives you the opportunity to implement custom code
                that is executed before performing the database operation.
                Be sure to call the parent class method when you are done.
            </para>

            <example id="zend.db.table.extending.insert-update.example">
                <title>Custom logic to manage timestamps</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    public function insert(array $data)
    {
        // add a timestamp
        if (empty($data['created_on'])) {
            $data['created_on'] = time();
        }
        return parent::insert($data);
    }

    public function update(array $data, $where)
    {
        // add a timestamp
        if (empty($data['updated_on'])) {
            $data['updated_on'] = time();
        }
        return parent::update($data, $where);
    }
}]]></programlisting>
            </example>

            <para>
                You can also override the <code>delete()</code> method.
            </para>

        </sect3>

        <sect3 id="zend.db.table.extending.finders">

            <title>Define Custom Search Methods in Zend_Db_Table</title>

            <para>
                You can implement custom query methods in your Table class,
                if you have frequent need to do queries against this table
                with specific criteria.  Most queries can be written using
                <code>fetchAll()</code>, but this requires that you duplicate
                code to form the query conditions if you need to run the
                query in several places in your application.
                Therefore it can be convenient to implement a method
                in the Table class to perform frequently-used queries
                against this table.
            </para>

            <example id="zend.db.table.extending.finders.example">
                <title>Custom method to find bugs by status</title>
                <programlisting role="php"><![CDATA[<?php

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs';

    public function findByStatus($status)
    {
        $where = $this->getAdapter()->quoteInto('bug_status = ?', $status);
        return $this->fetchAll($where, 'bug_id');
    }
}]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.extending.inflection">

            <title>Define Inflection in Zend_Db_Table</title>

            <para>
                Some people prefer that the table class name match a table
                name in the RDBMS by using a string transformation called
                <emphasis>inflection</emphasis>.
            </para>

            <para>
                For example, if your table class name is
                "<code>BugsProducts</code>", it would match the physical table
                in the database called "<code>bugs_products</code>,"
                if you omit the explicit declaration of the <code>$_name</code>
                class property.
                In this inflection mapping, the class name spelled in
                "CamelCase" format would be transformed to lower case,
                and words are separated with an underscore.
            </para>

            <para>
                You can specify the database table name independently from
                the class name by declaring the table name with the
                <code>$_name</code> class property in each of your table
                classes.
            </para>

            <para>
                Zend_Db_Table_Abstract performs no inflection to
                map the class name to the table name.  If you omit the
                declaration of <code>$_name</code> in your table class,
                the class maps to a database table that matches the
                spelling of the class name exactly.
            </para>

            <para>
                It is inappropriate to transform identifiers from the database,
                because this can lead to ambiguity or make some identifiers
                inaccessible.
                Using the SQL identifiers exactly as they appear in the database
                makes Zend_Db_Table_Abstract both simpler and more flexible.
            </para>

            <para>
                If you prefer to use inflection, then you must implement
                the transformation yourself, by overriding the
                <code>_setupTableName()</code> method in your Table classes.
                One way to do this is to define an abstract class that extends
                Zend_Db_Table_Abstract, and then the rest of your tables
                extend your new abstract class.
            </para>

            <example id="zend.db.table.extending.inflection.example">
                <title>Example of an abstract table class that implements inflection</title>
                <programlisting role="php"><![CDATA[<?php

abstract class MyAbstractTable extends Zend_Db_Table_Abstract
{
    protected function _setupTableName()
    {
        if (!$this->_name) {
            $this->_name = myCustomInflector(get_class($this));
        }
        parent::_setupTableName();
    }
}

class BugsProducts extends MyAbstractTable
{
}]]></programlisting>
            </example>

            <para>
                You are responsible for writing the functions to
                perform inflection transformation.
                Zend Framework does not provide such a function.
            </para>

        </sect3>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
