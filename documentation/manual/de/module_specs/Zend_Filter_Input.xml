<sect1 id="zend.filter.input">
    <title>Zend_Filter_Input</title>

    <para>
        Zend_Filter_Input bietet ein ausgezeichnetes Interfave um mehrere Filter und Prüfer zu assoziieren, Sie
        Kollektionen von Daten hinzuzufügen, und Eingabewerte zu empfangen nachdem diese durch die Filter und
        Prüfer bearbeitet wurden. Werte werden standardmäßig in kommentiertem Format zurückgegeben für sichere
        HTML Ausgabe.
    </para>

    <para>
        Angenommen das diese Klasse ein Käfig für externe Daten ist. Daten betreten die Anwendung von externen
        Quellen, wie HTTP Anfrageparameter, HTTP Header, ein Web Service, oder sogar durch Lesen von eine Datenbank
        oder anderen Dateien. Daten werden zuerst in den Käfig gesperrt, und die Anwendung kann diese Daten nur dann
        Stück für Stück empfangen wenn dem Käfig gesagt wird, was diese Daten sein sollten und wie geplant ist diese
        zu verwenden. Der Käfig inspiziert die Daten auf Gültigkeit. Es kann passieren das er die Datenwerte
        kommentiert für den entsprechenden Kontext. Der Käfig entlässt die Daten nur wen diese alle
        Notwendigkeiten komplett erfüllen. Mit einem einzigen und bequemen Interface, wird gutes
        Programmierverhalten ermöglicht und es lässt Entwickler darüber nachdenken wie die Daten verwendet werden.
    </para>

    <itemizedlist>
        <listitem>
            <para>
                <emphasis role="strong">Filter</emphasis> wandeln Eingabewerte um, inden Sie Zeichen in dem Wert
                entfernen oder Ändern. Das Ziel ist es Eingabewerte zu "normalisieren" bis diese einem
                erwarteten Format entsprechen. Zum Beispiel, wenn ein String von nummerischen Zeichen benötigt wird,
                und der Eingabewert "abc123" ist dann könnte eine erwartete Umwandlung die Änderung des Wertes in
                den String "123" sein.
            </para>
        </listitem>
        <listitem>
            <para>
                <emphasis role="strong">Prüfer</emphasis> prüfen Eingabewerte gegenüber Kriterien und melden ob
                diese den Test bestanden haben oder nicht. Der Wert wird nicht geändert, aber die Prüfung kann
                fehlschlagen. Zum Beispiel, wenn ein String wie eine Email Adresse aussehen muß, und der Eingabewert
                "abc123" ist, dann wird der Wert als nicht gültig angenommen.
            </para>
        </listitem>
        <listitem>
            <para>
                <emphasis role="strong">Auskommentierer</emphasis> wandeln einen Wert um indem Sie magisches
                Verhalten von bestimmten Zeichen entfernen. In einigen Ausgabekontexten haben speziellen Zeichen
                eine Bedeutung. Zum Beispiel das Zeichen '&lt;' und '&gt;' begrenzen HTML Tags, und wenn ein String
                diese Zeichen enthält und in einem HTML Kontext ausgegeben wird, könnte der Inhalt zwischen Ihnen
                die Ausgabe oder Funktionalität der HTML Präsentation beeinflussen. Das auskommentieren der Zeichen
                entfernt die spezielle Bedeutung, damit Sie als literale Zeichen ausgegeben werden.
            </para>
        </listitem>
    </itemizedlist>

    <para>
        Um Zend_Filter_Input zu verwenden, müssen die folgenden Schritte unternommen werden:
    </para>

    <orderedlist numeration="arabic">
        <listitem>
            <para>
                Filter und Prüfregeln deklarieren
            </para>
        </listitem>
        <listitem>
            <para>
                Filter und Prüfbearbeiter erstellen
            </para>
        </listitem>
        <listitem>
            <para>
                Eingabedaten bereitstellen
            </para>
        </listitem>
        <listitem>
            <para>
                Geprüfte Felder und andere Reports erhalten
            </para>
        </listitem>
    </orderedlist>

    <para>
        Die folgenden Sektionen beschreiben die Schritte für die Verwendung dieser Klasse.
    </para>

    <sect2 id="zend.filter.input.declaring">

        <title>Filter und Prüfregeln deklarieren</title>

        <para>
            Vor der Erstellung einer Instanz von Zend_Filter_Input, muß ein Array von Filterregeln deklariert werden
            und auch ein Array von Prüfregeln. Dieses assoziative Array verbindet einen Regelnamen mit einem Filter
            oder Prüfer oder einer Kette von Filtern oder Prüfern.
        </para>

        <para>
            Das folgende Beispiel eines Sets von Filterregeln deklariert, daß das Feld 'month' von Zend_Filter_Digits
            gefiltert wird, und das Feld 'account' von Zend_Filter_StringTrim gefiltert wird. Anschließend wird
            ein Set von Prüfregeln deklariert welches prüft das das Feld 'account' nur dann gültig ist wenn es
            nur alphabetische Zeichen enthält.
        </para>

        <programlisting role="php"><![CDATA[<?php
$filters = array(
    'month'   => 'Digits',
    'account' => 'StringTrim'
);

$validators = array(
    'account' => 'Alpha'
);]]>
        </programlisting>

        <para>
            Jeder Schlüssel im obigen Array ist der Name einer Regel die auf einen Filter für ein spezielles
            Datenfeld angewendet wird. Standardmäßig, ist der Name der Regel auch der Name des Feldes der
            Eingabedaten auf die die Regel angewendet werden soll.
        </para>

        <para>
            Eine Regel kann in verschiedenen Formaten deklariert werden:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Ein einfacher skalarer String, der einem Klassennamen entspricht:
                    <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month'   => 'Digits',
);]]>
                    </programlisting>
                </para>
            </listitem>
            <listitem>
                <para>
                    Die Instanz eines Objektes einer der Klassen die Zend_Filter_Interface oder
                    Zend_Validate_Interface implementieren.
                    <programlisting role="php"><![CDATA[<?php
$digits = new Zend_Validate_Digits();

$validators = array(
    'month'   => $digits
);]]>
                    </programlisting>
                </para>
            </listitem>
            <listitem>
                <para>
                    Ein Array um eine Kette von Filtern oder Prüfern zu deklarieren. Die Elemente dieses Arrays
                    können Strings sein die Klassennamen entsprechen oder Filter/Prüfobjekte, wie in den oben
                    beschriebenen Fällen. Zusätzlich kann eine dritte Wahl verwendet werden: Ein Array das
                    einen String enthält der dem Klassennamen entspricht gefolgt von Argumenten die dessen
                    Konstruktor übergeben werden.

                    <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month'   => array(
        'Digits',                // String
        new Zend_Validate_Int(), // Objekt Instanz
        array('Between', 1, 12)  // String mit Konstruktor Argumenten
    )
);]]>
                    </programlisting>
                </para>
            </listitem>
        </itemizedlist>

        <note>
            <para>
                Wenn ein Filter oder Prüfer mit Konstruktor Argumenten in einem Array deklariert wird, muß ein Array
                für die Regel erstellt werden, selbst wenn die Regel nur einen Filter oder Prüfer enthält.
            </para>
        </note>

        <para>
            Es kann ein spezieller "Wildcard" Regelschlüssel <code>'*'</code>, entweder im Array des Filters oder im
            Array des Prüfers, verwendet werden. Das bedeutet das der Filter oder Prüfer der in dieser Regel
            deklariert wird allen Feldern der Eingabedaten zugewiesen wird. Es gilt zu beachten das die Reihenfolge
            der Einträge im Array des Filters oder im Array des Prüfers bedeutend ist; die Regeln werden in der
            gleichen Reihenfolge zugewiesen in dem diese deklariert wurden.
        </para>

        <programlisting role="php"><![CDATA[<?php
$filters = array(
    '*'     => 'StringTrim',
    'month' => 'Digits'
);]]>
        </programlisting>

    </sect2>

    <sect2 id="zend.filter.input.running">

        <title>Filter und Prüfbearbeiter erstellen</title>

        <para>
            Nachdem die Filter und Prüfarrays deklariert wurden, können diese als Argumente im Konstruktor von
            Zend_Filter_Input verwendet werden. Das gibt ein Objekt zurück welches alle Filter- und Prüfregeln
            kennt, und das verwendet werden kann um ein oder mehrere Sets von Eingabedaten zu bearbeiten.
        </para>

        <programlisting role="php"><![CDATA[<?php
$input = new Zend_Filter_Input($filters, $validators);]]>
        </programlisting>

        <para>
            Man kann Eingabedaten als drittes Argument im Konstruktor spezifizieren. Die Datenstruktur ist ein
            assoziatives Array. Die superglobalen Standardvariablen in PHP, <code>$_GET</code> und
            <code>$_POST</code>, sind Beispiele für dieses Format. Man kann jede dieser Variablen als Eingabedaten
            für Zend_Filter_Input verwenden.
        </para>

        <programlisting role="php"><![CDATA[<?php
$data = $_GET;

$input = new Zend_Filter_Input($filters, $validators, $data);]]>
        </programlisting>

        <para>
            Alternativ kann die <code>setData()</code> Methode verwendet werden, indem ein assoziatives Array von
            Schlüssel/Werte Paaren, im selben Format wie oben beschrieben, übergeben wird.
        </para>

        <programlisting role="php"><![CDATA[<?php
$input = new Zend_Filter_Input($filters, $validators);
$input->setData($newData);]]>
        </programlisting>

        <para>
            Die <code>setData()</code> Methode definiert Daten nocheinmal, in einem existierenden Zend_Filter_Input
            Objekt ohne die Filter- und Prüfregeln zu verändern. Wenn diese Methode verwendet wird können die selben
            Regeln, an anderen Sets von Eingabedaten, wieder verwendet werden.
        </para>

    </sect2>

    <sect2 id="zend.filter.input.results">

        <title>Geprüfte Felder und andere Reporte empfangen</title>

        <para>
            Nachdem Filter und Prüfer deklariert wurden und der Eingabeprozessor erstellt wurde, können Reporte von
            fehlenden, unbekannten und ungültigen Feldern empfangen werden. Man kann auch die Werte der Felder
            erhalten, nachdem die Filter angewendet wurden.
        </para>

        <sect3 id="zend.filter.input.results.isvalid">

            <title>Abfragen ob die Eingabe gültig ist</title>

            <para>
                Wenn alle Eingabedaten die Prüfregeln bestanden haben, gibt die <code>isValid()</code> Methode
                <code>true</code> zurück. Wenn irgendein Feld ungültig ist oder ein benötigtes Feld fehlt, gibt die
                <code>isValid()</code> Methode <code>false</code> zurück.
            </para>

            <programlisting role="php"><![CDATA[<?php
if ($input->isValid()) {
  echo "OK\n";
}]]>
            </programlisting>

            <para>
                Diese Methode akzeptiert ein optionales String Argument, das ein individuelles Feld benennt.
                Wenn das spezifizierte Feld die Prüfung passiert und bereit ist um abgeholt zu werden, gibt
                <code>isValid('fieldName')</code> den Wert <code>true</code> zurück.
            </para>

            <programlisting role="php"><![CDATA[<?php
if ($input->isValid('month')) {
  echo "Feld 'month' ist OK\n";
}]]>
            </programlisting>

        </sect3>

        <sect3 id="zend.filter.input.results.reports">

            <title>Ungültige, fehlende oder unbekannte Felder erhalten</title>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis role="strong">Ungültige</emphasis> Felder sind jene, die einen oder mehrere Ihrer
                        Prüfungen nicht bestehen.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="strong">Fehlende</emphasis> Felder sind jene die nicht in den
                        Eingabedaten vorhanden sind, aber im Metakommando <code>'presence'=>'required'</code>
                        (Siehe die <link linkend="zend.filter.input.metacommands.presence">spätere Sektion</link>
                        über Metakommandos) deklariert wurden.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="strong">Unbekannte</emphasis> Felder sind jene die in keiner einzigen Regel,
                        im Array der Prüfer, deklariert wurden, aber in den Eingabedaten vorkommen.
                    </para>
                </listitem>
            </itemizedlist>

            <programlisting role="php"><![CDATA[<?php
if ($input->hasInvalid() || $input->hasMissing()) {
  $messages = $input->getMessages();
}

// getMessages() gibt einfach die Zusammenfassung von getInvalid() und getMissing() zurück

if ($input->hasInvalid()) {
  $invalidFields = $input->getInvalid();
}

if ($input->hasMissing()) {
  $missingFields = $input->getMissing();
}

if ($input->hasUnknown()) {
  $unknownFields = $input->getUnknown();
}]]>
            </programlisting>

            <para>
                Das Ergebnis der <code>getMessages()</code> Methode ist ein assoziatives Array, das die Regelnamen
                einem Array von Fehlermeldungen, relativ zu diesen Regeln, zuordnet. Es ist anzumerken das der Index
                dieses Arrays der Name der Regel ist die in der Regeldeklaration verwendet wird, und welche
                von den Namen der Felder, die von der Regel geprüft werden, unterschiedlich sein kann.
            </para>

            <para>
                Die <code>getMessages()</code> Methode gibt eine Zusammenfassung der Arrays zurück die von
                <code>getInvalid()</code> und <code>getMissing()</code> retourniert werden. Diese Methoden geben
                Subsets der Nachrichten zurück, relativ zu den Prüffehlern, oder Felder die als benötigt deklariert
                wurden aber in der Eingabe fehlen.
            </para>

            <para>
                Die <code>getErrors()</code> Methode gibt ein assoziatives Array zurück, in dem die Regelnamen einem
                Array von Fehler Identifizierern entsprechen. Fehler Identifizierer sind fixe Strings, um Gründe für
                eine fehlgeschlagene Prüfung, zu identifizieren, wobei Nachrichten selbst geändert werden können.
                Siehe <xref linkend="zend.validate.introduction.using" /> für mehr Informationen.
            </para>

            <para>
                Die Nachricht die von <code>getMissing()</code> zurückgegeben wird kann als Argument beim
                Zend_Filter_Input Konstruktor, oder durch verwenden der <code>setOptions()</code> Methode,
                spezifiziert werden.
            </para>

            <programlisting role="php"><![CDATA[<?php
$options = array(
    'missingMessage' => "Feld '%field%' wird benötigt"
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);

// alternative Methode:

$input = new Zend_Filter_Input($filters, $validators, $data);
$input->setOptions($options);]]>
            </programlisting>

            <para>
                Das Ergebnis der <code>getUnknown()</code> Methode ist ein assoziatives Array, in dem die Feldnamen
                den Feldwerten zugeordnet werden. Feldnamen werden in diesem Fall als Arrayschlüssel verwendet, statt
                als Regelnamen, weil keine Regel die Feld erwähnt die unbekannte Felder sind.
            </para>

        </sect3>

        <sect3 id="zend.filter.input.results.escaping">

            <title>Gültige Felder bekommen</title>

            <para>
                Alle Felder die entweder ungültig, fehlend oder unbekannt sind, werden als gültig angenommen. Man
                kann Werte für diese Felder erhalten indem ein magischer Accessor verwendet wird. Es gibt auch die
                nicht-magische Accessor Methoden <code>getEscaped()</code> und <code>getUnescaped()</code>.
            </para>

            <programlisting role="php"><![CDATA[<?php
$m = $input->month;                 // Ausgabe vom magischen Accessor kommentieren
$m = $input->getEscaped('month');   // Ausgabe kommentieren
$m = $input->getUnescaped('month'); // nicht kommentieren]]>
            </programlisting>

            <para>
                Standardmäßig, wenn ein Wert empfangen wird, wird er mit Zend_Filter_HtmlEntities gefiltert. Das ist
                der Standard weil angenommen wird, das die am meisten übliche Verwendung, die Ausgabe von Werten von
                einem Feld in HTML ist. Der HtmlEntities Filter hilft ungewollten Ausgaben von Code vorzubeugen,
                welche zu Sicherheitsproblemen führen könnten.
            </para>

            <note>
                <para>
                    Wie oben gezeigt, kann man unkommentierte Werte erhalten undem die <code>getUnescaped()</code>
                    Methode verwendet wird, aber man muß dafür Code schreiben um die Werte sicher zu verwendetn, und
                    Sicherheitsprobleme, wie Verletzbarkeit für Seitenübergreifende Skript Attacken zu vermeiden.
                </para>
            </note>

            <para>
                Es kann ein anderer Filter für das auskommentieren von Werten definiert werden, durch seine
                Spezifikation im Array der Optionen des Konstruktors:
            </para>

            <programlisting role="php"><![CDATA[<?php
$options = array('escapeFilter' => 'StringTrim');
$input = new Zend_Filter_Input($filters, $validators, $data, $options);]]>
            </programlisting>

            <para>
                Alternativ kann die <code>setDefaultEscapeFilter()</code> Methode verwendet werden:
            </para>

            <programlisting role="php"><![CDATA[<?php
$input = new Zend_Filter_Input($filters, $validators, $data);
$input->setDefaultEscapeFilter(new Zend_Filter_StringTrim());]]>
            </programlisting>

            <para>
                Bei jeder Verwendung, kann der Kommentarfilter als String Basisname der Filterklasse, oder als
                Objektinstanz einer Filterklasse, spezifiziert werden. Der Kommentarfilter kann eine Instanz einer
                Filterkette, oder ein Objekt der Zend_Filter Klasse sein.
            </para>

            <para>
                Filter die Ausgaben kommentieren sollen auf diesen Weg ausgeführt werden, um sicherzustellen das
                Sie nach der Prüfung ausgeführt werden. Andere Filter, die im Array der Filterregeln deklariert
                werden, werden bei den Eingabedaten angewendet bevor diese Daten geprüft werden. Wenn
                Kommentarfilter vor der Prüfung ausgeführt werden, würde der Prozess der Prüfung viel komplexer sein
                um sowohl kommentierte als auch unkommentierte Versionen der Daten anzubieten. Deswegen wird
                empfohlen, Filter die Ausgaben mit <code>setDefaultEscapeFilter()</code> kommentieren, nicht im
                <code>$filters</code> Array zu deklarieren.
            </para>

            <para>
                Es gibt nur eine <code>getEscaped()</code> Methode, und deswegen kann nur ein Filter für das
                kommentieren spezifiziert werden (trotzdem kann dieser Filter eine Filterkette sein). Wenn eine
                einzelne Instanz von Zend_Filter_Input benötigt wird, um kommentierte Ausgaben zu erhalten, und
                mehr als eine Filtermethode angewendet werden soll, sollte Zend_Filter_Input erweitert werden und
                neue Methoden in der Subklasse implementiert werden um Wert auf unterschiedlichen Wegen zu erhalten.
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.filter.input.metacommands">

        <title>Metakommandos verwenden um Filter oder Prüfregeln zu kontrollieren</title>

        <para>
            Zusätzlich zum deklarieren der Übereinstimmungen von Feldern zu Filtern oder Prüfer, können einige
            "Metakommandos" in der Array Deklaration spezifiziert werden um einige optionale Verhaltensweisen von
            Zend_Filter_Input zu kontrollieren. Metakommandos treten als String-indizierte Einträge in einem
            gegebenen Filter- oder Prüfarray Wert auf.
        </para>

        <sect3 id="zend.filter.input.metacommands.fields">

            <title>Das <code>FIELDS</code> Metakommando</title>

            <para>
                Wenn der Name der Regel für einen Filter oder Prüfer anders lautet als das Feld in welchem er
                angewendet werden soll, kann der Feldname mit dem 'fields' Metakommando spezifiziert werden.
            </para>

            <para>
                Dieses Metakommando kann durch Verwendung der Klassenkonstanten <code>Zend_Filter_Input::FIELDS</code>
                statt der Angabe eines Strings spezifiziert werden.
            </para>

            <programlisting role="php"><![CDATA[<?php
$filters = array(
    'month' => array(
        'Digits',        // Namen als Integer Index [0] filtern
        'fields' => 'mo' // Namen als String Index ['fields'] filtern
    )
);]]>
            </programlisting>

            <para>
                Im obigen Beispiel wendet die Filterregel den 'digits' Filter am Eingabefeld, das 'mo' heißt, an.
                Der String 'month' wird einfach ein mnemonischer Schlüsselfür diese Filterregel; er wird nicht als
                Filtername verwendet wenn der Filter mit dem 'fields' Metakommando spezifiziert wird, aber er wird
                als Regelname verwendet.
            </para>

            <para>
                Der Standardwert des 'fields' Metakommandos ist der Index der aktuellen Regel. Im obigen Beispiel
                wird die Regel, wenn das 'fields' Metakommando nicht spezifiziert wird, auf das Eingabefeld das
                'month' heißt, angewendet.
            </para>

            <para>
                Eine weitere Verwendung des 'fields' Metakommandos ist es Felder für Filter oder Prüfer zu
                spezifizieren die mehrere Felder als Eingabe benötigen. Wenn das 'fields' Metakommando ein Array ist,
                ist das Argument des korrespondierenden Filters oder Prüfers ein Array mit den Werten dieser Felder.
                Zum Beispiel ist es für Benutzer üblich einen Passwort String in zwei Feldern zu spezifizieren, und
                diese müssen den selben String in beide Felder eingeben. Man kann zum Beispiel eine Prüfklasse
                implmentieren die ein Array Argument annimmt, und <code>true</code> zurückgibt wenn alle Werte im
                Array identisch zum jeweils anderen sind.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'password' => array(
        'StringEquals',
        'fields' => array('password1', 'password2')
    )
);
//  Inkludiert die hypotetische Klasse Zend_Validate_StringEquals, übergibt dieser ein Array Argument das
// den Wert der beiden Eingabe Datenfelder enthält die 'password1' und 'password2' heißen.]]>
            </programlisting>

            <para>
                Wenn die Prüfung dieser Regel fehlschlägt wird der Schlüssel der Regel (<code>'password'</code>)
                im Rückgabewert von <code>getInvalid()</code> verwendet und nicht eine der benannten Felder im
                'fields' Metakommando.
            </para>

        </sect3>

        <sect3 id="zend.filter.input.metacommands.presence">

            <title>Das <code>PRESENCE</code> Metakommando</title>

            <para>
                Each entry in the validator array may have a metacommand called
                'presence'.  If the value of this metacommand is 'required'
                then the field must exist in the input data, or else it is
                reported as a missing field.
            </para>

            <para>
                You can specify this metacommand using the class constant
                <code>Zend_Filter_Input::PRESENCE</code> instead of the
                string.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month' => array(
        'digits',
        'presence' => 'required'
    )
);]]>
            </programlisting>

            <para>
                The default value of this metacommand is 'optional'.
            </para>

        </sect3>

        <sect3 id="zend.filter.input.metacommands.default">

            <title>The <code>DEFAULT_VALUE</code> metacommand</title>

            <para>
                If a field is not present in the input data, and you specify a
                value for the 'default' metacommand for that rule, the field
                takes the value of the metacommand.
            </para>

            <para>
                You can specify this metacommand using the class constant
                <code>Zend_Filter_Input::DEFAULT_VALUE</code> instead of the
                string.
            </para>

            <para>
                This default value is assigned to the field before any of the
                validators are invoked.  The default value is applied to the
                field only for the current rule; if the same field is
                referenced in a subsequent rule, the field has no value when
                evaluating that rule.  Thus different rules can declare
                different default values for a given field.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month' => array(
        'digits',
        'default' => '1'
    )
);

// no value for 'month' field
$data = array();

$input = new Zend_Filter_Input(null, $validators, $data);
echo $input->month; // echoes 1]]>
            </programlisting>

            <para>
                If your rule uses the <code>FIELDS</code> metacommand
                to define an array of multiple fields, you can define
                an array for the <code>DEFAULT_VALUE</code> metacommand
                and the defaults of corresponding keys are used for any
                missing fields.  If <code>FIELDS</code> defines multiple
                fields but <code>DEFAULT_VALUE</code> is a scalar, then
                that default value is used as the value for any missing
                fields in the array.
            </para>

            <para>
                There is no default value for this metacommand.
            </para>

        </sect3>

        <sect3 id="zend.filter.input.metacommands.allow-empty">

            <title>The <code>ALLOW_EMPTY</code> metacommand</title>

            <para>
                By default, if a field exists in the input data, then
                validators are applied to it, even if the value of the field is
                an empty string (<code>''</code>).  This is likely to result in
                a failure to validate.  For example, if the validator checks
                for digit characters, and there are none because a zero-length
                string has no characters, then the validator reports the data
                as invalid.
            </para>

            <para>
                If in your case an empty string should be considered valid, you
                can set the metacommand 'allowEmpty' to <code>true</code>.
                Then the input data passes validation if it is present in the
                input data, but has the value of an empty string.
            </para>

            <para>
                You can specify this metacommand using the class constant
                <code>Zend_Filter_Input::ALLOW_EMPTY</code> instead of the
                string.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'address2' => array(
        'Alnum',
        'allowEmpty' => true
    )
);]]>
            </programlisting>

            <para>
                The default value of this metacommand is <code>false</code>.
            </para>

            <para>
                In the uncommon case that you declare a validation rule with
                no validators, but the 'allowEmpty' metacommand is
                <code>false</code> (that is, the field is considered invalid if
                it is empty), Zend_Filter_Input returns a default error message
                that you can retrieve with <code>getMessages()</code>.  You can
                specify this message using the 'notEmptyMessage' option, as an
                argument to the Zend_Filter_Input constructor or using the
                <code>setOptions()</code> method.
            </para>

            <programlisting role="php"><![CDATA[<?php
$options = array(
    'notEmptyMessage' => "A non-empty value is required for field '%field%'"
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);

// alternative method:

$input = new Zend_Filter_Input($filters, $validators, $data);
$input->setOptions($options);]]>
            </programlisting>

        </sect3>

        <sect3 id="zend.filter.input.metacommands.break-chain">

            <title>The <code>BREAK_CHAIN</code> metacommand</title>

            <para>
                By default if a rule has more than one validator, all
                validators are applied to the input, and the resulting messages
                contain all error messages caused by the input.
            </para>

            <para>
                Alternatively, if the value of the 'breakChainOnFailure'
                metacommand is <code>true</code>, the validator chain
                terminates after the first validator fails.  The input data is
                not checked against subsequent validators in the chain, so it
                might cause more violations even if you correct the one
                reported.
            </para>

            <para>
                You can specify this metacommand using the class constant
                <code>Zend_Filter_Input::BREAK_CHAIN</code> instead of the
                string.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month' => array(
        'Digits',
        new Zend_Validate_Between(1,12),
        new Zend_Validate_GreaterThan(0),
        'breakChainOnFailure' => true
    )
);
$input = new Zend_Filter_Input(null, $validators);]]>
            </programlisting>

            <para>
                The default value of this metacommand is <code>false</code>.
            </para>

            <para>
                The validator chain class, Zend_Validate, is more flexible with
                respect to breaking chain execution than Zend_Filter_Input.
                With the former class, you can set the option to break the
                chain on failure independently for each validator in the chain.
                With the latter class, the defined value of the
                'breakChainOnFailure' metacommand for a rule applies uniformly
                for all validators in the rule.  If you require the more
                flexible usage, you should create the validator chain yourself,
                and use it as an object in the validator rule
                definition:
            </para>

            <programlisting role="php"><![CDATA[<?php
// Create validator chain with non-uniform breakChainOnFailure attributes
$chain = new Zend_Validate();
$chain->addValidator(new Zend_Validate_Digits(), true);
$chain->addValidator(new Zend_Validate_Between(1,12), false);
$chain->addValidator(new Zend_Validate_GreaterThan(0), true);

// Declare validator rule using the chain defined above
$validators = array(
    'month' => $chain
);
$input = new Zend_Filter_Input(null, $validators);]]>
            </programlisting>

        </sect3>

        <sect3 id="zend.filter.input.metacommands.messages">

            <title>The <code>MESSAGES</code> metacommand</title>

            <para>
                You can specify error messages for each validator in a rule
                using the metacommand 'messages'.  The value of this metacommand
                varies based on whether you have multiple validators in the
                rule, or if you want to set the message for a specific error
                condition in a given validator.
            </para>

            <para>
                You can specify this metacommand using the class constant
                <code>Zend_Filter_Input::MESSAGES</code> instead of the
                string.
            </para>

            <para>
                Below is a simple example of setting the default error message
                for a single validator.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month' => array(
        'digits',
        'messages' => 'A month must consist only of digits'
    )
);]]>
            </programlisting>

            <para>
                If you have multiple validators for which you want to set the
                error message, you should use an array for the value of the
                'messages' metacommand.
            </para>

            <para>
                Each element of this array is applied to the validator at the
                same index position.  You can specify a message for the
                validator at position <emphasis>n</emphasis> by using the value
                <emphasis>n</emphasis> as the array index.  Thus you can allow
                some validators to use their default message, while setting the
                message for a subsequent validator in the chain.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month' => array(
        'digits',
        new Zend_Validate_Between(1, 12),
        'messages' => array(
            // use default message for validator [0]
            // set new message for validator [1]
            1 => 'A month value must be between 1 and 12'
        )
    )
);]]>
            </programlisting>

            <para>
                If one of your validators has multiple error messages, they are
                identified by a message key.  There are different keys in each
                validator class, serving as identifiers for error messages that
                the respective validator class might generate.  Each validate
                class defines constants for its message keys.  You can use
                these keys in the 'messages' metacommand by passing an
                associative array instead of a string.
            </para>

            <programlisting role="php"><![CDATA[<?php
$validators = array(
    'month' => array(
        'digits', new Zend_Validate_Between(1, 12),
        'messages' => array(
            'A month must consist only of digits',
            array(
                Zend_Validate_Between::NOT_BETWEEN =>
                    'Month value %value% must be between %min% and %max%',
                Zend_Validate_Between::NOT_BETWEEN_STRICT =>
                    'Month value %value% must be strictly between %min% and %max%'
            )
        )
    )
);]]>
            </programlisting>

            <para>
                You should refer to documentation for each validator class to
                know if it has multiple error messages, the keys of these
                messages, and the tokens you can use in the message templates.
            </para>

        </sect3>

        <sect3 id="zend.filter.input.metacommands.global">

            <title>Using options to set metacommands for all rules</title>

            <para>
                The default value for 'allowEmpty', 'breakChainOnFailure', and
                'presence' metacommands can be set for all rules using the
                <code>$options</code> argument to the constructor of
                Zend_Filter_Input.  This allows you to set the default value
                for all rules, without requiring you to set the metacommand for
                every rule.
            </para>

            <programlisting role="php"><![CDATA[<?php
// The default is set so all fields allow an empty string.
$options = array('allowEmpty' => true);

// You can override this in a rule definition,
// if a field should not accept an empty string.
$validators = array(
    'month' => array(
        'Digits',
        'allowEmpty' => false
    )
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);]]>
            </programlisting>

            <para>
                The 'fields', 'messages', and 'default' metacommands cannot be
                set using this technique.
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.filter.input.namespaces">

        <title>Adding Filter Class Namespaces</title>

        <para>
            By default, when you declare a filter or validator as a string,
            Zend_Filter_Input searches for the corresponding classes under
            the Zend_Filter or Zend_Validate namespaces.  For example,
            a filter named by the string 'digits' is found in the class
            Zend_Filter_Digits.
        </para>

        <para>
            If you write your own filter or validator classes, or use filters
            or validators provided by a third-party, the classes may exist in
            different namespaces than Zend_Filter or Zend_Validate.  You can
            tell Zend_Filter_Input to search more namespaces.  You can specify
            namespaces in the constructor options:
        </para>

        <programlisting role="php"><![CDATA[<?php
$options = array('namespace' => 'My_Namespace');
$input = new Zend_Filter_Input($filters, $validators, $data, $options);]]>
        </programlisting>

        <para>
            Alternatively, you can use the addNamespace() method:
        </para>

        <programlisting role="php"><![CDATA[<?php
$input->addNamespace('Other_Namespace');

// Now the search order is:
// 1. My_Namespace
// 2. Other_Namespace
// 3. Zend_Filter
// 4. Zend_Validate]]>
        </programlisting>

        <para>
            You cannot remove Zend_Filter and Zend_Validate as namespaces, you
            only can add namespaces.  User-defined namespaces are searched
            first, Zend namespaces are searched last.
        </para>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
