<sect1 id="zend.pdf.introduction">
    <!-- @todo review and revise upon completion of refactoring -->
    <title>Einführung</title>
    <para>
        Die Zend_Pdf Komponente ist ein komplett in PHP 5 geschriebenes Werkzeug für die Veränderung von 
        PDF (Portable Document Format) Dateien. Es kann bestehende Dokumente laden, neue Dokumente 
        erstellen, Dokumente modifizieren und modifizierte Dokumente speichern. Dadurch kann es jede
        PHP-getriebene Anwendung unterstützen, Dokumente im PDF Format dynamisch aufzubereiten,
        indem bestehende Vorlagen modifiziert oder Dokumente von Grund auf neu erstellt werden.
        Die Zend_Pdf Komponente stellt die folgenden Funktionen bereit: 
    <itemizedlist>
        <listitem>
            <para>
                Erstellen von neuen Dokumenten oder Laden von vorhandenen Dokumenten.
            <footnote>
                <para>
                PDF V1.4 (Acrobat 5) Dokumente werden für das Laden derzeit unterstützt.
                </para>
            </footnote>
            </para>
        </listitem>
        <listitem>
            <para>
                Rückgabe einer vorgegebenen Revision eines Dokuments.
            </para>
        </listitem>
        <listitem>
            <para>
                Verändern von Seiten innerhalb eines Dokuments. Ändern der Seitensortierung,
                Hinzufügen von neuen Seiten, Entfernen von Seiten aus einem Dokument.
            </para>
        </listitem>
        <listitem>
            <para>
                Verschiedene einfache Grafikelemente (Linien, Rechtecke, Polygon, Kreise, Ellipsen 
                und Kreisausschnitte).
            </para>
        </listitem>
        <listitem>
            <para>
                Zeichnen von Texten unter Verwendung eines von 14 eingebauten Standard Zeichensätzen
                oder deiner eigenen TrueType Zeichensätze.
            </para>
        </listitem>
        <listitem>
            <para>
            Drehungen.
            </para>
        </listitem>
        <listitem>
            <para>
                Zeichnen von Grafiken.
            <footnote>
                <para>
                JPG, PNG [Bis zu 8bit+Alpha] und TIFF Grafiken werden unterstützt.
                </para>
            </footnote>
            </para>
        </listitem>
        <listitem>
            <para>
                Schrittweise Aktualisierung von PDF Dateien.
            </para>
        </listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="zend.pdf.create">
    <title>Erstellen und Laden von PDF Dokumenten</title>
    <para>
        Die <code>Zend_Pdf</code> Klasse bildet das PDF Dokument selber ab und stellt 
        Funktionalitäten auf Dokumentebene bereit.
    </para>

    <para>
        Um ein neues Dokument zu stellen, sollte ein neues <code>Zend_Pdf</code> Objekt erstellt 
        werden.
    </para>

    <para>
        Die <code>Zend_Pdf</code> Klasse stellt zwei statische Methoden zum Laden von bestehenden
        PDF Dateien bereit. Dies sind die Methoden <code>Zend_Pdf::load()</code> und 
        <code>Zend_Pdf::parse()</code>. Beide geben als Ergebnis ein Zend_Pdf Objekt zurück oder
        werfen eine Ausnahme, wenn ein Fehler auftritt.
    </para>

    <example>
        <title>Erstellen und Laden von PDF Dokumenten</title>
        <programlisting role="php"><![CDATA[<?php
...
// Erstelle ein neues PDF Dokument
$pdf1 = new Zend_Pdf();

// Lade ein PDF Dokument aus einer Datei.
$pdf2 = Zend_Pdf::load($fileName);

// Lade ein PDF Dokument aus einer Zeichenkette.
$pdf3 = Zend_Pdf::parse($pdfString);
...
?>]]></programlisting>
    </example>

    <para>
        Das PDF Datei Format unterstützt die schrittweise Aktualisierung von Dokumenten. Jedes Mal,
        wenn ein Dokument aktualisiert wird, wird eine neue Revision des Dokuments erstellt. Die 
        Zend_Pdf Komponente unterstützt die Rückgabe einer vorgegebenen Revision des Dokuments.
    </para>
    <para>
        Die Revision kann den Methoden <code>Zend_Pdf::load()</code> and 
        <code>Zend_Pdf::parse()</code> als zweiter Parameter übergeben oder durch einen 
        <code>Zend_Pdf::rollback()</code>   
        <footnote>
            <para>
                Die <code>Zend_Pdf::rollback()</code> Methode muss vor einer Änderung eines 
                Dokuments aufgerufen werden. Ansonsten ist das Verhalten nicht definiert.
            </para>
        </footnote>
        Aufruf angefordert werden.
    </para>

    <example>
        <title>Rückgabe einer vorgegebenen Revision eines PDF Dokuments</title>
        <programlisting role="php"><![CDATA[<?php
...
// Lade die vorherige Revision des PDF Dokuments.
$pdf1 = Zend_Pdf::load($fileName, 1);

// Lade die vorherige Revision des PDF Dokuments.
$pdf2 = Zend_Pdf::parse($pdfString, 1);

// Lade die erste Revision des PDF Dokuments.
$pdf3 = Zend_Pdf::load($fileName);
$revisions = $pdf3->revisions();
$pdf3->rollback($revisions - 1);
...
?>]]></programlisting>
    </example>


</sect1>


<sect1 id="zend.pdf.save">
    <title>Änderungen von PDF Dokumenten speichern</title>
    <para>
        Es gibt zwei Methoden für das Speichern von Änderungen am PDF Dokument.
        Dies sind die Methoden <code>Zend_Pdf::save()</code> und <code>Zend_Pdf::render()</code>.
    </para>

    <para>
        Die <code>Zend_Pdf::save($filename, $updateOnly = false)</code> Methode speichert das
        PDF Dokument in einer Datei. Wenn $updateOnly auf true gesetzt wird, wird das neue PDF 
        Segment nur an die Datei angehängt, ansonsten wird die Datei überschrieben.
    </para>

    <para>
        Die <code>Zend_Pdf::render($newSegmentOnly = false)</code> Methode gibt das PDF
        Dokument als Zeichenkette zurück. Wenn $newSegmentOnly auf true gesetzt wird, wird nur das
        neue PDF Dateisegment zurückgegeben.
    </para>

    <example>
        <title>Speichern eines PDF Dokuments</title>
        <programlisting role="php"><![CDATA[<?php
...
// Lade das PDF Dokument.
$pdf = Zend_Pdf::load($fileName);
...
// Aktualisiere das Dokument
$pdf->save($fileName);
// Speichere das Dokument in eine neue Datei
$pdf->save($newFileName, true);

// Geb das PDF Dokument in einer Zeichenkette zurück.
$pdfString = $pdf->render();

...
?>]]></programlisting>
    </example>

</sect1>

<sect1 id="zend.pdf.pages">
    <title>Dokument Seiten</title>
    <para>
        Die Abstraktion von PDF Dokumentseiten wird durch die Klasse <code>Zend_Pdf_Page</code> 
        abgebildet.
    </para>

    <para>
        PDF Seiten werden entweder aus einem vorhandenen PDF gelesen oder erstellt.
    </para>

    <para>
        Neue Seiten können durch die Erstellung eines neuen <code>Zend_Pdf_Page</code> Objektes 
        oder durch den Aufruf der <code>Zend_Pdf::newPage()</code> Methode erhalten werden, die ein
        <code>Zend_Pdf_Page</code> Objekt zurückgibt. Der Unterschied ist, dass die 
        <code>Zend_Pdf::newPage()</code> Methode eine Seite erstellt, die bereits an das vorhandene
        Dokument angehängt worden ist. Im Gegensatz dazu können ungebundene Seiten bei verschiedenen 
        PDF Dokumenten verwendet werden und sind ein wenig performanter
    <footnote>
        <para>
            Dies ist eine Einschränkung der V1.0 Version der Zend_Pdf Komponente. Sie wird in 
            zukünftigen Versionen beseitigt werden. Aber ungebundene Seiten werden immer ein 
            besseres (also optimaleres) Ergebnis für gemeinsame Benutzung in Dokumenten liefern. 
        </para>
    </footnote>. Du hast die Wahl, welche Vorgehensweise verwendet werden sollte.
    </para>

    <para>
        Die <code>Zend_Pdf::newPage()</code> Methode und der <code>Zend_Pdf_Page</code> Konstruktor
        benötigen die gleichen Parameter. Das ist entweder die Seitengröße ($x, $y) in Punkten 
        (1/72 Zoll) oder eine vordefinierte Konstante, die als Seitentyp verwendet wird:
        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Page::SIZE_A4</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Page::SIZE_A4_LANDSCAPE</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Page::SIZE_LETTER</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Page::SIZE_LETTER_LANDSCAPE</para>
            </listitem>
        </itemizedlist>
    </para>

    <para>
        Dokumentseiten werden in der öffentlichen Eigenschaft <code>$pages</code> der 
        <code>Zend_Pdf</code> Klasse abgelegt. Dies ist ein Array mit <code>Zend_Pdf_Page</code>
        Objekten. Es definiert den Satz und die Reihenfolge der Dokumentseiten und kann
        wie ein normales Array verändert werden:
    </para>

    <example>
        <title>Verwaltung von PDF Dokumentseiten</title>
        <programlisting role="php"><![CDATA[<?php
...
// Umgekehrte Seitenreihenfolge
$pdf->pages = array_reverse($pdf->pages);
...
// Füge eine neue Seite hinzu
$pdf->pages[] = new Zend_Pdf_Page(Zend_Pdf_Page::SIZE_A4);
// Füge eine neue Seite hinzu
$pdf->pages[] = $pdf->newPage(Zend_Pdf_Page::SIZE_A4);

// Entferne eine bestimmte Seite
unset($pdf->pages[$id]);

...
?>]]></programlisting>
    </example>

</sect1>

<sect1 id="zend.pdf.drawing">
    <title>Zeichnen</title>

    <sect2 id="zend.pdf.drawing.geometry">
        <title>Geometrie</title>
        <para>
            PDF verwendet die selbe Geometrie wie PostScript. Sie beginnt an der linken unteren 
            Ecke der Seite und wird in Punkten (1/72 Zoll) gemessen.
        </para>
        <para>
            Die Seitengröße kann vom Seitenobjekt erhalten werden:
        </para>
            <programlisting role="php"><![CDATA[
$width  = $pdfPage->getWidth();
$height = $pdfPage->getHeight();]]>
            </programlisting>
    </sect2>

    <sect2 id="zend.pdf.drawing.color">
        <title>Farben</title>
        <para>
            PDF bietet leistungsfähige Möglichkeiten für die Farbdarstellung. Die Zend_Pdf 
            Komponente unterstützt die Grauskala sowie RGB und CYMK Farbräume. Jede kann überall 
            verwendet werden, wo ein <code>Zend_Pdf_Color</code> Objekt benötigt wird. Die 
            <code>Zend_Pdf_Color_GrayScale</code>, <code>Zend_Pdf_Color_RGB</code> und
            <code>Zend_Pdf_Color_CMYK</code> Klassen stellen folgende Funktionalitäten bereit:
        </para>
            <programlisting role="php"><![CDATA[
// $grayLevel (Fließkommazahl). 0.0 (schwarz) - 1.0 (weiß)
$color1 = new Zend_Pdf_Color_GrayScale($grayLevel);

// $r, $g, $b (Fließkommazahlen). 0.0 (minimale Helligkeit) - 1.0 (maximale Helligkeit)
$color2 = new Zend_Pdf_Color_RGB($r, $g, $b);

// $c, $m, $y, $k (Fließkommazahlen). 0.0 (minimale Helligkeit) - 1.0 (maximale Helligkeit)
$color3 = new Zend_Pdf_Color_CMYK($c, $m, $y, $k);]]>
            </programlisting>
    </sect2>

    <sect2 id="zend.pdf.drawing.shape-drawing">
        <title>Zeichnen von Formen</title>
        <para>
            Alle Zeichenoperationen können im Kontext einer PDF Seite durchgeführt werden.
        </para>
        <para>
            Die <code>Zend_Pdf_Page</code> Klass stellt einen Satz von einfachen Formen bereit:
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Zeichne eine Linie von x1,y1 nach x2,y2.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function drawLine($x1, $y1, $x2, $y2);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Zeichne ein Rechteck.
 *
 * Füllarten:
 * Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - fülle und strichele das Rechteck (Standard)
 * Zend_Pdf_Page::SHAPE_DRAW_STROKE      - strichele das Rechteck
 * Zend_Pdf_Page::SHAPE_DRAW_FILL        - fülle das Rechteck
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param integer $fillType
 */
public function drawRectangle($x1, $y1, $x2, $y2, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Zeichne ein Polygon
 *
 * Wenn $fillType Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE oder Zend_Pdf_Page::SHAPE_DRAW_FILL ist,
 * wird das Polygon automatisch geschlossen.
 * Für eine detaillierte Beschreibung dieser Methode schaue in eine PDF Dokumentation
 * (Kapitel 4.4.2 Path painting Operators, Filling)
 *
 * @param array $x  - Array mit Floats (die X Koordinaten der Eckpunkte)
 * @param array $y  - Array mit Floats (the Y Koordinaten der Eckpunkte)
 * @param integer $fillType
 * @param integer $fillMethod
 */
public function drawPolygon($x, $y,
                            $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE,
                            $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Zeichne einen Kreis mit dem Mittelpunkt x, y dem Radius radius.
 *
 * Winkel werden im Bogenmaß angegeben
 *
 * Methoden Signaturen:
 * drawCircle($x, $y, $radius);
 * drawCircle($x, $y, $radius, $fillType);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle, $fillType);
 *
 *
 * Es ist kein echter Kreis, weil PDF nur kubische Bezierkurven unterstützt.
 * Aber es ist eine sehr Annäherung.
 * Es unterscheidet sich von echten Kreisen maximal um 0.00026 Radien
 * (Bei PI/8, 3*PI/8, 5*PI/8, 7*PI/8, 9*PI/8, 11*PI/8, 13*PI/8 und 15*PI/8 Winkeln).
 * Bei 0, PI/4, PI/2, 3*PI/4, PI, 5*PI/4, 3*PI/2 und 7*PI/4 ist es exakt eine Tangente zu einem Kreis.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param mixed $param4
 * @param mixed $param5
 * @param mixed $param6
 */
public function  drawCircle($x, $y, $radius, $param4 = null, $param5 = null, $param6 = null);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Zeichne eine Ellipse innerhalb des angegebenen Rechtecks.
 *
 * Methoden Signaturen:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $fillType);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle, $fillType);
 *
 * Winkel werden im Bogenmaß angegeben
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param mixed $param5
 * @param mixed $param6
 * @param mixed $param7
 */
public function drawEllipse($x1, $y1, $x2, $y2, $param5 = null, $param6 = null, $param7 = null);]]>
            </programlisting>
    </sect2>

    <sect2 id="zend.pdf.drawing.text-drawing">
        <title>Zeichnen von Text</title>
        <para>
            Auch alle Textoperationen können im Kontext einer PDF Seite durchgeführt werden. Du 
            kannst eine einzige Textzeile an jeder Position auf der Seite durch Übergabe der X und
            Y Koordinaten für die Grundlinie zeichnen. Der aktuelle Zeichensatz und die aktuelle
            Zeichengröße werden für die Textoperationen verwendet (beachte die detaillierte 
            Beschreibung unten).
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Zeichne eine Textzeile an einer bestimmten Position.
 *
 * @param string $text
 * @param float $x
 * @param float $y
 * @param string $charEncoding (optional) Zeichencodierung des Quelltexts.
 *          Standard ist die aktuelle "locale".
 * @throws Zend_Pdf_Exception
 */
public function drawText($text, $x, $y, $charEncoding = '');]]>
            </programlisting>
        <example>
            <title>Zeichne einen String auf der Seite.</title>
            <programlisting role="php"><![CDATA[<?php
...
$pdfPage->drawText('Hello world!', 72, 720);
...
?>]]>
            </programlisting>
        </example>
        <para>
            Standardmäßig werden Textstrings unter Verwendung der Zeichenkodierungsmethode der 
            aktuelle "locale" interpretiert. Wenn du einen String hast, der eine andere 
            Zeichenkodierungsmethode verwendet (wie zum Beispiel ein UTF-8 String, der aus einer
            Datei auf der Platte gelesen wurde, oder ein MacRoman String, der aus einer älteren
            Datenbank erhalten wurde), kannst du die Zeichenkodierung zum Zeitpunkt des Zeichnens 
            angeben und Zend_Pdf wird die Konvertierung für dich durchführen. Du kannst Quellstrings
            in jeder Kodierungsmethode übergeben, die von PHP's 
            <code><ulink url="http://www.php.net/manual/function.iconv.php">iconv()</ulink></code>
            Funktion unterstützt wird.
        </para>
        <example>
            <title>Zeiche einen UTF-8 kodierten String auf der Seite.</title>
            <programlisting role="php"><![CDATA[<?php
...
// Lese einen UTF-8 kodierten String von der Platte
$unicodeString = fread($fp, 1024);

// Zeichne den String auf der Seite
$pdfPage->drawText($unicodeString, 72, 720, 'UTF-8');
...
?>]]>
            </programlisting>
        </example>
    </sect2>

    <sect2 id="zend.pdf.drawing.using-fonts">
        <title>Verwendung von Zeichensätzen</title>
        <para>
            <code>Zend_Pdf_Page::drawText()</code> verwendet den aktuellen Zeichensatz und die 
            aktuelle Zeichengröße der Seite, die mit der Methode <code>Zend_Pdf_Page::setFont()</code> 
            festgelegt werden:
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Lege den aktuellen Zeichensatz fest.
 *
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);]]>
            </programlisting>
        <para>
            PDF Dokumente unterstützt PostScript Type1 und TrueType Zeichensätze, sowie die zwei 
            speziellen PDF Typen Type3 und zusammengesetzte Zeichensätze (composite fonts). Es gibt 
            zudem 14 Type1 Standardzeichensätze, die von jedem PDF Viewer bereit gestellt werden:
            Courier (4 Stile), Helvetica (4 Stile), Times (4 Stile), Symbol und Zapf Dingbats. 
        </para>
        <para>
            Die Zend_Pdf Komponente unterstützt derzeit diese 14 Standardzeichensätze sowie deine 
            eigenen TrueType Zeichensätze. Zeichensatzobjekte können über eine der zwei 
            Fabrikmethoden (factory methods) erhalten werden: 
            <code>Zend_Pdf_Font::fontWithName($fontName)</code> für die 14 PDF Standardzeichensätze
            oder <code>Zend_Pdf_Font::fontWithPath($filePath)</code> für eigene Zeichensätze.
        </para>
        <example>
            <title>Erstelle einen Standardzeichensatz</title>
            <programlisting role="php"><![CDATA[<?php
...
// Erstelle einen neuen Zeichensatz
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA);

// Wende Zeichensatz an
$pdfPage->setFont($font, 36);
...
?>]]>
            </programlisting>
        </example>
        <para>
            Die Zeichensatzkonstanten für die 14 Standardzeichensätze sind innerhalb der 
            <code>Zend_Pdf_Font</code> Klasse definiert:
        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Font::FONT_COURIER</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_COURIER_BOLD</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_COURIER_ITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_COURIER_BOLDITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_TIMES_ROMAN</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_TIMES_BOLD</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_TIMES_ITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_TIMES_BOLDITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_HELVETICA</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_HELVETICA_BOLD</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_HELVETICA_ITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_HELVETICA_BOLDITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_SYMBOL</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Font::FONT_ZAPFDINGBATS</para>
            </listitem>
        </itemizedlist>
        </para>
        <para>
            Du kannst außerdem jeden individuellen TrueType Zeichensatz (welcher normalerweise eine
            '.ttf' Erweiterung hat) oder einen OpenType Zeichensatz ('.otf' Erweiterung) verwenden,
            wenn er TrueType Konturen enthält. Bisher nicht unterstützt, aber für zukünftige 
            Versionen geplant, sind Mac OS X .dfont Dateien und Microsoft TrueType Collection
            ('.ttc' Erweiterung) Dateien. 
        </para>
        <para>
            Um einen TrueType Zeichensatz zu verwenden, mußt du den kompletten Verzeichnispfad zum
            Zeichensatzprogramm angeben. Wenn der Zeichensatz aus welchem Grund auch immer nicht 
            gelesen werden kann oder wenn es kein TrueType Zeichensatz ist, wird the Fabrikmethode
            eine Ausnahme werfen:
        </para>
        <example>
            <title>Erstelle einen TrueType Zeichensatz.</title>
            <programlisting role="php"><![CDATA[<?php
...
// Erstelle einen neuen Zeichensatz
$goodDogCoolFont = Zend_Pdf_Font::fontWithPath('/path/to/GOODDC__.TTF');

// Verwende den Zeichensatz
$pdfPage->setFont($goodDogCoolFont, 36);
...
?>]]>
            </programlisting>
        </example>
        <para>
            Standardmäßig werden eigene Zeichensätze in das erstellte PDF Dokument eingebettet. Dies
            ermöglicht den Empfänger, die Seite wie beabsichtigt anzuschauen, sogar wenn sie den 
            entsprechenden Zeichensatz auf ihrem System gar nicht installiert haben. Wenn du dich
            über die Dateigröße sorgst, kannst du angeben, dass das Zeichensatzprogramm nicht
            eingebettet wird, indem du eine 'nicht einbetten' Option an die Fabrikmethode übergibst:
        </para>
        <example>
            <title>Erstelle einen TrueType Zeichensatz, aber bette ihn nicht in das PDF Dokument ein.</title>
            <programlisting role="php"><![CDATA[<?php
...
// Erstelle einen neuen Zeichensatz
$goodDogCoolFont = Zend_Pdf_Font::fontWithPath('/path/to/GOODDC__.TTF',
                                               Zend_Pdf_Font::EMBED_DONT_EMBED);

// Verwende den Zeichensatz
$pdfPage->setFont($goodDogCoolFont, 36);
...
?>]]>
            </programlisting>
        </example>
        <para>
            Wenn das Zeichensatzprogramm nicht eingebettet wurde, aber den Empfänger der PDF Datei
            diesen Zeichensatz auf seinem System installiert hat, wird er das Dokument so sehen wie
            beabsichtigt. Wenn sie nicht den korrekten Zeichensatz installiert haben, wird der PDF
            Viewer sich bemühen, um einen Ersatz herzustellen.
        </para>
        <para>
            Einige Zeichensätze haben sehr spezielle Lizensierungsregeln, die das Einbetten in PDF
            Dokumente verhindern. Damit du dadurch nicht überrascht wirst, wenn du versuchst einen
            Zeichensatz einzubetten, der nicht eingebettet werden kann, wird die Fabrikmethode eine
            Ausnahme werfen.
        </para>
        <para>
            Du kannst diese Zeichensätze weiterhin verwenden, aber du mußt entweder die 'nicht 
            einbetten' Option übergeben wie oben beschrieben oder du kannst einfach die Ausnahme 
            unterdrücken:
        </para>
        <example>
            <title>Werfe keine Ausnahme für Zeichensätze, die nicht eingebettet werden können.</title>
            <programlisting role="php"><![CDATA[<?php
...
$font = Zend_Pdf_Font::fontWithPath('/path/to/unEmbeddableFont.ttf',
                                    Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION);
...
?>]]>
            </programlisting>
        </example>
        <para>
            Diese Unterdrückungstechnik wird bevorzugt, wenn du einen Endnutzer erlaubst, seine 
            eigenen Zeichensätze auszuwählen. Zeichensätze, die in ein PDF Dokument eingebettet 
            werden können, werden eingebettet, andere nicht.
        </para>
        <para>
            Zeichensatzprogramme können sehr groß sein, manche erreichen Dutzende von Megabytes.
            Standardmäßig werden alle eingebetteten Zeichensätze unter Verwendung des Flate
            Kompressionsschemas komprimiert, woraus im Schnitt 50% an Speicherplatz gespart werden
            kann. Wenn du aus welchem Grund auch immer nicht möchtest, dass das Zeichensatzprogramm
            kompimiert wird, kannst du dies mit einer Option abschalten:
        </para>
        <example>
            <title>Komprimiere einen eingebetten Zeichensatz nicht.</title>
            <programlisting role="php"><![CDATA[<?php
...
$font = Zend_Pdf_Font::fontWithPath('/path/to/someReallyBigFont.ttf',
                                    Zend_Pdf_Font::EMBED_DONT_COMPRESS);
...
?>]]>
            </programlisting>
        </example>
        <para>
            Zuguterletzt, kannst du die Einbettungsoptionen mit Hilfe des OR Operators kombinieren,
            wenn notwendig:
        </para>
        <example>
            <title>Kombiniere die Zeichensatz Einbettungsoptionen.</title>
            <programlisting role="php"><![CDATA[<?php
...
$font = Zend_Pdf_Font::fontWithPath($someUserSelectedFontPath,
                                    (Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION |
                                     Zend_Pdf_Font::EMBED_DONT_COMPRESS));
...
?>]]>
            </programlisting>
        </example>

    </sect2>

    <sect2 id="zend.pdf.drawing.image-drawing">
        <title>Zeichnen von Grafiken</title>
        <para>
            Die <code>Zend_Pdf_Page</code> Klasse stellt die drawImage() Methode für das Zeichnen
            von Grafiken bereit:
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Zeichne eine Grafik an der angegebenen Position der Seite.
 *
 * @param Zend_Pdf_Image $image
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function drawImage(Zend_Pdf_Image $image, $x1, $y1, $x2, $y2);]]>
            </programlisting>
        <para>
            Grafikobjekte werden durch Ableitungen der <code>Zend_Pdf_Image</code> Klasse 
            abgebildet.
        </para>
        <para>
            Es werden zur Zeit JPG, PNG und TIFF Grafiken unterstützt:
        </para>
        <example>
            <title>Zeichnen von Grafiken</title>
            <programlisting role="php"><![CDATA[<?php
...
// Erstelle ein Grafikobjekt direkt (wähle eines aus)
$image = new Zend_Pdf_Image_JPEG('my_image.jpg');
$image = new Zend_Pdf_Image_TIFF('my_image.tiff');
$image = new Zend_Pdf_Image_PNG('my_image.png');

// oder verwende Zend_Pdf_ImageFactory um den entsprechenden Typ zu laden
$image = Zend_Pdf_ImageFactory::factory('my_image.jpg');

$pdfPage->drawImage($image, 100, 100, 400, 300);
...
?>]]>
            </programlisting>
        </example>

        <para>
            <emphasis>Wichtig! Die Zend_Pdf_Image_JPEG Klasse setzt voraus, dass die GD 
            Erweiterung für PHP konfiguriert wurde.</emphasis>
            <emphasis>Wichtig! Die Zend_Pdf_Image_PNG Klasse setzt voraus, dass die ZLIB 
            Erweiterung konfiguriert wurde, um mit Grafiken mit Alphakanal zu arbeiten.</emphasis>
        </para>
        <para>
            Wende dich an die PHP Dokumentation für weitere Informationen
            (<ulink url="http://www.php.net/manual/en/ref.image.php">http://www.php.net/manual/en/ref.image.php</ulink>).
            (<ulink url="http://www.php.net/manual/en/ref.zlib.php">http://www.php.net/manual/en/ref.zlib.php</ulink>).
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.line-drawing-style">
        <title>Stil der Strichzeichnungen</title>
        <para>
            Der Stil der Strichzeichnungen wurd durch die Linienbreite, die Linienfarbe und das
            Strichmuster definiert. Alle diese Parameter können an die Klassenmethoden von 
            <code>Zend_Pdf_Page</code> übergeben werden:
        </para>
            <programlisting role="php"><![CDATA[
/** Setze die Linienfarbe. */
public function setLineColor(Zend_Pdf_Color $color);

/** Setze die Linienbreite. */
public function setLineWidth(float $width);

/**
 * Setze das Strichmuster.
 *
 * Pattern ist ein Array mit Fließkommazahlen: array(on_length, off_length, on_length, off_length, ...)
 * Phase is shift from the beginning of line.
 *
 * @param array $pattern
 * @param array $phase
 */
public function setLineDashingPattern($pattern, $phase = 0);]]>
            </programlisting>
    </sect2>

    <sect2 id="zend.pdf.drawing.fill-style">
        <title>Füllstil</title>
        <para>
            Die Methoden <code>Zend_Pdf_Page::drawRectangle()</code>, 
            <code>Zend_Pdf_Page::drawPolygon()</code>, <code>Zend_Pdf_Page::drawCircle()</code> und 
            <code>Zend_Pdf_Page::drawEllipse()</code> akzeptieren das <code>$fillType</code> 
            Argument als optionalen Parameter. Es kann lauten:
        </para>

        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Page::SHAPE_DRAW_STROKE - strichele die Form</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Page::SHAPE_DRAW_FILL - fülle die Form</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - fülle und strichele die Form 
                (Standardverhalten)</para>
            </listitem>
        </itemizedlist>

        <para>
            Die <code>Zend_Pdf_Page::drawPolygon()</code> Methode akzeptiert 
            <code>$fillMethod</code> als zusätzlichen Parameter:
        </para>
        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING (Standardverhalten)</para>
                <para>
                <citetitle>Die PDF Referenz</citetitle> beschreibt diese Regel wie folgt:
                <blockquote>
The nonzero winding number rule determines whether a given point is inside a
path by conceptually drawing a ray from that point to infinity in any direction
and then examining the places where a segment of the path crosses the ray. Starting
with a count of 0, the rule adds 1 each time a path segment crosses the ray
from left to right and subtracts 1 each time a segment crosses from right to left.
After counting all the crossings, if the result is 0 then the point is outside the path;
otherwise it is inside.

Note: The method just described does not specify what to do if a path segment coincides
with or is tangent to the chosen ray. Since the direction of the ray is arbitrary,
the rule simply chooses a ray that does not encounter such problem intersections.
For simple convex paths, the nonzero winding number rule defines the inside
and outside as one would intuitively expect. The more interesting cases are those
involving complex or self-intersecting paths like the ones shown in Figure 4.10
(in a PDF Reference).

For a path consisting of a five-pointed star, drawn with five connected straight
line segments intersecting each other, the rule considers the inside to be the entire
area enclosed by the star, including the pentagon in the center. For a path composed
of two concentric circles, the areas enclosed by both circles are considered
to be inside, provided that both are drawn in the same direction. If the circles are
drawn in opposite directions, only the "doughnut" shape between them is inside,
according to the rule; the "doughnut hole" is outside.
            </blockquote>
            </para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Page::FILL_METHOD_EVEN_ODD</para>
                <para>
                <citetitle>Die PDF Referenz</citetitle> beschreibt diese Regel wie folgt:
                <blockquote>
An alternative to the nonzero winding number rule is the even-odd rule. This rule
determines the "insideness" of a point by drawing a ray from that point in any
direction and simply counting the number of path segments that cross the ray,
regardless of direction. If this number is odd, the point is inside; if even, the point
is outside. This yields the same results as the nonzero winding number rule for
paths with simple shapes, but produces different results for more complex
shapes.

Figure 4.11 (in a PDF Reference) shows the effects of applying the even-odd rule
to complex paths. For the five-pointed star, the rule considers the triangular
points to be inside the path, but not the pentagon in the center. For the two
concentric circles, only the "doughnut" shape between the two circles is considered inside,
regardless of the directions in which the circles are drawn.
                </blockquote>
            </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.pdf.drawing.rotations">
        <title>Drehungen</title>
        <para>
            Bevor eine Zeichenoperation angewendet wird, können PDF Seiten gedreht werden. Dies 
            kann mit Hilfe der <code>Zend_Pdf_Page::rotate()</code> Methode durchgeführt werden:
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Drehe die Seite um den Punkt ($x, $y) mit dem angegebenen Winkel (im Bogenmaß).
 *
 * @param float $angle
 */
public function rotate($x, $y, $angle);]]>
            </programlisting>
    </sect2>

    <sect2 id="zend.pdf.drawing.save-restore">
        <title>Speichern/Wiederherstellen des Grafikzustand</title>
        <para>
            Jederzeit kann der Grafikzustand der Seite (aktueller Zeichensatz, Schriftgröße, 
            Linienfarbe, Füllfarbe, Linienstil, Seitendrehung, Zeichenbereich) gespeichert und 
            wiederhergestellt werden. Speicheroperationen legen die Daten auf einen Grafikzustand 
            Stapel, Wiederherstelloperationen holen Sie daher zurück. 
        </para>
        <para>
            In der <code>Zend_Pdf_Page</code> Klasse gibt es für diese Operationen zwei Methoden:
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Speichere den Grafikzustand dieser Seite.
 * Es wir ein Schnappschuss vom aktuell festgelegten Stil, Position, Zeichenbereich und
 * jeder festgelegten Drehung/Umrechnung/Skalierung erstellt.
 */
public function saveGS();

/**
 * Stelle den Grafikzustand wieder her, der mit dem letzten Aufruf von saveGS() gespeichert wurde.
 */
public function restoreGS();]]>
            </programlisting>
    </sect2>

    <sect2 id="zend.pdf.drawing.clipping">
        <title>Zeichenbereich</title>
        <para>
            PDF und die Zend_Pdf Komponente unterstützen die Begrenzung des Zeichenbereichs. Der
            aktuelle Zeichenbereich begrenzt den Seitenbereich, der von Zeichenoperationen 
            beeinflusst werden kann. Zu Beginn ist dies die gesamte Seite.
        </para>
        <para>
            Die <code>Zend_Pdf_Page</code> Klasse stellt einen Satz von Methoden für die Begrenzung
            bereit.
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Durchschneide den aktuellen Zeichenbereich mit einem Rechteck.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function clipRectangle($x1, $y1, $x2, $y2);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Durchschneide den aktuellen Zeichenbereich mit einem Polygon.
 *
 * @param array $x  - Array mit Floats (die X Koordinaten der Eckpunkte)
 * @param array $y  - Array mit Floats (die Y Koordinaten der Eckpunkte)
 * @param integer $fillMethod
 */
public function clipPolygon($x, $y, $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Durchschneide den aktuellen Zeichenbereich mit einem Kreis.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param float $startAngle
 * @param float $endAngle
 */
public function clipCircle($x, $y, $radius, $startAngle = null, $endAngle = null);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Durchschneide den aktuellen Zeichenbereich mit einer Ellipse.
 *
 * Methoden Signaturen:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 *
 * @todo verarbeite die Sonderfälle mit $x2-$x1 == 0 oder $y2-$y1 == 0
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param float $startAngle
 * @param float $endAngle
 */
public function clipEllipse($x1, $y1, $x2, $y2, $startAngle = null, $endAngle = null);]]>
            </programlisting>
    </sect2>

    <sect2 id="zend.pdf.drawing.styles">
        <title>Stile</title>
        <para>
            Die <code>Zend_Pdf_Style</code> Klasse stellt Stilfunktionalitäten bereit.
        </para>
        <para>
            Stile können verwendet werden, um mit einer Operation die Parameter für den 
            Grafikzustand zu speichern und auf eine PDF Seite anzuwenden:
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Lege den Stil für zukünftige Zeichenoperationen auf dieser Seite fest
 *
 * @param Zend_Pdf_Style $style
 */
public function setStyle(Zend_Pdf_Style $style);

/**
 * Gebe den Stil der Seite zurück.
 *
 * @return Zend_Pdf_Style|null
 */
public function getStyle();]]>
            </programlisting>

        <para>
            Die <code>Zend_Pdf_Style</code> Klasse stellt einen Satz von Methoden bereit, um 
            verschiedene Parameter des Grafikstadiums zu setzen und zu holen:
        </para>
            <programlisting role="php"><![CDATA[
/**
 * Setze die Linienfarbe.
 *
 * @param Zend_Pdf_Color $color
 */
public function setLineColor(Zend_Pdf_Color $color);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Hole die Linienfarbe.
 *
 * @return Zend_Pdf_Color|null
 */
public function getLineColor();]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Setze die Linienbreite.
 *
 * @param float $width
 */
public function setLineWidth($width);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Hole die Linienbreite.
 *
 * @return float
 */
public function getLineWidth();]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Setze das Strichmuster
 *
 * @param array $pattern
 * @param float $phase
 */
public function setLineDashingPattern($pattern, $phase = 0);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Hole das Strichmuster
 *
 * @return array
 */
public function getLineDashingPattern();]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Get line dashing phase
 *
 * @return float
 */
public function getLineDashingPhase();]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Setze die Füllfarbe
 *
 * @param Zend_Pdf_Color $color
 */
public function setFillColor(Zend_Pdf_Color $color);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Hole die Füllfarbe.
 *
 * @return Zend_Pdf_Color|null
 */
public function getFillColor();]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Ändere den Zeichensatz.
 *
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Ändere die Schriftgröße
 *
 * @param float $fontSize
 */
public function setFontSize($fontSize);]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Hole den Zeichensatz.
 *
 * @return Zend_Pdf_Resource_Font $font
 */
public function getFont();]]>
            </programlisting>
            <programlisting role="php"><![CDATA[
/**
 * Hole die Schriftgröße
 *
 * @return float $fontSize
 */
public function getFontSize();]]>
            </programlisting>
    </sect2>

</sect1>

<sect1 id="zend.pdf.usage">
    <title>Anwendungsbeispiel für die Zend_Pdf Komponente</title>
    <para>
        Dieser Abschnitt stellt ein Beispiel für die Anwendung der Komponente bereit.
    </para>

    <para>
        Das Beispiel kann in der Datei <filename>demos/Zend/Pdf/demo.php</filename> gefunden werden.
    </para>
    <para>
        Dort gibt es auch die Datei <filename>test.pdf</filename>, die für diese Demo zu 
        Testzwecken verwendet werden kann. 
    </para>

    <example>
        <title>Anwendungsbeispiel für die Zend_Pdf Komponente</title>
        <programlisting role="php"><![CDATA[<?php
/**
 * @package Zend_Pdf
 * @subpackage demo
 */

/** Zend_Pdf */
require_once 'Zend/Pdf.php';

if (!isset($argv[1])) {
    echo "VERWENDUNG: php demo.php <pdf_file> [<output_pdf_file>]\n";
    exit;
}

if (file_exists($argv[1])) {
    $pdf = Zend_Pdf::load($argv[1]);
} else {
    $pdf = new Zend_Pdf();
}

//------------------------------------------------------------------------------------
// Kehre die Seitenreihenfolge um
$pdf->pages = array_reverse($pdf->pages);

// Erstelle einen neuen Stil
$style = new Zend_Pdf_Style();
$style->setFillColor(new Zend_Pdf_Color_RGB(0, 0, 0.9));
$style->setLineColor(new Zend_Pdf_Color_GrayScale(0.2));
$style->setLineWidth(3);
$style->setLineDashingPattern(array(3, 2, 3, 4), 1.6);
$style->setFont(Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA_BOLD), 32);

// Erstelle ein neues Grafikobjekt
$stampImage = Zend_Pdf_ImageFactory::factory(dirname(__FILE__) . '/stamp.jpg');

// Kennzeichne Seiten als verändert
foreach ($pdf->pages as $page){
    $page->saveGS();
    $page->setStyle($style);
    $page->rotate(0, 0, M_PI_2/3);

    $page->saveGS();
    $page->clipCircle(550, -10, 50);
    $page->drawImage($stampImage, 500, -60, 600, 40);
    $page->restoreGS();

    $page->drawText('Modified by Zend Framework!', 150, 0);
    $page->restoreGS();
}

// Erstelle eine neue Seite mit Hilfe des Zend_Pdf Objekts (die Seite wird an das angegebene 
// Dokument angehängt)
$pdf->pages[] = ($page1 = $pdf->newPage('A4'));

// Erstelle eine neue Seite mit Hilfe des Zend_Pdf_Page Objekts (die Seite wird nicht an das 
// angegebene Dokument angehängt)
$pdf->pages[] = ($page2 = new Zend_Pdf_Page(Zend_Pdf_Page::SIZE_LETTER_LANDSCAPE));

// Erstelle einen neuen Zeichensatz
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA);

// Lege Zeichensatz fest und zeichnen einen text
$page1->setFont($font, 36);
$page1->drawText('Helvetica 36 text string', 60, 500);

// Verwende das Zeichensatz Objekt für eine andere Seite
$page2->setFont($font, 24);
$page2->drawText('Helvetica 24 text string', 60, 500);

// Verwenden einen anderen Zeichensatz
$page2->setFont(new Zend_Pdf_Font_Standard(Zend_Pdf_Font::FONT_TIMES_ROMAN), 32);
$page2->drawText('Times-Roman 32 text string', 60, 450);

// Zeichne ein Rechteck
$page2->setFillColor(new Zend_Pdf_Color_GrayScale(0.8));
$page2->setLineColor(new Zend_Pdf_Color_GrayScale(0.2));
$page2->setLineDashingPattern(array(3, 2, 3, 4), 1.6);
$page2->drawRectangle(60, 400, 400, 350);

// Zeichne einen Kreis
$page2->setLineDashingPattern(Zend_Pdf_Page::LINE_DASHING_SOLID);
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 0, 0));
$page2->drawCircle(85, 375, 25);

// Zeichne Kreisausschnitte
$page2->drawCircle(200, 375, 25, 2*M_PI/3, -M_PI/6);
$page2->setFillColor(new Zend_Pdf_Color_CMYK(1, 0, 0, 0));
$page2->drawCircle(200, 375, 25, M_PI/6, 2*M_PI/3);
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 1, 0));
$page2->drawCircle(200, 375, 25, -M_PI/6, M_PI/6);

// Zeichne Ellipsen
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 0, 0));
$page2->drawEllipse(250, 400, 400, 350);
$page2->setFillColor(new Zend_Pdf_Color_CMYK(1, 0, 0, 0));
$page2->drawEllipse(250, 400, 400, 350, M_PI/6, 2*M_PI/3);
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 1, 0));
$page2->drawEllipse(250, 400, 400, 350, -M_PI/6, M_PI/6);

// Zeichne und fülle ein Polygon
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 0, 1));
$x = array();
$y = array();
for ($count = 0; $count < 8; $count++) {
    $x[] = 140 + 25*cos(3*M_PI_4*$count);
    $y[] = 375 + 25*sin(3*M_PI_4*$count);
}
$page2->drawPolygon($x, $y,
                    Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE,
                    Zend_Pdf_Page::FILL_METHOD_EVEN_ODD);

// Zeichne eine Linie
$page2->setLineWidth(0.5);
$page2->drawLine(60, 375, 400, 375);
//------------------------------------------------------------------------------------

if (isset($argv[2])) {
    $pdf->save($argv[2]);
} else {
    $pdf->save($argv[1], true /* Aktualisierung */);
}
]]></programlisting>
    </example>

</sect1>


<!--
vim:se ts=4 sw=4 et:
-->
