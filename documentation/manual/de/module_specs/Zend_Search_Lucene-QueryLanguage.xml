<sect1 id="zend.search.lucene.query-language">
    <title>Abfragesprache</title>

    <para>
        Java Lucene und Zend_Search_Lucene bieten eine sehr mächtige Abfragesprache an.
    </para>

    <para>
        Meistens ist es das selbe, hat aber ein paar Unterschiede, welche anbei erklärt werden.
    </para>

    <para>
        Die komplette Java Lucene Syntax Dokumentation der Abfragesprache kann
        <ulink url="http://lucene.apache.org/java/2_0_0/queryparsersyntax.html">hier</ulink> gefunden werden.
    </para>

    <sect2 id="zend.search.lucene.query-language.terms">
        <title>Ausdrücke</title>

        <para>
            Eine Abfrage wird in Ausdrücke und Operatoren zerteilt. Es gibt drei Arten von Ausdrücken:
            Einzelne Ausdrücke, Phrasen und Unterabfragen.
        </para>
        <para>
            Ein einzelner Ausdruck ist ein einzelnes Wort wie "Test" oder "Hallo".
        </para>
        <para>
            Eine Phrase ist eine Gruppe von Wörtern die von doppelten Hochkommata umgeben sind wie "Hallo Dolly".
        </para>
        <para>
            Eine Unterabfrage ist eine Abfrage die von Klammern umgeben ist wie "(Hallo Dolly)".
        </para>
        <para>
            Mehrere Ausdrücke können miteinander kombiniert werden mithilfe eines boolschen Operators um eine
            komplexere Abfrage zu formen (siehe anbei).
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.fields">
        <title>Felder</title>

        <para>
            Lucene unterstützt Daten in Feldern. Wenn eine Suche durchgeführt wird kann man entweder ein Feld
            spezifizieren, oder ein Standardfeld verwenden. Der Name des Feldes hängt von den indizierten Daten
            ab und das Standardfeld wird durch aktuelle Einstellungen definiert.
        </para>
        <para>
            Der erste und hauptsächliche Unterschied zu Java Lucene ist der das Ausdrücke standardmäßig
            über <emphasis>alle Felder</emphasis> gesucht werden.
        </para>
        <para>
            Es gibt zwei statishce Methoden in der Zend_Search_Lucene Klasse die das das Arbeiten mit diesen
            Einstellungen erlauben:
        </para>
        <programlisting role="php"><![CDATA[<?php
$defaultSearchField = Zend_Search_Lucene::getDefaultSearchField();
...
Zend_Search_Lucene::setDefaultSearchField('contents');]]>
        </programlisting>

        <para>
            <code>null</code> Wert heißt, das die Suche über alle Felder durchgeführt wird. Das ist die
            Standardeinstellung.
        </para>
        <para>
            Felder können spezifiziert werden durch die Angabe des Feldnamens gefolgt von einem Doppelpunkt ":"
            und danach den Ausdruck nach dem gesucht wird.
        </para>
        <para>
            Als Beispiel nehmen wir an das ein Lucene Index zwei Felder enthält, title und text. Text ist der
            Standardwert. Wenn man das "Der richtige Weg" benannte Dokument finden will welches den Text
            "gehe nicht diesen Weg" enthält, geht das mit:
        </para>
        <programlisting role="querystring"><![CDATA[title:"Der richtige Weg" AND text:go]]>
        </programlisting>
        <para>
            oder
        </para>
        <programlisting role="querystring"><![CDATA[title:"Mach es richtig" AND go]]>
        </programlisting>
        <para>
            Wenn "text" das Standardfeld ist, wird der Feld Indikator nicht benötigt.
        </para>

        <para>
            Beachte: Das Feld nur nur für den Ausdruck, die Phrase oder die Unterabfrage gültig die direkt
            danach folgt, sodas die Abfrage
            <programlisting role="querystring"><![CDATA[title:Mach es richtig]]>
            </programlisting>
            nur "Mach" im title Feld finden wird. Es findet "es" und "richtig" im Standardfeld, wenn das
            Standardfeld gesetzt ist, oder in allen indizierten Felder, wenn das Standardfeld auf
            <code>null</code> gesetzt ist.
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.wildcard">
        <title>Wildcards</title>
        <para>
            Lucene unterstützt Einzelzeichen und Mehrfachzeichen Suchen mit Wildcards in einzelnen Ausdrücken
            (nicht innerhalb von Phrasenabfragen).
        </para>

        <para>
            Um eine Einzelzeichen Wildcardsuche durchzuführen kann das "?" Zeichen verwendet werden.
        </para>

        <para>
            Um eine Mehrzeichen Wildcardsuche durchzuführen kann das "*" Zeichen verwendet werden.
        </para>

        <para>
            Die Einzelzeichen Wildcardsuche schaut nach Ausdrücken die dem ausgetauschten Einzelzeichen
            entsprechen. Um, zum Beispiel, nach "Text" oder "Test" zu suchen kann die folgende Suche
            verwendet werden:
            <programlisting role="querystring"><![CDATA[Te?t]]>
            </programlisting>
        </para>

        <para>
            Mehrzeichen Wildcardsuche sucht nach 0 oder mehr Zeichen. Um, zum Beispiel, nach Test, Tests oder
            Tester zu suchen, kann die folgende Suche verwendet werden: 
            <programlisting role="querystring"><![CDATA[Test*]]>
            </programlisting>
        </para>

        <para>
            Es können "?", "*" oder beide an jeder Stelle des Ausdrucks verwendet werden:
            <programlisting role="querystring"><![CDATA[*schrei?t*]]>
            </programlisting>
            Sucht nach "schreibt", "schreibtisch", "beschreibt", "schreist" und so weiter.
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.modifiers">
        <title>Ausdrücke verändern</title>

        <para>
            Lucene unterstützt die Veränderung von Abfrageausdrücken und bietet damit ein beites Spektrum von
            Suchoptionen.
        </para>
        <para>
            Zend_Search_Lucene unterstützt den "~" Modifikator aktuell nur für Phrasen
            <footnote>
                <para>
                    "~" für Ausdrücke wird für Fuzzy Suche verwendet, aber die Fuzzy Suche von Abfragen wird bis
                    dato noch nicht unterstützt.
                </para>
            </footnote>
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.range">
        <title>Bereiche suchen</title>

        <para>
            Range queries allow one to match documents whose field(s) values are between the lower and upper bound specified by the range query.
            Range Queries can be inclusive or exclusive of the upper and lower bounds. Sorting is done lexicographically.
            <programlisting role="querystring"><![CDATA[mod_date:[20020101 TO 20030101]]]>
            </programlisting>
            This will find documents whose mod_date fields have values between 20020101 and 20030101, inclusive. Note that Range Queries are not
            reserved for date fields. You could also use range queries with non-date fields:
            <programlisting role="querystring"><![CDATA[title:{Aida TO Carmen}]]>
            </programlisting>
            This will find all documents whose titles are between Aida and Carmen, but not including Aida and Carmen.
        </para>
        <para>
            Inclusive range queries are denoted by square brackets. Exclusive range queries are denoted by curly brackets.
        </para>
        <para>
            If field is not specified then Zend_Search_Lucene searches for specified interval through all fields.
            <programlisting role="querystring"><![CDATA[{Aida TO Carmen}]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.proximity-search">
        <title>Proximity Searches</title>

        <para>
            Lucene supports finding words are a within a specific distance away. To do a proximity search
            use the tilde, "~", symbol at the end of a Phrase. For example to search for a "Zend" and
            "Framework" within 10 words of each other in a document use the search:
            <programlisting role="querystring"><![CDATA["Zend Framework"~10]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.boosting">
        <title>Boosting a Term</title>

        <para>
            Java Lucene and Zend_Search_Lucene provide the relevance level of matching documents based
            on the terms found. To boost a term use the caret, "^", symbol with a boost factor (a number)
            at the end of the term you are searching. The higher the boost factor, the more relevant
            the term will be.
        </para>
        <para>
            Boosting allows you to control the relevance of a document by boosting its term. For example,
            if you are searching for
            <programlisting role="querystring"><![CDATA[PHP framework]]>
            </programlisting>
            and you want the term "PHP" to be more relevant boost it using the ^ symbol along with the
            boost factor next to the term. You would type:
            <programlisting role="querystring"><![CDATA[PHP^4 framework]]>
            </programlisting>
            This will make documents with the term PHP appear more relevant. You can also boost Phrase
            Terms  and subqueries as in the example:
            <programlisting role="querystring"><![CDATA["PHP framework"^4 "Zend Framework"]]>
            </programlisting>
            By default, the boost factor is 1. Although the boost factor must be positive,
            it can be less than 1 (e.g. 0.2)
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.boolean">
        <title>Boolean Operators</title>

        <para>
            Boolean operators allow terms to be combined through logic operators.
            Lucene supports AND, "+", OR, NOT and "-" as Boolean operators.
            Java Lucene needs boolean operators t obe ALL CAPS. Zend_Search_Lucene doesn't.
        </para>

        <para>
            Boolean operators allow terms to be combined through logic operators.
            Lucene supports AND, "+", OR, NOT and "-" as Boolean operators.
        </para>

        <para>
            AND, OR, and NOT operators and "+", "-" defines two styles to construct boolean queries.
            As opposed to Java Lucene Zend_Search_Lucene doesn't allow to mix these two styles.
        </para>
        <para>
            If AND/OR/NOT style is used, then AND/OR operator must be present between all query terms.
            Each term may also be preceded by NOT operator. AND operator has higher precedence than OR.
            It differs from Java Lucene behavior.
        </para>

        <sect3 id="zend.search.lucene.query-language.boolean.and">
            <title>AND</title>
            <para>
                The AND operator means, that all terms in "AND group" must match document.
            </para>
            <para>
                To search for documents that contain "PHP framework" and "Zend Framework" use the query:
                <programlisting role="querystring"><![CDATA["PHP framework" AND "Zend Framework"]]>
                </programlisting>
            </para>
        </sect3>

        <sect3 id="zend.search.lucene.query-language.boolean.or">
            <title>OR</title>
            <para>
                The OR operator divides query into several optional parts.
            </para>
            <para>
                To search for documents that contain "PHP framework" or "Zend Framework" use the query:
                <programlisting role="querystring"><![CDATA["PHP framework" OR "Zend Framework"]]>
                </programlisting>
            </para>
        </sect3>

        <sect3 id="zend.search.lucene.query-language.boolean.not">
            <title>NOT</title>
            <para>
                The NOT operator excludes documents that contain the term after NOT. But "AND group", which contains
                only terms with NOT operator, gives empty result instead of full set indexed documents.
            </para>
            <para>
                To search for documents that contain "PHP framework" but not "Zend Framework" use the query:
                <programlisting role="querystring"><![CDATA["PHP framework" AND NOT "Zend Framework"]]>
                </programlisting>
            </para>
        </sect3>

        <sect3 id="zend.search.lucene.query-language.boolean.other-form">
            <title>&amp;&amp;, ||, and ! operators</title>
            <para>
                &amp;&amp;, ||, and ! may be used instead of AND, OR, and NOT operators.
            </para>
        </sect3>

        <sect3 id="zend.search.lucene.query-language.boolean.plus">
            <title>+</title>
            <para>
                The "+" or required operator requires that the term after the "+" symbol must match the document.
            </para>
            <para>
                To search for documents that must contain "Zend" and may contain "Framework" use the query:
                <programlisting role="querystring"><![CDATA[+Zend Framework]]>
                </programlisting>
            </para>
        </sect3>

        <sect3 id="zend.search.lucene.query-language.boolean.minus">
            <title>-</title>
            <para>
                The "-" or prohibit operator excludes documents that matches the term after the "-" symbol.
            </para>
            <para>
                To search for documents that contain "PHP framework" but not "Zend Framework" use the query:
                <programlisting role="querystring"><![CDATA["PHP framework" -"Zend Framework"]]>
                </programlisting>
            </para>
        </sect3>

        <sect3 id="zend.search.lucene.query-language.boolean.no-operator">
            <title>no operator</title>
            <para>
                If no operator is used, then behavior is defined by "default boolean operator".
            </para>
            <para>
                It's <code>OR</code> by default.
            </para>
            <para>
                That means, that term is optional. It may be or may not be presented within document, but documents with this term
                will have higher score.
            </para>
            <para>
                To search for documents that requires "PHP framework" and may contain "Zend Framework" use the query:
                <programlisting role="querystring"><![CDATA[+"PHP framework" "Zend Framework"]]>
                </programlisting>
            </para>

            <para>
                Default boolean operator may be set or retrieved with
                <code>Zend_Search_Lucene_Search_QueryParser::setDefaultOperator($operator)</code> and
                <code>Zend_Search_Lucene_Search_QueryParser::getDefaultOperator()</code> methods.
            </para>
            <para>
                These methods operate with
                <code>Zend_Search_Lucene_Search_QueryParser::B_AND</code> and
                <code>Zend_Search_Lucene_Search_QueryParser::B_OR</code> constants.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.grouping">
        <title>Grouping</title>

        <para>
            Java Lucene and Zend_Search_Lucene support using parentheses to group clauses to form sub queries. This can be
            useful if you want to control the boolean logic for a query or mix different boolean query styles:
            <programlisting role="querystring"><![CDATA[+(framework OR library) +php]]>
            </programlisting>
            Zend_Search_Lucene supports subqueries of any level.
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.field-grouping">
        <title>Field Grouping</title>

        <para>
            Lucene supports using parentheses to group multiple clauses to a single field.
        </para>
        <para>
            To search for a title that contains both the word "return" and the phrase "pink panther" use the query:
            <programlisting role="querystring"><![CDATA[title:(+return +"pink panther")]]>
            </programlisting>
            Zend_Search_Lucene supports subqueries of any level.
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.query-language.escaping">
        <title>Escaping Special Characters</title>

        <para>
            Lucene supports escaping special characters that are part of the query syntax. The current list special
            characters are:
        </para>
        <para>
            + - &amp;&amp; || ! ( ) { } [ ] ^ " ~ * ? : \
        </para>
        <para>
            + and - inside single terms are treated as common characters.
        </para>
        <para>
            To escape these character use the \ before the character. For example to search for (1+1):2 use the query:
            <programlisting role="querystring"><![CDATA[\(1\+1\)\:2]]>
            </programlisting>
        </para>
    </sect2>

</sect1>
