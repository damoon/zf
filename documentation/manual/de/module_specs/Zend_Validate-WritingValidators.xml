<sect1 id="zend.validate.writing_validators">

    <title>Schreiben von Prüfern</title>

    <para>
        Zend_Validate bietet ein Set von standardmäßig benötigten Prüfern, aber zwangsläufig, werden
        Entwickler wünschen, eigene Prüfer für die eigenen Bedürfnisse zu schreiben. Die Aufgabe des
        Schreibens eigener Prüfer wird in diesem Kapitel beschrieben.
    </para>

    <para>
        <code>Zend_Validate_Interface</code> definiert drei Methoden, <code>isValid()</code>,
        <code>getMessages()</code>, und <code>getErrors()</code>, welche von Benutzerklassen implementiert
        werden können um eigene Prüfobjekte zu erstellen. Ein Objekt welches das
        <code>Zend_Validate_Interface</code> Interface implementiert kann einer Prüfkette mit
        <code>Zend_Validate::addValidator()</code> hinzugefügt werden. Solche Objekte können auch mit
        <link linkend="zend.filter.input"><code>Zend_Filter_Input</code></link> verwendet werden.
    </para>

    <para>
        Wie man bereits aus der obigen Beschreibung von <code>Zend_Validate_Interface</code> folgern kann,
        geben die vom Zend Framework bereitgestellten Prüfklassen einen boolschen Wert zurück, ob die Prüfung
        des Wertes erfolgreich war oder nicht. Sie geben auch darüber Informationen
        <emphasis role="bold">warum</emphasis> ein Wert die Prüfung nicht bestanden hat. Die Verfügbarkeit der
        Gründe für fehlgeschlagene Prüfungen kann für eine Anwendung aus vielen Gründen nützlich sein, wie
        zum Beispiel das zur Verfügung stellen von Statistiken für Useability Analysen.
    </para>

    <para>
        Grundlegende Funktionalitäten für fehlgeschlagene Prüfmeldungen ist in <code>Zend_Validate_Abstract</code>
        implementiert. Um diese Funktionalität einzubinden wenn eine Prüfklasse erstellt wird, muß einfach
        <code>Zend_Validate_Abstract</code> erweitert werden. In der existierenden Klasse wird die Logik der
        <code>isValid()</code> Methode implementiert und die Variablen für die Nachrichten und
        Nachrichten-Templates definiert werden die zu den Typen von Prüffehlern passen die auftreten können.
        Wenn ein Wert die Prüfung nicht besteht, sollte <code>isValid()</code> <code>false</code> zurückgeben.
        Wenn der Wert die Prüfung besteht, sollte <code>isValid()</code> <code>true</code> zurückgeben.
    </para>

    <para>
        Normalerweise sollte die <code>isValid()</code> Methode keine Ausnahmen werfen, ausser wenn es unmöglich
        ist festzustellen ob ein Eingabewert gültig ist oder nicht. Einige Beispiele für gute Fälle in denen keine
        Ausnahme geworfen werden sollte sind, wenn eine Datei nicht geöffnet werden konnte, ein LDAP Server nicht
        erreicht wurde, oder eine Datenbank Verbindung unerreichbar ist, und wo solche Dinge für Prüfprozesse
        benötigt werden um zu erkennen ob die Prüfung gültig oder ungültig ist.
    </para>

    <example id="zend.validate.writing_validators.example.simple">

        <title>Erstellen einer einfachen Prüfklasse</title>

        <para>
            Das folgende Beispiel demonstriert wie ein sehr einfacher eigener Prüfer geschrieben werden könnte.
            In diesem Fall sind die Prüfregeln sehr einfach und der Eingabewert muß ein Gleitkommawert sein.

            <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Validate/Abstract.php';

class MyValid_Float extends Zend_Validate_Abstract
{
    const FLOAT = 'float';

    protected $_messageTemplates = array(
        self::FLOAT => "'%value%' ist kein Gleitkommawert"
    );

    public function isValid($value)
    {
        $this->_setValue($value);

        if (!is_float($value)) {
            $this->_error();
            return false;
        }

        return true;
    }
}

?>]]></programlisting>

            The class defines a template for its single validation failure message, which includes the built-in magic
            parameter, <code>%value%</code>. The call to <code>_setValue()</code> prepares the object to insert the
            tested value into the failure message automatically, should the value fail validation. The call to
            <code>_error()</code> tracks a reason for validation failure. Since this class only defines one failure
            message, it is not necessary to provide <code>_error()</code> with the name of the failure message
            template.
        </para>

    </example>

    <example id="zend.validate.writing_validators.example.conditions.dependent">

        <title>Writing a Validation Class having Dependent Conditions</title>

        <para>
            The following example demonstrates a more complex set of validation rules, where it is required that the
            input value be numeric and within the range of minimum and maximum boundary values. An input value would
            fail validation for exactly one of the following reasons:

            <itemizedlist>
                <listitem>
                    <para>The input value is not numeric.</para>
                </listitem>
                <listitem>
                    <para>The input value is less than the minimum allowed value.</para>
                </listitem>
                <listitem>
                    <para>The input value is more than the maximum allowed value.</para>
                </listitem>
            </itemizedlist>
        </para>

        <para>
            These validation failure reasons are then translated to definitions in the class:

            <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Validate/Abstract.php';

class MyValid_NumericBetween extends Zend_Validate_Abstract
{
    const MSG_NUMERIC = 'msgNumeric';
    const MSG_MINIMUM = 'msgMinimum';
    const MSG_MAXIMUM = 'msgMaximum';

    public $minimum = 0;
    public $maximum = 100;

    protected $_messageVariables = array(
        'min' => 'minimum',
        'max' => 'maximum'
    );

    protected $_messageTemplates = array(
        self::MSG_NUMERIC => "'%value%' is not numeric",
        self::MSG_MINIMUM => "'%value%' must be at least '%min%'",
        self::MSG_MAXIMUM => "'%value%' must be no more than '%max%'"
    );

    public function isValid($value)
    {
        $this->_setValue($value);

        if (!is_numeric($value)) {
            $this->_error(self::MSG_NUMERIC);
            return false;
        }

        if ($value < $this->minimum) {
            $this->_error(self::MSG_MINIMUM);
            return false;
        }

        if ($value > $this->maximum) {
            $this->_error(self::MSG_MAXIMUM);
            return false;
        }

        return true;
    }
}

?>]]></programlisting>

            The public properties <code>$minimum</code> and <code>$maximum</code> have been established to provide
            the minimum and maximum boundaries, respectively, for a value to successfully validate. The class also
            defines two message variables that correspond to the public properties and allow <code>min</code> and
            <code>max</code> to be used in message templates as magic parameters, just as with <code>value</code>.
        </para>

        <para>
            Note that if any one of the validation checks in <code>isValid()</code> fails, an appropriate failure
            message is prepared, and the method immediately returns <code>false</code>. These validation rules are
            therefore sequentially dependent. That is, if one test should fail, there is no need to test any
            subsequent validation rules. This need not be the case, however. The following example illustrates how to
            write a class having independent validation rules, where the validation object may return multiple
            reasons why a particular validation attempt failed.
        </para>

    </example>

    <example id="zend.validate.writing_validators.example.conditions.independent">

        <title>Validation with Independent Conditions, Multiple Reasons for Failure</title>

        <para>
            Consider writing a validation class for password strength enforcement - when a user is required to choose
            a password that meets certain criteria for helping secure user accounts. Let us assume that the password
            security criteria enforce that the password:

            <itemizedlist>
                <listitem>
                    <para>is at least 8 characters in length,</para>
                </listitem>
                <listitem>
                    <para>contains at least one uppercase letter,</para>
                </listitem>
                <listitem>
                    <para>contains at least one lowercase letter,</para>
                </listitem>
                <listitem>
                    <para>and contains at least one digit character.</para>
                </listitem>
            </itemizedlist>
        </para>

        <para>
            The following class implements these validation criteria:

            <programlisting role="php"><![CDATA[<?php

require_once 'Zend/Validate/Abstract.php';

class MyValid_PasswordStrength extends Zend_Validate_Abstract
{
    const LENGTH = 'length';
    const UPPER  = 'upper';
    const LOWER  = 'lower';
    const DIGIT  = 'digit';

    protected $_messageTemplates = array(
        self::LENGTH => "'%value%' must be at least 8 characters in length",
        self::UPPER  => "'%value%' must contain at least one uppercase letter",
        self::LOWER  => "'%value%' must contain at least one lowercase letter",
        self::DIGIT  => "'%value%' must contain at least one digit character"
    );

    public function isValid($value)
    {
        $this->_setValue($value);

        $isValid = true;

        if (strlen($value) < 8) {
            $this->_error(self::LENGTH);
            $isValid = false;
        }

        if (!preg_match('/[A-Z]/', $value) {
            $this->_error(self::UPPER);
            $isValid = false;
        }

        if (!preg_match('/[a-z]/', $value) {
            $this->_error(self::LOWER);
            $isValid = false;
        }

        if (!preg_match('/\d/', $value) {
            $this->_error(self::DIGIT);
            $isValid = false;
        }

        return $isValid;
    }
}

?>]]></programlisting>

            Note that the four criteria tests in <code>isValid()</code> do not immediately return <code>false</code>.
            This allows the validation class to provide <emphasis role="bold">all</emphasis> of the reasons that the
            input password failed to meet the validation requirements. If, for example, a user were to input the
            string "<code>#$%</code>" as a password, <code>isValid()</code> would cause all four validation failure
            messages to be returned by a subsequent call to <code>getMessages()</code>.
        </para>

    </example>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
