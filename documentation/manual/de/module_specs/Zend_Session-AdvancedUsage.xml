<sect1 id="zend.session.advancedusage">

    <title>Gehobene Benutzung</title>

    <para>
        Wärend die Beispiele für die Basisnutzung völlig akzeptierbar sind, in ihrem Weg Zend Framework Sessions
        zu Benutzen, ist auch etwas beste Praxis zu bedenken. Bedenkt man etwa das
        <link linkend="zend.auth.introduction.using"><code>Zend_Auth</code> Beispiel</link>
        das Zend_Session_Namespace standardmäßig transparent benutzt um Authentifizierungs Teile zu fixieren.
        Dieses Beispiel zeigt einen Ansatz um schnell und einfach Zend_Session_Namespace und Zend_Auth zu integrieren.
    </para>

    <sect2 id="zend.session.startingasession">

        <title>Starten einer Session</title>

        <para>
            Wenn alle Anfragen eine Session besitzen und Zend Framework Sessions benutzen sollen,
            muß die Session in der Bootstrap Datei gestartet werden:
        </para>

        <example>
            <title>Starten einer globalen Session</title>
<programlisting role="php">
<![CDATA[<?php
...
require_once 'Zend/Session.php';
Zend_Session::start();
...
?>]]></programlisting>
        </example>

        <para>
            Durch das Starten der Session in der Bootstrap Datei verhindert man das die Session gestartet werden
            könnte nachdem die Header an den Browser gesendet wurde, was zu einer Ausnahme und möglicherweise
            zu einer fehlerhaften Seiten im Browser führen würde. Viele gehobenen Features benötigen zuerst
            <code>Zend_Session::start()</code>. (Mehr dazu später in den gehobenen Features)
        </para>

        <para>
            Es gibt vier Wege eine Session zustarten wenn Zend_Session verwendet wird. Zwei sind falsch.
        </para>

        <itemizedlist mark='opencircle'>
            <listitem>
                <para>
                    1. Falsch: PHP's session.auto.start Ini-Einstellung darf nicht gesetzt sein, weder in der
                    php.ini noch in .htaccess (http://www.php.net/manual/en/ref.session.php#ini.session.auto-start).
                    Wenn keine Möglichkeit besteht diese Einstellung in php.ini zu deaktivieren, und mod_php
                    (oder ähnliches) verwendet wird, und die Einstellung schon in php.ini aktiviert ist, kann
                    <code>php_value session.auto_start 0</code> in der .htaccess Datei hinzugefügt werden
                    (normalerweise im HTML Dokument Haupt-Verzeichnis).
                </para>
            </listitem>
            <listitem>
                <para>
                    2. Falsch: PHP's <code><ulink url="http://www.php.net/session_start">session_start()</ulink></code>
                    Funktion darf nicht direkt verwendet werden. Wenn <code>session_start()</code> direkt, und
                    anschließend Zend_Session_Namespace verwendet wird, wird von <code>Zend_Session::start()</code>
                    eine Ausnahme geworfen ("session has already been started"). Wenn
                    <code>Zend_Session::start()</code> ausgerufen wird, nachdem Zend_Session_Namespace verwendet
                    wird oder <code>Zend_Session::start()</code> explizit verwendet wird, wird ein Fehler vom
                    Level E_NOTICE erzeugt und der Aufruf wird ignoriert.
                </para>
            </listitem>
            <listitem>
                <para>
                    3. Richtig: Verwenden von <code>Zend_Session::start()</code>. Wenn es gewünscht ist, das alle
                    Anfragen eine Session haben und verwenden, sollte diese Funktion sehr früh, direkt und
                    entscheidungslos in der ZF Bootstrap Datei aufgerufen werden. Session haben einigen Overhead.
                    Wenn einige Anfragen Sessions benötigen aber andere Anfragen keine Sessions verwenden, dann:
                </para>
                <itemizedlist mark='opencircle'>
                    <listitem>
                        <para>
                            Entscheidungslos, die <code>strict</code> Option auf wahr setzen (siehe
                            <link
                        linkend="zend.session.startingasession"><code>Zend_Session::setOptions()</code>
                            </link>
                            ) im eigenen Bootstrap.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Aufruf von <code>Zend_Session::start()</code>, nur für die Anfragen die eine Session
                            verwenden müssen, bevor das erste Mal <code>new Zend_Session_Namespace()</code> aufgerufen
                            wird.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Normales verwenden von <code>new Zend_Session_Namespace()</code> wo es benötigt wird,
                            aber sicherstellen das davor <code>Zend_Session::start()</code> ausgerufen wurde.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Die Option <code>strict</code> verhindert das <code>new Zend_Session_Namespace()</code>
                    automatisch eine Session startet und dabei <code>Zend_Session::start()</code> verwendet.
                    Deshalb hilft diese Option Entwicklern bei eigenen ZF Anwendungen, sich für ein Design entscheiden
                    zu können welches verhindert das für bestimmte Anfragen Sessions verwendet werden, da ein
                    Fehler geworfen würde wenn diese Option verwendet und Zend_Session_Namespace instanziiert wird,
                    bevor <code>Zend_Session::start()</code> explizit aufgerufen wird. Diese Option sollte nicht in
                    ZF Kern-Bibliotheks-Code verwendet werden, da nur Entwickler diese Designentscheidung treffen
                    sollten. Gleichfalls sollten alle "Bibliotheks" Entwickler vorsichtig entscheiden welchen Einfluß
                    die Verwendung von <code>Zend_Session::setOptions()</code> auf Benutzern in deren
                    Bibliothekscode hat, da diese Optionen globale Seiteneffekte hat (genauso wie die
                    darunterliegende Option für ext/session).
                </para>
            </listitem>
            <listitem>
                <para>
                    4. Richtig: Einfach <code>new Zend_Session_Namespace()</code> verwenden wo dies auch immer
                    notwendig ist, und die Session wird automatisch innerhalb von Zend_Session gestartet. Das bietet
                    eine extrem simple Handhabung die in den meisten Situationen gut funktioniert. Trotzdem ist man
                    dann dafür verantwortlich darauf zu schauen das das erste <code>new Zend_Session_Namespace()</code>
                    passiert <emphasis role="strong">bevor</emphasis> irgendeine Ausgabe (z.B. 
                    <ulink url="http://www.php.net/headers_sent">HTTP headers</ulink> ) von PHP an den Client
                    gesendet wird, wenn standardmäßige, Cookie-basierte Sessions verwendet werden (sehr
                    empfehlenswert). Siehe <xref linkend="zend.session.errors.headerssent" /> für mehr Informationen.
                </para>
            </listitem>
        </itemizedlist>

    </sect2>

    <sect2 id="zend.session.locking">

        <title>Gesperrte Session Namensräume</title>

        <para>
            Session Namensräume können gesperrt werden um weitere Veränderungen der Daten in diesem Namensraum
            zu verhindern. Die Verwendung von <code>Zend_Session_Namespace's lock()</code> macht einen speziellen
            Namensraum nur-lesbar, <code>unLock()</code> macht einen nur-lesbaren Namensraum les- und schreibbar,
            und <code>isLocked()</code> prüft ob ein Namensraum vorher gesperrt wurde. Sperren sind flüchtig und
            bestehen nicht von einer Anfrage zur nächsten. Die Sperre des Namensraumes hat keinen Effekt auf
            Setz-Methoden von Objekten welche im Namensraum gespeichert sind, aber sie verhindert die Verwendung
            der Setz-Methoden des Namensraumes welche das gespeicherte Objekt direkt im Namensraum löschen oder
            ersetzen. Gleichwohl verhindert das Sperren von Zend_Session_Namespace Namensräumen nicht die Verwendung
            von symbolischen Tabellen-Aliasen auf die gleichen Daten (siehe
            <ulink url="http://www.php.net/references">PHP references</ulink>).
        </para>

        <example>
            <title>Sperren von Session Namensräumen</title>
<programlisting role="php">
<![CDATA[<?php
    // Annahme:
    $userProfileNamespace = new Zend_Session_Namespace('userProfileNamespace');

    // Die Session als nur-lesbar gesperrt markieren
    $userProfileNamespace->lock();

    // Die nur-lesbar Sperre aufheben
    if ($userProfileNamespace->isLocked()) {
        $userProfileNamespace->unLock();
    }
?>]]></programlisting>
        </example>

        <para>
            Es gibt eine Vielzahl von Ideen wie Modelle im MVC Paradigma für das Web gehandhabt werden, welche die
            Erstellung von Präsentations Modellen für Views inkludieren. Manchmal sind bestehende Daten, egal ob
            Teil des Domain Modells oder nicht, adequat für diese Aufgabe. Um Views vom Hinzufügen von irgendeiner
            ausführenden Logik abzuraten, die solche Daten verändert, sollte der Session Namensraum gesperrt werden
            bevor es Views gestattet wird auf dieses Subset des "Präsentations" Modells zuzugreifen.
        </para>

        <example>
            <title>Sperren von Sessions in Views</title>
<programlisting role="php">
<![CDATA[<?php
class FooModule_View extends Zend_View
{
    public function show($name)
    {
        if (!isset($this->mySessionNamespace)) {
            $this->mySessionNamespace = Zend::registry('FooModule');
        }

        if ($this->mySessionNamespace->isLocked()) {
            return parent::render($name);
        }

        $this->mySessionNamespace->lock();
        $return = parent::render($name);
        $this->mySessionNamespace->unLock();

        return $return;
    }
}
?>]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.session.expiration">

        <title>Verfall von Namensräumen</title>

        <para>
            Limits können plaziert werden an der Lebensdauer von beidem, Namensräumen und individuellen Schlüsseln
            in Namensräumen. Normale Anwendungsfälle beinhalten das durchlaufen von temporären Informationen zwischen
            Anfragen, und das vermindern der Aufdeckung von vielfältigen Sicherheitsrisiken durch das Entfernen des
            Zugangs zu potentiell sensitiven Informationen, manchmal nachdem Authentifizierung stettgefunden hat.
            Das Ende kann auf abgelaufenen Sekunden, oder auf dem Konzept von "Sprüngen" basieren, wobei ein Sprung
            für jede nachfolgende Anfrage stattfindet die den Namensraum aktiviert, durch mindestens ein
            <code>$space = new Zend_Session_Namespace('myspace');</code>.
        </para>

        <example>
            <title>Beispiel für den Verfall</title>
<programlisting role="php">
<![CDATA[<?php
$s = new Zend_Session_Namespace('expireAll');
$s->a = 'Apfel';
$s->p = 'Pfirsich';
$s->o = 'Orange';

$s->setExpirationSeconds(5, 'a'); // Der Schlüssel "a" läuft in 5 Sekunden ab

// Der komplette Namensraum läuft in 5 "Sprüngen"
$s->setExpirationHops(5);

$s->setExpirationSeconds(60);
// Der "expireAll" Namensraum wird als "abgelaufen" markiert
// sobald der erste Aufruf empfangen wurde und 60 Sekunden
// vergangen sind, oder in 5 Sprüngen, was auch immer zuerst stattfindet
?>]]></programlisting>
        </example>

        <para>
            When working with data expiring from the session in the current request, care should be used when retrieving
            it. Although the data is returned by reference, modifying the data will not make expiring data persist past
            the current request. In order to "reset" the expiration time, fetch the data into temporary variables, use
            the namespace to unset it, and then set the appropriate keys again.
        </para>

    </sect2>

    <sect2 id="zend.session.controllers">

        <title>Session Encapsulation and Controllers</title>

        <para>
            Namespaces can also be used to separate session access by controllers to protect variables from
            contamination. For example, the 'Zend_Auth' controller might keep its session state data separate from all
            other controllers.
        </para>

        <example>
            <title>Namespaced Sessions for Controllers with Automatic Expiration</title>
<programlisting role="php">
<![CDATA[<?php
require_once 'Zend/Session.php';
// question view controller
$testSpace = new Zend_Session_Namespace('testSpace');
$testSpace->setExpirationSeconds(300, "accept_answer"); // expire only this variable
$testSpace->accept_answer = true;

--

// answer processing controller
$testSpace = new Zend_Session_Namespace('testSpace');

if ($testSpace->accept_answer === true) {
    // within time
}
else {
    // not within time
}
?>]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.session.limitinginstances">

        <title>Limiting Instances of Zend_Session_Namespace to One Per Namespace</title>

        <para>
            We recommend using session locking (see above) instead of the feature below, which places extra management
            burden on the developer to pass any Zend_Session_Namespace instances into whatever functions and objects
            need access to each namespace.
        </para>

        <para>
            When constructing the first instance of Zend_Session_Namespace attached to a specific namespace, you can
            also instruct Zend_Session_Namespace to not make any more instances for that namespace. Thus, any future
            attempts to construct a Zend_Session_Namespace instance having the same namespace will throw an error. Such
            behavior is optional, and not the default behavior, but remains available to those who prefer to pass around
            a single instance object for each namespace. This increases protection from changes by components that
            should not modify a particular session namespace, because they won't have easy access. However, limiting a
            namespace to a single instance may lead to more code or more complex code, as it removes access to the
            convient <code>$aNamespace = new Zend_Session_Namespace('aNamespace');</code>, after the first intance has
            been created, as follows in the example below:
        </para>

        <example>
            <title>Limiting to Single Instances</title>
<programlisting role="php">
<![CDATA[<?php
    require_once 'Zend/Session.php';
    $authSpaceAccessor1 = new Zend_Session_Namespace('Zend_Auth');
    $authSpaceAccessor2 = new Zend_Session_Namespace('Zend_Auth', Zend_Session_Namespace::SINGLE_INSTANCE);
    $authSpaceAccessor1->foo = 'bar';
    assert($authSpaceAccessor2->foo, 'bar'); // passes
    doSomething($options, $authSpaceAccessor2); // pass the accessor to wherever it is needed
    .
    .
    .
    $aNamespaceObject = new Zend_Session_Namespace('Zend_Auth'); // this will throw an error
?>]]></programlisting>
        </example>

        <para>
            The second parameter in the constructor above will tell Zend_Session_Namespace that any future
            Zend_Session's that are instantiated with the 'Zend_Auth' namespace are not allowed, and will thus cause an
            exception. Since <code>new Zend_Session_Namespace('Zend_Auth')</code> will not be allowed after the code
            above has been executed, the developer becomes responsible for storing the instance object
            (<code>$authSpaceAccessor2</code> in the example above) somewhere, if access to this session namespace is
            needed at a later time during the same request. For example, a developer may store the instance in a static
            variable, or pass it to other methods that might need access to this session namespace. Session locking (see
            above) provides a more convenient, and less burdensome approach to limiting access to namespaces.
        </para>

    </sect2>

    <sect2 id="zend.session.modifyingarray">

        <title>Working with Arrays in Namespaces</title>

        <para>
            Modifying an array inside a namespace does not work. The simplest solution is to store arrays after all
            desired values have been set.
            <ulink url="http://framework.zend.com/issues/browse/ZF-800">ZF-800</ulink>
            documents a known issue affecting many PHP applications using magic methods and arrays.
        </para>

        <example>
            <title>Known problem with arrays</title>
<programlisting role="php">
<![CDATA[<?php
    $sessionNamespace = new Zend_Session_Namespace('Foo');
    $sessionNamespace->array = array();
    $sessionNamespace->array['testKey'] = 1; // does not work before PHP 5.2.1
?>]]></programlisting>
        </example>

        <para>
            If you need to modify the array after assigning it to a session namespace key, fetch the array, then
        </para>

        <example>
            <title>Workaround: fetch, modify, save</title>
<programlisting role="php">
<![CDATA[<?php
    $sessionNamespace = new Zend_Session_Namespace('Foo');
    $sessionNamespace->array = array('tree' => 'apple');
    $tmp = $sessionNamespace->array;
    $tmp['fruit'] = 'peach';
    $sessionNamespace->array = $tmp;
?>]]></programlisting>
        </example>

        <para>
            Alternatively, store an array containing a reference to the desired array, and then access it indirectly.
        </para>

        <example>
            <title>Workaround: store array containing reference</title>
<programlisting role="php">
<![CDATA[<?php
    $myNamespace = new Zend_Session_Namespace('mySpace');

    // works, even for broken versions of PHP
    $a = array(1,2,3);
    $myNamespace->someArray = array( & $a ) ;
    $a['foo'] = 'bar';
?>]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.session.auth">

        <title>Using Sessions with Authentication</title>

        <para>
            If your authentication adapter for <code>Zend_Auth</code> returns a result where the authorization identity
            is an object (not recommended), instead of an array, then make sure to require your authorization identity
            class definition before starting the session. Instead, we recommend storing the authorization ids computed
            within an authentication adapter inside a well-known key in a session namespace. For example, the default
            behavior of <code>Zend_Auth</code> places this in the 'storage' key of the 'Zend_Auth' namespace.
        </para>

        <para>
            If you tell <code>Zend_Auth</code> to not persist authentication tokens in sessions, then you can manually
            store the authorization id in the session namespace, in a well-known location in a session namespace of your
            choice. Often, applications have specific needs about where to store credentials used (if any) and
            "authorization" identity. Applications often map authentication identities (e.g. usernames) to authorization
            identities (e.g. a uniquely assigned integer) during authentication, which would occur in the Zend_Auth
            authentication adapter's <code>authenticate()</code> method.
        </para>

        <example>
            <title>Example: Simplified access of authorization ids</title>
<programlisting role="php">
<![CDATA[<?php
    // pre-authentication request
    require_once 'Zend/Auth/Adapter/Digest.php';
    $adapter = new Zend_Auth_Adapter_Digest($filename, $realm, $username, $password);
    $result = $adapter->authenticate();
    require_once 'Zend/Session/Namespace.php';
    $namespace = new Zend_Session_Namespace('Zend_Auth');
    if ($result->isValid()) {
        $namespace->authorizationId = $result->getIdentity();
        $namespace->date = time();
    } else {
        $namespace->attempts++;
    }

    // subsequent requests
    require_once 'Zend/Session.php';
    Zend_Session::start();
    $namespace = new Zend_Session_Namespace('Zend_Auth');

    echo "Valid: ", (empty($namespace->authorizationId) ? 'No' : 'Yes'), "\n"';
    echo "Authorization / user Id: ", (empty($namespace->authorizationId)
        ? 'none' : print_r($namespace->authorizationId, true)), "\n"';
    echo "Authentication attempts: ", (empty($namespace->attempts)
        ? '0' : $namespace->attempts), "\n"';
    echo "Authenticated on: ",
        (empty($namespace->date) ? 'No' : date(DATE_ATOM, $namespace->date), "\n"';
?>]]></programlisting>
        </example>

        <para>
            Authorization ids stored client-side are subject to privilege escalation vulnerabilities, if these ids are
            used and trusted by the server, unless, for example, the id is duplicated on the server-side (e.g. in the
            session) and then cross-checked with the authorization id claimed by the client for the in-effect session.
            We are differentiating between "authentication ids" (e.g. usernames) and "authorization ids" (e.g. user id
            #101 in the users DB table).
        </para>

        <para>
            The latter is not uncommon for performance reasons, such as helping select from a pool of servers caching
            session information to help solve chicken-and-egg problems. Often debates ensue about whether to use the
            real authorization id in the cookie, or some substitute that aids in mapping to the real authorization id
            (or session or server(s) holding the user's session/profile, etc.), as some system security architects wish
            to prevent true "DB primary keys" from escaping into the wild. These architects try and obtain some level of
            protection by obfuscation in the event of a SQL injection vulnerability in their system. Not everyone uses
            auto-increment strategies for authorization ids.
        </para>

    </sect2>

    <sect2 id="zend.session.testing">

        <title>Using Sessions with Unit Tests</title>

        <para>
            The Zend Framework relies on PHPUnit to facilitate testing of itself. Many developers extend the existing
            suite of unit tests to cover the code in their applications. The exception
            "<emphasis role="strong">Zend_Session is currently marked as read-only</emphasis>" is thrown while
            performing unit tests, if any write-related methods are used after ending the session. However, unit tests
            using Zend_Session require extra attention, because closing (<code>Zend_Session::writeClose()</code>), or
            destroying a session (<code>Zend_Session::destroy()</code>) prevents any further setting or unsetting of
            keys in any Zend_Session_Namespace. This behavior is a direct result of the underlying ext/session mechanism
            and PHP's <code>session_destroy()</code> and <code>session_write_close()</code>, which has no "undo"
            mechanism to facilitate setup/teardown with unit tests.
        </para>

        <para>
            To work around this, see the unit test <code>testSetExpirationSeconds()</code> in
            <code>tests/Zend/Session/SessionTest.php and SessionTestHelper.php</code>, which make use of PHP's
            <code>exec()</code> to launch a separate process. The new process more accurately simulates a second,
            successive request from a browser. The separate process begins with a "clean" session, just like any PHP
            script execution for a web request. Also, any changes to <code>$_SESSION[]</code> made in the calling
            process become available to the child process, provided the parent closed the session before using
            <code>exec()</code>
        </para>

        <example>
            <title>Using PHPUnit to test code written using Zend_Session*</title>
<programlisting role="php">
<![CDATA[<?php
        // testing setExpirationSeconds()
        require 'tests/Zend/Session/SessionTestHelper.php'; // also see SessionTest.php in trunk/
        $script = 'SessionTestHelper.php';
        $s = new Zend_Session_Namespace('space');
        $s->a = 'apple';
        $s->o = 'orange';
        $s->setExpirationSeconds(5);

        Zend_Session::regenerateId();
        $id = Zend_Session::getId();
        session_write_close(); // release session so process below can use it
        sleep(4); // not long enough for things to expire
        exec($script . "expireAll $id expireAll", $result);
        $result = $this->sortResult($result);
        $expect = ';a === apple;o === orange;p === pear';
        $this->assertTrue($result === $expect,
            "iteration over default Zend_Session namespace failed; expecting result === '$expect', but got '$result'");

        sleep(2); // long enough for things to expire (total of 6 seconds waiting, but expires in 5)
        exec($script . "expireAll $id expireAll", $result);
        $result = array_pop($result);
        $this->assertTrue($result === '',
            "iteration over default Zend_Session namespace failed; expecting result === '', but got '$result')");
        session_start(); // resume artificially suspended session

        // We could split this into a separate test, but actually, if anything leftover from above
        // contaminates the tests below, that is also a bug that we want to know about.
        $s = new Zend_Session_Namespace('expireGuava');
        $s->setExpirationSeconds(5, 'g'); // now try to expire only 1 of the keys in the namespace
        $s->g = 'guava';
        $s->p = 'peach';
        $s->p = 'plum';

        session_write_close(); // release session so process below can use it
        sleep(6); // not long enough for things to expire
        exec($script . "expireAll $id expireGuava", $result);
        $result = $this->sortResult($result);
        session_start(); // resume artificially suspended session
        $this->assertTrue($result === ';p === plum',
            "iteration over named Zend_Session namespace failed (result=$result)");
?>]]></programlisting>
        </example>

    </sect2>

</sect1>
