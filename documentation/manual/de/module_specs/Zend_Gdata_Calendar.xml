<sect1 id="zend.gdata.calendar">
    <title>Google Kalender verwenden</title>
    <para>
        Die <code>Zend_Gdata_Calendar</code> Klasse kann verwendet werden um Events im Online Google Kalender
        Service zu sehen, erstellen, updaten und löschen.
    </para>
    <para>
        Siehe
        <ulink url="http://code.google.com/apis/calendar/overview.html">http://code.google.com/apis/calendar/overview.html</ulink>
        für weitere Informationen über die Google Kalender API.
    </para>
    <sect2 id="zend.gdata.calendar.connecting">
        <title>Zum Kalender Service verbinden</title>
        <para>
            Die Google Kalender API basiert, wie alle GData APIs, auf dem Atom Publishing Protocol (APP), einem
            XML basierenden Format für gemanagte Web-basierte Ressourcen. Verkehr zwischen einem Client und den
            Google Kalender Servern läuft über HTTP und erlaubt sowohl authentifizierte als auch unauthentifizierte
            Verbindungen.
        </para>
        <para>
            Bevor irgendeine Transaktion stattfinden kann, muß diese Verbindung erstellt werden. Die Erstellung
            einer Verbindung zu den Kalender Server beinhaltet zwei Schritte: Erstellung eines HTTP Clients und
            das binden einer <code>Zend_Gdata_Calendar</code> Instanz an diesen Client.
        </para>
        <sect3 id="zend.gdata.calendar.connecting.authentication">
            <title>Authentifizierung</title>
            <para>
                Die Google Kalender API erlaubt den Zugriff auf beide, öffentliche und private, Kalender Feeds.
                Öfentliche Foods benötigen keine Authentifizierung, aber sie können nur gelesen werden und bieten
                reduzierte Funktionalitäten. Private Feeds bieten die kompletteste Funktionalität benötigen aber
                eine authentifizierte Verbindung zu den Kalender Servern. Es gibt drei Authentifizierungs
                Schemas die von Google Kalender unterstützt werden:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <firstterm>ClientAuth</firstterm> bietet direkte Benutzername/Passwort Authentifizierung
                        zu den Kalender Servern. Da dieses Schema erfordert das Benutzer die Anwendung mit Ihrem
                        Passwort versorgen, ist diese Authentifizierung nur zu empfehlen wenn andere
                        Authentifizierungs Schemas nicht anwendbar sind.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>AuthSub</firstterm> erlaubt die Authentifizierung zu den Kalender Servern über
                        einen Google Proxy Server. Das bietet den gleichen Level von Bequemlichkeit wie
                        ClientAuth aber ohne die Sicherheits Risiken, was es zu einer idealen Wahl für Web
                        basierende Anwendungen macht.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>MagicCookie</firstterm> erlaubt die Authentifizierung basieren auf einer
                        semi-zufälligen URL von immerhalb des Google Kalender Interfaces. Das ist das einfachste
                        Authentifizierungs Schema das implmentiert werden kann, erzwingt aber das Benutzer
                        ihre Sicherheits URL manuell empfangen, bevor sie sich authentifizieren können, und ist
                        limitiert auf nur-lesenden Zugriff.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Die <code>Zend_Gdata</code> Bibliothek bietet Unterstützung für alle drei Authentifizierungs
                Schemas. Der Rest dieses Kapitels nimmt an das die vorhandenen Authentifizierungs Schemas
                geläufig sind und wie eine korrekte Authentifizierte Verbindung erstellt wird. Für weitere Details
                kann in die <link linkend="zend.gdata.introduction.authentication">Authentifizierungs Sektion</link>
                dieses Handbuches, oder in die
                <ulink url="http://code.google.com/apis/gdata/auth.html">Authentifizierungs Übersicht im Google Data API Entwickler Guide</ulink>.
                gesehen werden.
            </para>
        </sect3>
        <sect3 id="zend.gdata.calendar.connecting.service">
            <title>Eine Service Instanz erstellen</title>
            <para>
                Um mit dem Google Kalender zu interagieren, bietet diese Bibliothek die
                <code>Zend_Gdata_Calendar</code> Service Klasse. Diese Klasse bietet ein übliches Interface zu den
                Google Data und Atom Publishing Protocol Modellen und assistiert in der Behandlung der Anfragen
                zum und von den Kalender Servern.
            </para>
            <para>
                Sobald ein Authentifizierung Schema ausgewählt wurde, besteht der nächste Schritt darin eine
                Instanz von <code>Zend_Gdata_Calendar</code> zu erstellen. Der Klassen Konstruktor nimmt eine
                Instanz von <code>Zend_Http_Client</code> als einzelnes Argument. Das bietet ein Interface für
                AuthSub und ClientAuth Authentifizierungen, da beide von Ihnen die Erstellung eines speziellen
                authentifizierten  HTTP Clients benötigen. Wenn keine Argumente angegeben werden, wird
                automatisch eine unauthentifizierte Instanz von <code>Zend_Http_Client</code> erstellt.
            </para>
            <para>
                Das folgende Beispiel zeigt wie man eine Kalender Service Klasse erstellt und dabei die
                ClientAuth Authentifizierung verwendet:
            </para>
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Loader.php';
Zend_Loader::loadClass('Zend_Gdata');
Zend_Loader::loadClass('Zend_Gdata_ClientLogin');
Zend_Loader::loadClass('Zend_Gdata_Calendar');
Zend_Loader::loadClass('Zend_Http_Client');

// Parameter für die ClientAuth Authentifizierung
$service = Zend_Gdata_Calendar::AUTH_SERVICE_NAME;
$user = "sample.user@gmail.com";
$pass = "pa$$w0rd";

// Erstellt einen authentifizierten HTTP Client
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);

// Erstellt eine Instanz des Kalender Services
$service = new Zend_Gdata_Calendar($client);]]>
            </programlisting>
            <para>
                Ein Kalender Service der AuthSub verwendet, kann ähnlich erstellt werden, durch eine etwas längere
                Schreibweise:</para>
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Loader.php';
Zend_Loader::loadClass('Zend_Gdata');
Zend_Loader::loadClass('Zend_Gdata_AuthSub');
Zend_Loader::loadClass('Zend_Gdata_Calendar');
Zend_Loader::loadClass('Zend_Http_Client');

/** Empfängt die aktuelle URL so das der AuthSub Server weiß wohin er den Benutzer
 * umleiten soll nachdem die Authentifizierung komplett ist.
 */
function getCurrentUrl()
{
    global $_SERVER;

    // Filtert php_self um Sicherheitsprobleme zu vermeiden.
    $php_request_uri = htmlentities(substr($_SERVER['REQUEST_URI'], 0, strcspn($_SERVER['REQUEST_URI'], "\n\r")), ENT_QUOTES);

    if (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) == 'on') {
        $protocol = 'https://';
    } else {
        $protocol = 'http://';
    }
    $host = $_SERVER['HTTP_HOST'];
    if ($_SERVER['HTTP_PORT'] != '' &&
        (($protocol == 'http://' && $_SERVER['HTTP_PORT'] != '80') ||
        ($protocol == 'https://' && $_SERVER['HTTP_PORT'] != '443'))) {
        $port = ':' . $_SERVER['HTTP_PORT'];
    } else {
        $port = '';
    }
    return $protocol . $host . $port . $php_request_uri;
}

/** Einen AuthSub authentifizierten HTTP Client nehmen, der den Benutzer zum
 * AuthSub Server zum Login umleitet wenn es notwendig ist.
 */
function getAuthSubHttpClient()
{
    global $_SESSION, $_GET;

    // Wenn es keine AuthSub Session oder einmal-benutzbares Token gibt der auf uns wartet,
    // den Benutzer zum AuthSub Server umleiten um einen zu erhalten.
    if (!isset($_SESSION['sessionToken']) && !isset($_GET['token'])) {
        // Parameter für den AuthSub Server
        $next = getCurrentUrl();
        $scope = "http://www.google.com/calendar/feeds/";
        $secure = false;
        $session = true;

        // Den Benutzer zum AuthSub server umleiten zur Anmeldung

        $authSubUrl = Zend_Gdata_AuthSub::getAuthSubTokenUri($next, $scope, $secure, $session);
         header("HTTP/1.0 307 Temporary redirect");

         header("Location: " . $authSubUrl);

         exit();
    }

    // Konvertiert ein AuthSub einmal-benutzbares Token in ein Session Token wenn das notwendig ist
    if (!isset($_SESSION['sessionToken']) && isset($_GET['token'])) {
        $_SESSION['sessionToken'] =
            Zend_Gdata_AuthSub::getAuthSubSessionToken($_GET['token']);
    }

    // An diesem Punkt sind wir authentifiziert über AuthSub und können eine authentifizierte
    // HTTP Client Instanz holen

    // Erstellt einen authentifizierte HTTP Client
    $client = Zend_Gdata_AuthSub::getHttpClient($_SESSION['sessionToken']);
    return $client;
}

// -> Skript Bearbeitung beginnt hier <-

// Sicher stellen http://code.google.com/apis/gdata/reference.html#Queriesthat das der Benutzer eine
// gültige Session hat, sodas der AuthSub Session Token gespeichert werden kann sobald er vorhanden ist.
session_start();

// Erstellt eine Instanz des Kalender Services, und leitet den Benutzer zum AuthSub Server
// um wenn das notwendig ist.
$service = new Zend_Gdata_Calendar(getAuthSubHttpClient());]]>
            </programlisting>
            <para>
                Schlußendlich, kann ein nicht authentifizierter Server erstellt werden um Ihn entweder mit
                öffentlichen Feeds oder MagicCookie Authentifizierung zu verwenden:</para>
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Loader.php';
Zend_Loader::loadClass('Zend_Gdata');
Zend_Loader::loadClass('Zend_Gdata_Calendar');


// Erstellt eine Instanz des Kalender Services wobei ein nicht authentifizierter HTTP Client verwendet wird

$service = new Zend_Gdata_Calendar();]]>
            </programlisting>
            <para>
                Es ist zu beachten das die MagicCookie Authentifizierung nicht mit der HTTP Verbindung
                unterstützt wird, sonder stattdessen wärend der gewählten Sichtbarkeit spezifiziert wird,
                wärend Anfragen abgeschickt werden. Siehe die folgende Sektion über das empfangen von Events
                für ein Beispiel.
            </para>
        </sect3>
    </sect2>
    <sect2 id="zend.gdata.calendar_retrieval">
        <title>Eine Kalender Liste empfangen</title>
        <para>
            Der Kalender Service unterstützt den Empfang einer Liste von Kalendern für den authentifizierten
            Benutzer. Das ist die gleiche Liste von Kalendern welche im Google Kalender UI angezeigt werden,
            ausser das jene die als "<code>hidden</code>" markiert sind, auch vorhanden sind.
        </para>
        <para>
            Die Kalender Liste ist immer privat und es muß über eine authentifizierte Verbindung darauf
            zugegriffen werden. Es ist nicht möglich eine Kalender Liste eines anderen Benutzers zu erhalten und
            es kann nicht darauf zugegriffen werden wenn die MagicCookie Authentifizierung verwendet wird.
            Der Versuch auf eine Kalender Liste zuzugreifen ohne das die notwendigen Zugriffsrechte vorhanden
            sind, wird fehlschlagen und in einem 401 (Authentifizierung benötigt) Statuc Code resultieren.
        </para>
        <programlisting role="php"><![CDATA[<?php
$service = Zend_Gdata_Calendar::AUTH_SERVICE_NAME;
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
$service = new Zend_Gdata_Calendar($client);

try {
    $listFeed= $service->getCalendarListFeed();
} catch (Zend_Gdata_App_Exception $e) {
    echo "Fehler: " . $e->getResponse();
}]]>
        </programlisting>
        <para>
            Der Aufruf von <code>getCalendarListFeed()</code> erstellt eine neue Instanz von
            <code>Zend_Gdata_Calendar_ListFeed</code> die jeden vorhandenen Kalender als Instanz von
            <code>Zend_Gdata_Calendar_ListEntry</code> enthält. Nachdem der Feed empfangen wurde, können der
            Iterator und der Accessor die innerhalb des Feeds enthalten sind, verwendet werden um die enthaltenen
            Kalender zu inspizieren.
        </para>
        <programlisting role="php"><![CDATA[<?php
echo "<h1>Kalender Feed Liste</h1>";
echo "<ul>";
foreach ($listFeed as $calendar) {
    echo "<li>" . $calendar->title . " (Event Feed: " . $calendar->id . ")</li>";
}
echo "</ul>";]]>
        </programlisting>
    </sect2>
    <sect2 id="zend.gdata.event_retrieval">
        <title>Events erhalten</title>
        <para>
            Wie die Liste der Kalender können auch die Events empfangen werden durch Verwendung der
            <code>Zend_Gdata_Calendar</code> Service Klasse. Die zurückgegebene Event Liste ist vom Typ
            <code>Zend_Gdata_Calendar_EventFeed</code> und enthält jedes Event als Instanz von
            <code>Zend_Gdata_Calendar_EventEntry</code>. Wie vorher, erlauben die in der Instanz des Event Feeds
            enthaltenen Accessoren und der Iterator das individuelle Events inspiziert werden können.
        </para>
        <sect3 id="zend.gdata.event_retrieval.queries">
            <title>Abfragen</title>
            <para>
                Wenn Events mit der Kalender API empfangen werden, werden speziell erstellte Abfrage URLs verwendet
                um zu beschreiben welche Events zurückgegeben werden sollten. Die
                <code>Zend_Gdata_Calendar_EventQuery</code> Klasse vereinfacht diese Aufgabe durch
                automatische Erstellung einer Abfrage URL basierend auf den gegebenen Parametern. Eine komplette
                Liste dieser Parameter ist in der
                <ulink url="http://code.google.com/apis/gdata/reference.html#Queries">Abfrage Sektion des
                Google Data API Protokoll Referenz</ulink> enthalten. Trotzdem gibt es drei Parameter die es
                Wert sind speziell genannt zu werden:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <firstterm>User</firstterm> wird verwendet um den Benutzer zu spezifizieren dessen
                        Kalender gesucht wird, und wird als EMail Adresse spezifiziert. Wenn kein Benutzer
                        angegeben wurde, wird stattdessen "default" verwendet um den aktuellen authentifizierten
                        Benutzer anzuzeigen  (wenn er authentifiziert wurde).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Visibility</firstterm> spezifiziert ob der öffentliche oder private Kalender
                        eines Benutzers gesucht werden soll. Wenn eine nicht authentifizierte Session verwendet
                        wird und kein MagicCookie vorhanden ist, ist nur der öffentliche Feed vorhanden.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Projection</firstterm> spezifiziert wieviele Daten vom Server zurückgegeben
                        werden sollen, und in welchem Format. In den meisten Fällen wird man die komplette
                        ("full") Projektion verwenden wollen. Auch die normale ("basic") Projektion ist vorhanden,
                        welche die meisten Meta-Daten in jedem Inhaltsfeld der Events als menschlich lesbaren
                        Text plaziert, und die kombinierte ("composite") Projketion welche den kompletten
                        text für jedes Kommentar entlang jedes Events inkludiert. Die kombinierte ("composite")
                        Ansicht ist oft viel größer als die komplette ("full") Ansicht.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>
        <sect3 id="zend.gdata.event_retrieval.start_time">
            <title>Events in der Reihenfolge Ihres Startzeitpunktes erhalten</title>
            <para>
                Das folgende Beispiel zeigt die Verwendung der <code>Zend_Gdata_Query</code> Klasse und spezifiziert
                den privat sichtbaren Feed, welcher eine vorhandene authentifizierte Verbindung zu den Kalender
                Servern benötigt. Wenn ein MagicCookie für die Authentifizierung verwendet wird, sollte die
                Sichtbarkeit zuerst auf "<code>private-magicCookieValue</code>" gesetzt werden, sobei
                magicCookieValue der zufälliger String ist, der erhalten wird, wenn man die private XML Adresse
                im Google Kalender UI betrachtet. Events werden chronologisch anhand des Startzeitpunktes angefragt
                und nur Events die in der Zukunft stattfinden werden zurückgegeben.
            </para>
            <programlisting role="php"><![CDATA[<?php
$query = $service->newEventQuery();
$query->setUser('default');
// Setze $query->setVisibility('private-magicCookieValue') wenn MagicCookie Authentifizierung verwendet wird
$query->setVisibility('private');
$query->setProjection('full');
$query->setOrderby('starttime');
$query->setFutureevents('true');

// Empfängt die Event Liste vom Kalender Server
try {
    $eventFeed = $service->getCalendarEventFeed($query);
} catch (Zend_Gdata_App_Exception $e) {
    echo "Fehler: " . $e->getResponse();
}

// Iteriere durch die Liste der Events und gib Sie als HTML Liste aus
echo "<ul>";
foreach ($eventFeed as $event) {
    echo "<li>" . $event->title . " (Event ID: " . $event->id . ")</li>";
}
echo "</ul>";]]>
            </programlisting>
            <para>
                Zusätzliche Eigenschaften wie ID, Autor, Wann, Event Status, Sichtbarkeit, Web Inhalt, und Inhalt,
                sowie andere sind innerhalb von <code>Zend_Gdata_Calendar_EventEntry</code> vorhanden. Siehe die
                <ulink url="http://framework.zend.com/apidoc/core/">Zend Framework API Dokumentation</ulink> und
                die <ulink url="http://code.google.com/apis/gdata/reference.html">Lalender Protokol Referenz</ulink>
                für eine komplette Liste.
            </para>
        </sect3>
        <sect3 id="zend.gdata.event_retrieval.date_range">
            <title>Events in einem speziellen Datumsbereich empfangen</title>
            <para>
                Um alle Events in einem gewünschten Bereich auszugeben, zum Beispiel vom 1. Dezember 2006 bis zum
                15. Dezember 2006, müssen die folgenden zwei Zeilen im vorhergehenden Beispiel hinzugefügt werden.
                Es ist zu beachten das "<code>$query->setFutureevents('true')</code>" entfernt werden muß, da
                <code>futureevents</code> die Werte von <code>startMin</code> und <code>startMax</code>
                überschreibt.
            </para>
            <programlisting role="php"><![CDATA[<?php
$query->setStartMin('2006-12-01');
$query->setStartMax('2006-12-16');]]>
            </programlisting>
            <para>
                Es ist zu beachten das <code>startMin</code> inklusive ist, wobei <code>startMax</code> exklusive
                ist. Als Ergebnis, werden nur die Events bis 2006-12-15 23:59:59 zurückgegeben.
            </para>
        </sect3>
        <sect3 id="zend.gdata.event_retrieval.fulltext">
            <title>Events durch eine Volltext Abfrage erhalten</title>
            <para>
                Um alle Events auszugeben welche ein spezielles Wort, zum Beispiel "Hundefutter" enthalten,
                muß die  <code>setQuery()</code> Methode verwendet werden wenn die Abfrage erstellt wird.
            </para>
            <programlisting role="php"><![CDATA[<?php
$query->setQuery("Hundefutter");]]>
            </programlisting>
        </sect3>
        <sect3 id="zend.gdata.event_retrieval.individual">
            <title>Individuelle Events erhalten</title>
            <para>
                Individuelle Events können empfangen werden indem deren Event ID als Teil der Abfrage spezifiziert
                wird. Statt <code>getCalendarEventFeed()</code> auszurufen, sollte
                <code>getCalendarEventEntry()</code> aufgerufen werden.
            </para>
            <programlisting role="php"><![CDATA[<?php
$query = $service->newEventQuery();
$query->setUser('default');
$query->setVisibility('private');
$query->setProjection('full');
$query->setEvent($eventId);

try {
    $event = $service->getCalendarEventEntry($query);
} catch (Zend_Gdata_App_Exception $e) {
    echo "Fehler: " . $e->getResponse();
}]]>
            </programlisting>
            <para>
                In einer ähnlichen Weise kann Sie, wenn die Event URL bekannt ist, direkt an
                <code>getCalendarEntry()</code> übergeben werden um ein spezielles Event zu erhalten. In diesem
                Fall wird kein Abfrage Objekt benötigt da die Event URL alle notwendigen Informationen enthält um
                das Event zu erhalten.
            </para>
            <programlisting role="php"><![CDATA[<?php
$eventURL = "http://www.google.com/calendar/feeds/default/private/full/g829on5sq4ag12se91d10uumko";

try {
    $event = $service->getCalendarEventEntry($eventURL);
} catch (Zend_Gdata_App_Exception $e) {
    echo "Fehler: " . $e->getResponse();
}]]>
            </programlisting>
        </sect3>
    </sect2>
    <sect2 id="zend.gdata.calendar.creating_events">
        <title>Events erstellen</title>
        <sect3 id="zend.gdata.calendar.creating_events.single">
            <title>Ein einmal vorkommendes Event erstellen</title>
            <para>
                Events werden einem Kalender hinzugefügt indem eine Instanz von  <code>Zend_Gdata_EventEntry</code>
                erstellt wird, und diese mit den richtigen Daten bekanntgegeben wird. Die Kalender Service Instanz
                (<code>Zend_Gdata_Calendar</code>) wird dann verwendet um das Event transparent in XML zu
                konvertieren und diese an den Kalender Server zu senden.
            </para>
            <para>Mindestens die folgenden Attribute sollten gesetzt werden:</para>
            <itemizedlist>
                <listitem>
                    <para>
                        <firstterm>Title</firstterm> enthält die Kopfzeile die über jedem Event innerhalb der
                        Google Kalender UI angezeigt wird.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>When</firstterm> zeigt die Dauer des Events und, optional, jede Erinnerung die
                        mit Ihm assoziiert ist. Siehe in die nächste Sektion für mehr Informationen über dieses
                        Attribut.
                    </para>
                </listitem>
            </itemizedlist>
            <para>Andere nützliche Attribute die optional gesetzt werden können sind unter anderem:</para>
            <itemizedlist>
                <listitem>
                    <para>
                        <firstterm>Author</firstterm> liefert Informationen über den Benutzer der das Event
                        erstellt hat.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Content</firstterm> liefert zusätzliche Information über das Event und wird
                        angezeigt wenn die Event Details innerhalb des Google Kalenders angefragt werden.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>EventStatus</firstterm> zeigt an ob ein Event bestätigt, in Wartestellung
                        oder abgebrochen wurde.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Hidden</firstterm> entfernt das Event von der Google Kalender UI.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Transparency</firstterm> zeigt ob das Event Zeit auf der Frei/Belegt Liste
                        des Benutzers benötigt.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>WebContent</firstterm> erlaubt es externe Inhalte zu verlinken und innerhalb
                        eines Events anzubieten.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Where</firstterm> indiziert den Ort des Events.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Visibility</firstterm> erlaubt es das Event vor der öffentlichen Event Liste
                        zu verstecken.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Für eine komplette Liste an Event Attributen, kann in die
                <ulink url="http://framework.zend.com/apidoc/core/">Zend Framework API Documentation</ulink> und die
                <ulink url="http://code.google.com/apis/gdata/reference.html">Kalender Protokol Referenz</ulink>
                gesehen werden. Attribute die mehrfache Werte enthalten können, wo wie "where", sind als Arrays
                implementiert und müssen korrekt erstellt werden. Es ist zu beachten das alle diese Attribute
                Objekte als Parameter benötigen. Der Versuch diese stattdessen als Strings oder Primitivvariablen
                bekanntzugeben wird in einem Fehler wärend der Konvertierung in XML führen.
            </para>
            <para>
                Sobald das Event bekanntgegeben wurde, kann es zum Kalender Server hochgeladen werden durch
                seine Übergabe als Argument zur <code>insertEvent()</code> Funktion des Kalender Services.
            </para>
            <programlisting role="php"><![CDATA[<?php
// Erstellt einen neuen Eintrag und verwendet die magische Factory Methode vom Kalender Service
$event= $service->newEventEntry();

// Gibt das Event bekannt mit den gewünschten Informationen
// Beachte das jedes Attribu als Instanz der zugehörenden Klasse erstellt wird
$event->title = $service->newTitle("Mein Event");
$event->where = array($service->newWhere("Berg Ansicht, Kalifornien"));
$event->content = $service->newContent(" Das ist mein super Event. RSVP benötigt.");

// Setze das Datum und verwende das RFC 3339 Format.
$startDate = "2008-01-20";
$startTime = "14:00";
$endDate = "2008-01-20";
$endTime = "16:00";
$tzOffset = "-08";

$when = $service->newWhen();
$when->startTime = "{$startDate}T{$startTime}:00.000{$tzOffset}:00";
$when->endTime = "{$endDate}T{$endTime}:00.000{$tzOffset}:00";
$event->when = array($when);

// Das Event an den Kalender Server hochladen
// Eine Kopie des Events wird zurückgegeben wenn es am Server gespeichert wird
$newEvent = $service->insertEvent($event);]]>
            </programlisting>
        </sect3>
        <sect3 id="zend.gdata.calendar.creating_events.schedulers_reminders">
            <title>Event Schedules and Reminders</title>
            <para>
                An event's starting time and duration are determined by the value of its when property, which contains the properties
                <code>startTime</code>
                ,
                <code>endTime</code>
                , and
                <code>valueString</code>
                .
                <code>StartTime</code>
                and
                <code>EndTime</code>
                control the duration of the event, while
                <code>valueString</code>
                provides a way to store a friendly, human readable version of the duration such as "This Afternoon". Note that even when using
                <code>valueString</code>
                ,
                <code>startTime</code>
                and
                <code>endTime</code>
                still must be be set to valid values.
            </para>
            <para>
                All-day events can be scheduled by specifying only the date omitting the time when setting
                <code>startTime</code>
                and
                <code>endTime</code>
                . Likewise, zero-duration events can be specified by omitting the
                <code>endTime</code>
                . In all cases, date/time values should be provided in
                <ulink url="http://www.ietf.org/rfc/rfc3339.txt">RFC3339</ulink>
                format.
            </para>
            <programlisting role="php"><![CDATA[<?php
// Schedule the event to occur on December 05, 2007 at 2 PM PST (UTC-8) with a duration of one hour.
$when = $service->newWhen();
$when->startTime = "2007-12-05T14:00:00-08:00";
$when->endTime="2007-12-05T15:00:00:00-08:00";

// Specify a optional human readable value for the above date
$when->valueString = "This Afternoon";

// Apply the when property to an event
$event->when = $when;]]>
            </programlisting>
            <para>
                The
                <code>when</code>
                attribute also controls when reminders are sent to a user. Reminders are stored in an array and each event may have up to find reminders associated with it.
            </para>
            <para>
                For a
                <code>reminder</code>
                to be valid, it needs to have two attributes set:
                <code>method</code>
                and a time.
                <code>Method</code>
                can accept one of the following strings: "alert", "email", or "sms". The time should be entered as an integer and can be set with either the property
                <code>minutes</code>
                ,
                <code>hours</code>
                ,
                <code>days</code>
                , or
                <code>absoluteTime</code>
                . However, a valid request may only have one of these attributes set. If a mixed time is desired, convert to the most precise unit available. For example, 1 hour and 30 minutes should be entered as 90 minutes.
            </para>
            <programlisting role="php"><![CDATA[<?php
// Create a new reminder object. It should be set send an email message to the user 10 minutes beforehand.
$reminder = $service->newReminder();
$reminder->method = "email";
$reminder->minutes = "10";

// Apply the reminder to an existing event's when property
$when = $event->when[0];
$when->reminders = array($reminder);]]>
            </programlisting>
        </sect3>
        <sect3 id="zend.gdata.calendar.creating_events.recurring">
            <title>Creating Recurring Events</title>
            <para>
                Recurring events are created the same way as single-occurrence events, except a recurrence attribute should be provided instead of a where attribute. The recurrence attribute should hold a string describing the event's recurrence pattern using properties defined in the iCalendar standard (
                <ulink url="http://www.ietf.org/rfc/rfc2445.txt">RFC 2445</ulink>
                ).
            </para>
            <para>
                Exceptions to the recurrence pattern will usually be specified by a distinct
                <code>recurrenceException</code>
                attribute. However, the iCalendar standard provides a secondary format for defining recurrences, and the possibility that either may be used must be accounted for.
            </para>
            <para>
                Due to the complexity of parsing recurrence patterns, further information on this them is outside the scope of this document. However, more information can be found in the
                <ulink url="http://code.google.com/apis/gdata/elements.html#gdRecurrence">Common Elements section of the Google Data APIs Developer Guide</ulink>
                , as well as in RFC 2445.
            </para>
            <programlisting role="php"><![CDATA[<?php
 // Create a new entry using the calendar service's magic factory method
$event= $service->newEventEntry();

// Populate the event with the desired information
// Note that each attribute is crated as an instance of a matching class
$event->title = $service->newTitle("My Recurring Event");
$event->where = array($service->newWhere("Palo Alto, California"));
$event->content = $service->newContent(" This is my other awesome event, occurring all-day every Tuesday from 2007-05-01 until 207-09-04. No RSVP required.");

// Set the duration and frequency by specifying a recurrence pattern.

$recurrence = "DTSTART;VALUE=DATE:20070501\r\n" .
        "DTEND;VALUE=DATE:20070502\r\n" .
        "RRULE:FREQ=WEEKLY;BYDAY=Tu;UNTIL=20070904\r\n";

$event->recurrence = $service->newRecurrence($recurrence);

// Upload the event to the calendar server
// A copy of the event as it is recorded on the server is returned
$newEvent = $service->insertEvent($event);]]>
            </programlisting>
        </sect3>
        <sect3 id="zend.gdata.calendar.creating_events.quickadd">
            <title>Using QuickAdd</title>
            <para>
                QuickAdd is a feature which allows events to be created using free-form text entry. For example, the string "Dinner at Joe's Diner on Thursday" would create an event with the title "Dinner", location "Joe's Diner", and date "Thursday". To take advantage of QuickAdd, create a new
                <code>QuickAdd</code>
                property set to "true" and store the freeform text as a
                <code>content</code>
                property.
            </para>
            <programlisting role="php"><![CDATA[<?php
// Create a new entry using the calendar service's magic factory method
$event= $service->newEventEntry();

// Populate the event with the desired information
$event->content= $service->newContent("Dinner at Joe's Diner on Thursday");
$event->quickAdd = $service->newQuickAdd("true");

// Upload the event to the calendar server
// A copy of the event as it is recorded on the server is returned
$newEvent = $service->insertEvent($event);]]>
            </programlisting>
        </sect3>
    </sect2>
    <sect2 id="zend.gdata.calendar.modifying_events">
        <title>Modifying Events</title>
        <para>
            Once an instance of an event has been obtained, the event's attributes can be locally modified in the same way as when creating an event. Once all modifications are complete, calling the event's
            <code>save()</code>
            method will upload the changes to the calendar server and return a copy of the event as it was created on the server.
        </para>
        <para>
            In the event another user has modified the event since the local copy was retrieved,
            <code>save()</code>
            will fail and the server will return a 409 (Conflict) status code. To resolve this a fresh copy of the event must be retrieved from the server before attempting to resubmit any modifications.
        </para>
        <programlisting role="php"><![CDATA[<?php
// Get the first event in the user's event list
$event = $eventFeed[0];

// Change the title to a new value
$event->title = $service->newTitle("Woof!");

// Upload the changes to the server
try {
    $event->save();
} catch (Zend_Gdata_App_Exception $e) {
    echo "Error: " . $e->getResponse();
}]]>
        </programlisting>
    </sect2>
    <sect2 id="zend.gdata.calendar.deleting_events">
        <title>Deleting Events</title>
        <para>
            Calendar events can be deleted either by calling the calendar service's
            <code>delete()</code>
            method and providing the edit URL of an event or by calling an existing event's own
            <code>delete()</code>
            method.
        </para>
        <para>
            In either case, the deleted event will still show up on a user's private event feed if an
            <code>updateMin</code>
            query parameter is provided. Deleted events can be distinguished from regular events because they will have their
            <code>eventStatus</code>
            property set to "http://schemas.google.com/g/2005#event.canceled".
        </para>
        <programlisting role="php"><![CDATA[<?php
// Option 1: Events can be deleted directly
$event->delete();]]>
        </programlisting>
        <programlisting role="php"><![CDATA[<?php
// Option 2: Events can be deleted supplying the edit URL of the event to the calendar service, if known
$service->delete($event->getEditLink()->href);]]>
        </programlisting>
    </sect2>
    <sect2 id="zend.gdata.calendar.comments">
        <title>Accessing Event Comments</title>
        <para>When using the full event view, comments are not directly stored within an entry. Instead, each event contains a URL to it's associated comment feed which must be manually requested.</para>
        <para>
            Working with comments is fundamentally similar to working with events, with the only significant difference being that a different feed and event class should be used and that the additional meta-data for events such as where and when does not exist for comments. Specifically, the comment's author is stored in the
            <code>author</code>
            property, and the comment text is stored in the
            <code>content</code>
            property.
        </para>
        <programlisting role="php"><![CDATA[<?php
// Extract the comment URL from the first event in a user's feed list
$event = $eventFeed[0];
$commentUrl = $event->comments->feedLink->url;

// Retrieve the comment list for the event
try {
$commentFeed = $service->getFeed($commentUrl);
} catch (Zend_Gdata_App_Exception $e) {
    echo "Error: " . $e->getResponse();
}

// Output each comment as an HTML list
echo "<ul>";
foreach ($commentFeed as $comment) {
    echo "<li><em>Comment By: " . $comment->author->name "</em><br/>" . $comment->content . "</li>";
}
echo "</ul>";]]>
        </programlisting>
    </sect2>
</sect1>
