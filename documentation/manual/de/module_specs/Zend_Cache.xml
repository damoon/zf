<sect1 id="zend.cache.introduction">
    <title>Einführung</title>
    <para>
        <code>Zend_Cache</code> bietet einen generellen Weg für das Cachen von Daten.
    </para>
    <para>
      Cachen im Zend Framework wird mit Frontends durchgeführt, wobei Cache Datensätze über Backend Adapter
      (<code>File</code>, <code>Sqlite</code>, <code>Memcache</code>...), durch ein flexibles System von
      IDs und Tags, gespeichert werden. Durch deren Verwendung ist es einfach, spezielle Typen von Datensätzen im 
      Nachhinein zu Löschen (zum Beispiel: "Löschen aller Cache Datensätze welche mit einem bestimmten
      Tag markiert sind").
    </para>
    <para>
        Der Kern des Moduls (<code>Zend_Cache_Core</code>) ist generell, flexibel und konfigurierbar.
        Nun gibt es - für spezielle Bedürfnisse - Cache Frontends, welche <code>Zend_Cache_Core</code>
        erweitern: <code>Output</code>, <code>File</code>, <code>Function</code> und <code>Class</code>.
    </para>
    <example>
        <title>Ein Frontend mit <code>Zend_Cache::factory()</code> erzeugen</title>
        <para>
            <code>Zend_Cache::factory()</code> instanziiert korrekte Objekte und fügt sie zusammen.
            In diesem ersten Beispiel wird das <code>Core</code> Frontend zusammen mit dem 
            <code>File</code> Backend verwendet.
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200, // Lebensdauer des Caches 2 Stunden 
   'automaticSerialization' => true
);

$backendOptions = array(
    'cacheDir' => './tmp/' // Verzeichnis, in welches die Cache Dateien kommen
);

// Ein Zend_Cache_Core Objekt erzeugen
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?>]]></programlisting>
       </para>
       <para>
            Jetzt, da wir ein Frontend haben, kann jeder Typ von Daten gecached werden (Serialisierung ist
            eingeschaltet). Zum Beispiel können Ergebnisse von sehr umfangreichen Datenbankabfragen
            gecached werden. Nach dem Cachen ist es sogar gar nicht nicht mehr notwendig, eine Verbindung
            zur Datenbank zu machen; Datensätze werden vom Cache genommen und deserialisiert.
            <programlisting role="php"><![CDATA[<?php

// $cache initialisiert im vorhergehenden Beispiel

// Nachsehen, ob der Cache bereits existiert:
if(!$result = $cache->get('myresult')) {

    // Cache miss; mit Datenbank verbinden
    
    $db = Zend_Db::factory( [...] );
    
    $result = $db->fetchAll('SELECT * FROM huge_table');
    
    $cache->save($result, 'myresult');
    
} else {

    // Cache hit! Ausgeben, damit wir es wissen
    echo "Der ist vom Cache!\n\n";
    
}

print_r($result);

?>]]></programlisting>
       </para>
    </example>
    <example>
        <title>Cache Ausgabe mit dem <code>Zend_Cache</code> Frontend</title>
        <para>
            Abschnitte, in denen die Ausgabe gecached werden soll, werden 'markiert', durch Hinzufügen
            von etwas bedingter Logik, wobei der Abschnitt innerhalb der <code>start()</code> und <code>end()</code> Methoden
            gekapselt wird (das ähnelt dem ersten Beispiel, und ist eine Kernstrategie für das Cachen).
        </para>
        <para>
            Darin muß die Ausgabe der Daten wie immer geschehen - jede Ausgabe wird gecached, wenn die Ausführung auf
            die <code>end()</code> Methode trifft. Bei der nächsten Ausführung wird der komplette Abschnitt
            übersprungen, dafür werden die Daten vom Cache geholt (solange der Cache Datensatz gültig ist).
            <programlisting role="php"><![CDATA[<?php

$frontendOptions = array(
   'lifeTime' => 30,                  // Lebenszeit des Caches wir auf eine halbe Minute gesetzt
   'automaticSerialization' => false  // Dieser Wert ist auf alle Fälle Standard
);

$backendOptions = array('cacheDir' => './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// Wir übergeben eine eindeutige Identifizierung an die start() Methode
if(!$cache->start('mypage')) {
    // Ausgabe wie gewöhnlich:
    
    echo 'Hallo Welt! ';
    echo 'Das ist gecached ('.time().') ';
    
    $cache->end(); // Die Ausgabe wird gespeichert und zum Browser gesendet
}

echo 'Das wird nie gecached ('.time().').';

?>]]>       </programlisting>
       </para>
       <para>
           Zu beachten ist das das Ergebnis von <code>time()</code> zweimal ausgegeben wird; das ist
           etwas dynamisches für Demonstrationszwecke. Beim Versuch dieses auszuführen und mehrfach zu 
           refreshen, kann bemerkt werden, dass sich die erste Nummer nie ändert, während die zweite sich 
           ändert, während die Zeit verstreicht. Das geschieht, weil die erste Nummer, die im gecacheten Abschnitt 
           ausgegeben wird, im Gegensatz zur anderen Ausgabe gecached wurde.
           Nach einer halben Minute (die Lebensdauer wurde auf 30 Sekunden gesetzt) sind die Nummern
           wieder identisch, weil der Cache Eintrag abgelaufen ist - er muß wieder gecached werden.
           Man sollte das im Browser oder in der Konsole testen.
       </para>
    </example>
    <note><para>
        Wenn Zend_Cache benutzt wird, muß auf die wichtigen Cache Identifizierungen geachtet werden (welche an
        <code>save()</code> und <code>start()</code> übergeben werden). Diese müssen für jede Ressource 
        einzigartig sein, die gecached werden soll. Andernfalls würden sich unverknüpfte Cache Datensätze gegenseitig
        entfernen oder, noch schlimmer, anstatt des anderen dargestellt werden.
    </para></note>
</sect1>


<sect1 id="zend.cache.theory">
    <title>Die Theorie des Cachens</title>
    <para>
        Es gibt 3 Schlüsselkonzepte in Zend_Cache. Eines ist die eindeutige Identifizierung (ein String), 
        die benutzt wird, um Cache Datensätze zu identifizieren. Das zweite ist die <code>'lifeTime'</code>
        Direktive, wie im Beispiel gezeigt; sie definiert, wie lange eine gecachte Ressource als 'frisch'
        betrachtet wird. Das dritte Konzept ist die bedingte Ausführung, so das Teile des Codes komplett 
        übersprungen werden können, was die Leistung steigert.
        Die Haupt-Frontend Funktion (eg. <code>Zend_Cache_Core::get()</code>) ist immer so gestaltet, das
        false zurückgegeben wird, wenn ein Cache fehlt. Aber nur, wenn das für die Natur des Frontends Sinn macht.
        Das erlaubt es Endbenutzern, die Teile des Codes, die gecached (oder übersprungen) werden sollen, in
        <code>if(){ ... }</code> Anweisungen zu umhüllen, wobei die Bedingung die Zend_Cache Methode selbst ist.
        Am Ende der Blöcke muss das erstellte auf alle Fälle gespeichert werden
        (z.B. <code>Zend_Cache_Core::save()</code>).
    </para>
    <note><para>
        Das Design der bedingten Ausführung des erzeugten Codes ist in einigen Frontends nicht notwendig
        (<code>Function</code>, zum Beispiel) wenn die komplette Logik im verwendeten Frontend integriert ist.
    </para></note>
    <note><para>
        'Cache hit' ist ein Ausdruck für eine Bedingung, wenn ein Cache Datensatz gefunden wurde, er gültig und
        'frisch' ist (in anderen Worten, er ist noch nicht abgelaufen). 'Cache miss' ist alles andere.
        Wenn ein 'Cache miss' passiert, müssen die Daten erzeugt werden (wie man es normalerweise tun würde) und
        anschließend cachen. Wenn ein 'Cache hit' geschieht muß, auf der anderen Seite, das Backend automatisch den 
        Datensatz vom Cache transparent holen.
    </para></note>
    <sect2 id="zend.cache.factory">
        <title>Die <code>Zend_Cache</code> Factory Methode</title>
        <para>
            Ein guter Weg, um eine verwendbare Instanz eines <code>Zend_Cache</code> Frontends zu erstellen, wird im
            folgenden Beispiel gegeben:
            <programlisting role="php"><![CDATA[<?php
        
# Wir "laden" die Zend_Cache Factory 
require 'Zend/Cache.php'; 

# Wir wählen ein Backend (zum Beispiel 'File' oder 'Sqlite'...)
$backendName = '[...]';

# Wir wählen ein Frontend (zum Beispiel 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# Wir definieren ein Array von Optionen für das gewählte Frontend
$frontendOptions = array([...]);

# Wir definieren ein Array von Optionen für das gewählte Backend
$backendOptions = array([...]);

# Wir erstellen eine gute Instanz
# (natürlich sind die letzten 2 Argumente optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

?>]]></programlisting> 
        </para> 
        <para>
            In den folgenden Beispielen wird angenommen, dass die <code>$cache</code> Variable ein
            gültiges, initiiertes Frontend wie gezeigt enthält und dass verstanden wird, wie 
            Parameter an das ausgewählte Backend übergeben werden.
        </para>
        <note><para>
            Immer <code>Zend_Cache::factory()</code> benutzen, um eine Frontend Instanz zu bekommen.
            Das selbstständige Instantiieren von Frontends und Backends funktioniert nicht so wie
            erwartet.
        </para></note>
    </sect2>
    
    <sect2 id="zend.cache.tags">
        <title>Markierte Datensätze</title>
        <para>
            Markierungen sind ein Weg um Cache Datensätze zu kategorisieren. Wenn der Cache mit der <code>save()</code>
            Methode abgespeichert werden soll, kann ein Array mit Markierungen für diesen Datensatz angelegt werden.
            Dann besteht die Möglichkeit, alle markierten Cache Datensätze mit einer bestimmten Markierung (oder
            Markierungen), zu löschen:
        <programlisting role="php"><![CDATA[<?php
             
$cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));
            
?>]]></programlisting></para>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>Löschen des Caches</title>
        <para>
            Um eine bestimmte Cache ID zu entfernen/annullieren, kann die <code>remove()</code> Methode benutzt werden:
             <programlisting role="php"><![CDATA[<?php 
             
$cache->remove('idToRemove');
            
?>]]></programlisting>            
        </para>
        <para>
            Um mehrere Cache IDs mit einer Operation zu entfernen/annulieren, kann die <code>clean()</code> Methode
            benutzt werden. Zum Beispiel um alle Cache Datensätze zu entfernen :
              <programlisting role="php"><![CDATA[<?php 

// Löschen aller Datensätze
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// Nur abgelaufene löschen
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
            
?>]]>       </programlisting>    
            Um Cache Einträge zu löschen, die zu den Tags 'tagA' und 'tagC' passen :
              <programlisting role="php"><![CDATA[<?php 
             
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tagA', 'tagC'));
            
?>]]>       </programlisting>
        </para>
        <para>
            Mögliche Löschmodi sind: <code>CLEANING_MODE_ALL</code>, <code>CLEANING_MODE_OLD</code>,
            <code>CLEANING_MODE_MATCHING_TAG</code> und <code>CLEANING_MODE_NOT_MATCHING_TAG</code>. 
            Die letzteren sind, wie deren Namen vermuten lassen, kombiniert mit einem Array von Markierungen
            für die Löschoperation.
        </para>
    </sect2>
</sect1>

<sect1 id="zend.cache.frontends">
    <title>Zend_Cache Frontends</title>
    
    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Core</code> ist ein spezielles Frontend, da es der Kern dieses Moduls ist.
                Es ist ein generelles Cache Frontend und durch andere Klassen erweiterbar.
            </para>
            <note><para>
                Alle Frontends sind von <code>Zend_Cache_Core</code> abgeleitet, so dass deren Methoden und
                Optionen (wie folgt beschrieben) auch in anderen Frontends vorhanden sind. Deswegen werden
                sie dort nicht dokumentiert.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>Mögliche Optionen</title>
            <para>
                Diese Optionen werden der Factory Methode übergeben wie im nachfolgenden Beispiel demonstriert.
            </para>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Ein- / Ausschalten vom Caching (kann sehr nützlich für das 
                                  Debuggen von gecachten Skripten sein)
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                Cache Lebensdauer (in Sekunden), wenn auf <code>null</code> gesetzt, ist
                                der Cache für immer gültig.
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Wenn auf true gesetzt, wird das Logging durch <code>Zend_Log</code> aktiviert
                                (aber das System wird langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Ein- / Ausschalten der Schreibkontrolle (der Cace wird gleich gelesen, nachdem
                                er geschrieben wurde, um fehlerhafte Einträge zu finden); das Einschalten der
                                Schreibkontrolle wird das Schreiben des Caches etwas verlangsamen, aber nicht das
                                Lesen des Caches (es können defekte Cache Dateien entdeckt werden, aber es ist 
                                keine perfekte Kontrolle)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Ein- / Ausschalten der automatischen Serialisierung, kann dafür benutzt werden, um
                                Daten direkt zu speichern, welche keine Strings sind (aber es ist langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                Ausschalten / Abgleichen des automatischen Löschprozesses (Garbage Collector):
                                0 heißt keine automatische Löschung des Caches, 1 heißt Systematische Cache
                                Löschung und x &gt; 1 heißt automatisches zufälliges Löschen 1 mal nach 
                                x Schreiboperationen.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.core.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben.
            </para>
            <para>
                Wenn nur Strings in den Cache gespeichert werden (denn mit der "automaticSerialization" Option
                wäre es möglich Booleans zu speichern), kann ein kompakterer Weg wie folgt gewählt werden:
                 <programlisting role="php"><![CDATA[<?php  
             
// Es wird angenommen das $cache existiert

$id = 'myBigLoop'; // Die Cache ID von dem "das gecached werden soll"

if (!($data = $cache->get($id))) {
    // Cache miss
    
    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 

// [...] Irgendwas mit $data machen (ausgeben, verarbeiten, usw.)
             
?>]]>       </programlisting> 
            </para>  
            <para>
                Wenn mehrere Blöcke von Daten oder Daten Instanzen gecached werden sollen, ist die 
                Idee dahinter die gleiche:
                 <programlisting role="php"><![CDATA[<?php  
             
// Sicherstellen, dass eindeutige Identifizierer verwendet werden:
$id1 = 'foo';
$id2 = 'bar';

// Block 1
if (!($data = $cache->get($id1))) {
    // Cache miss
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 
echo($data);

// Hier wird NIE gecached
echo('NIE GECACHED! ');

// Block 2
if (!($data = $cache->get($id2))) {
    // Cache miss
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }
    
    $cache->save($data);
    
} 
echo($data);

?>]]>       </programlisting>             
            </para>            
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontend.output.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_Output</code> ist ein Ausgabe-Empfangendes Frontend. Es verwendet den
                Ausgabe Puffer in PHP, um alles zwischen der <code>start()</code> und der <code>end()</code> Methode
                zu fangen.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.output.options">
            <title>Mögliche Optionen</title>
            <para>
                Dieses Frontend hat keine bestimmten Optionen zusätzlich zu denen von
                <code>Zend_Cache_Core</code>.
            </para>
        </sect3>
        
        <sect3 id="zend.cache.frontend.output.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben. Hier ist es mit kleinen Änderungen:
                 <programlisting role="php"><![CDATA[<?php

// Wenn es ein Cache Miss ist, wird das puffern der Ausgabe ausgelöst
if(!$cache->start('mypage')):

// Alle wie gewohnt ausgeben
echo 'Hallo Welt! ';
echo 'Das wird gecached ('.time().') ';

$cache->end(); // Ausgabepufferung beenden
endif;

echo 'Hier wird nie gecached ('.time().').';

?>]]>       </programlisting>
            </para>
            <para>
                Die Verwendung dieser Form ist ziemlich einfach, um Ausgabe caching in einem bereits bestehenden
                Projekt, mit nur wenig oder gar keinen Codeänderungen, zu erhalten.
            </para>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontend.function.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_Function</code> cached das Ergebnis von Funktionsaufrufen. Es hat
                eine einzelne Hauptmethode genannt <code>call()</code>, welche den Funktionsnamen und Parameter
                für den Aufruf in einem Array entgegennimmt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.function.options">
            <title>Mögliche Optionen</title>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Funktionsaufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen, die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen, die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.function.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung der <code>call()</code> Funktion ist die gleiche, wie die von
                <code>call_user_func_array()</code> in PHP:
                 <programlisting role="php"><![CDATA[<?php

$cache->call('veryExpensiveFunc', $params);

# $params ist ein Array
# Zum Beispiel fürs Aufrufen (mit cachen) von veryExpensiveFunc(1, 'foo', 'bar'), wird
# $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar')) benutzt

?>]]>       </programlisting>
            </para>
            <para>
                <code>Zend_Cache_Frontend_Function</code> ist elegant genug, um beides zu cachen, den
                Rückgabewert der Funktion und deren interne Ausgabe.
            </para>
            <note><para>
                Man kann jede eingebaute oder benutzerdefinierte Funktion übergeben, mit ausnahme von
                <code>array()</code>, <code>echo()</code>, <code>empty()</code>, <code>eval()</code>,
                <code>exit()</code>, <code>isset()</code>, <code>list()</code>, <code>print()</code>
                und <code>unset()</code>. 
            </para></note>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontend.class.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_Class</code> ist unterschiedlich zu <code>Zend_Cache_Frontend_Function</code>,
                weil es das Cachen von Objekten und statischen Methodenaufrufen erlaubt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.class.options">
            <title>Mögliche Optionen</title>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Datentyp</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cachedEntity</code> (Notwendig)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  Wenn auf einen Klassennamen gesetzt, wird eine abstrakte Klasse gecached und
                                  es werden statische Aufrufe verwendet; wenn auf ein Objekt gesetzt, wird deren
                                  Objektmethoden gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Aufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen, die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen, die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.class.examples">
            <title>Beispiele</title>
            <para>
                zum Beispiel, um einen statischen Aufruf zu cachen:
                <programlisting role="php"><![CDATA[<?php

class test {
   
    # Statische Methode
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => 'test' // Der Name der Klasse
);
// [...]

# Der gecachte Aufruf
$res = $cache->foobar('1', '2');

?>]]>           </programlisting>
                Um klassische Methodenaufrufe zu cachen :
                <programlisting role="php"><![CDATA[<?php

class test {
   
    private $_string = 'Hallo !';
      
    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => new test() // Eine Instanz der Klasse
);
// [...]

# Der gecachte Aufruf
$res = $cache->foobar2('1', '2');

?>]]>           </programlisting>
            </para>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Einführung</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> ist ein Frontend angetrieben durch den
                Änderungszeitpunkt einer "Masterdatei". Es ist wirklich interessant für Beispiele
                in Konfigurations- oder Templateanwendungen.
            </para>
            <para>
                Zum Beispiel eine XML Konfigurationsdatei, welche von einer Funktion geparsed wird
                und die ein "Config Objekt" zurückgibt (wie durch <code>Zend_Config</code>). Mit
                <code>Zend_Cache_Frontend_File</code> kann das "Config Objekt" im Cache gespeichert
                werden (um zu Verhindern, das die XML Konfiguration jedes mal geparsed wird), aber mit
                einer strengen Abhängigkeit zur "Masterdatei". Wenn also die XML Konfigurationsdatei
                geändert wird, wird der Cache sofort ungültig.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Mögliche Optionen</title>
            <table>
                <title>Mögliche Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>masterFile (mandatory)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  Der komplette Pfad und Name der Master Datei                 
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>   
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung dieses Frontends ist die gleiche wie die von <code>Zend_Cache_Core</code>. 
                Es gibt kein eigenes Beispiel - was als einziges gemacht werden muß, ist das <code>masterFile</code>
                zu definieren, wenn die Factory verwendet wird.
            </para>
        </sect3>
    </sect2>
    
    <sect2 id="zend.cache.frontends.page">
    	<title>Zend_Cache_Frontend_Page</title>
    	<sect3 id="zend.cache.frontends.page.introduction">
        	<title>Einführung</title>
        	<para>
	            <code>Zend_Cache_Frontend_Page</code> ist wie <code>Zend_Cache_Frontend_Output</code>
	            aber entwickelt für eine komplette Seite. Es ist unmöglich <code>Zend_Cache_Frontend_Page</code>
	            nur für das Cachen eines einzelnen Blockes zu verwenden.
	        </para>
	        <para>
	        	Andererseits wird die "Cache ID" automatisch berechnet mit <code>$_SERVER['REQUEST_URI']</code> und
	        	(abhängig von den Optionen) mit
	        	<code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>, <code>$_COOKIE</code>, <code>$_FILES</code>.
                Trotzdem muß nur eine Methode aufgerufen werden (<code>start()</code>), weil der Aufruf von 
                <code>end()</code> immer vollautomatisch ist, wenn die Seite endet.
	        </para>
	        <para>
	        	Zur Zeit ist es nicht eingebaut, aber es ist ein HTTP abhängiges System geplant, um Bandbreiten zu
	        	sparen (das System wird ein "HTTP 304 nicht geändert" schicken, wenn der Cache gefunden wurde und wenn
	        	der Browser bereits eine gültige Version hat).
	        </para>
	        <note><para>
                Zend_Cache_Frontend_Page ist wirklich eine "Alpha Version" und ist zukünftig für Verbesserungen vorgesehen.
	        </para></note>
    	</sect3>
    	<sect3 id="zend.cache.frontends.page.options">
	        <title>Mögliche Optionen (Für dieses Frontend in der Zend_Cache Factory)</title>
	        <table>
	            <title>Mögliche Optionen</title>
	            <tgroup cols="4">
	                 <thead>
	                      <row>
	                        <entry>Option</entry>
	                        <entry>Daten Typ</entry>
	                        <entry>Standardwert</entry>
	                        <entry>Beschreibung</entry>
	                    </row>
	                 </thead>
	                 <tbody>
	                 	   <row>
	                          <entry><code>httpConditional</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              Verwendung des httpConditional Systems (zur Zeit nicht implementiert)
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>debugHeader</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                                Wenn true, wird eine Debugging Text for jeder gecacheten Seite hinzugefügt
	                          </entry>
	                     </row>
	                     <row>
	                     	  <entry><code>defaultOptions</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array(...siehe unten...)</code></entry>
	                          <entry>
	                              Ein assoziatives Array mit Default Optionen: 
	                              <itemizedlist>
	                                  <listitem><code>(boolean, true per Default) cache</code> : Cache ist aktiviert wenn true</listitem>
	                                  <listitem><code>(boolean, false per Default) cacheWithGetVariables</code> : wenn true, ist der Cache weiterhin aktiviert, selbst wenn es einige Variables im <code>$_GET</code> Array gibt</listitem>
	                                  <listitem><code>(boolean, false per Default) cacheWithPostVariables</code> : wenn true, ist der Cache weiterhin aktiviert, selbst wenn es einige Variables im <code>$_POST</code> Array gibt</listitem>
	                                  <listitem><code>(boolean, false per Default) cacheWithSessionVariables</code> : wenn true, ist der Cache weiterhin aktiviert, selbst wenn es einige Variables im <code>$_SESSION</code> Array gibt</listitem>
	                                  <listitem><code>(boolean, false per Default) cacheWithFilesVariables</code> : wenn true, ist der Cache weiterhin aktiviert, selbst wenn es einige Variables im <code>$_FILES</code> Array gibt</listitem>
	                                  <listitem><code>(boolean, false per Default) cacheWithCookieVariables</code> : wenn true, ist der Cache weiterhin aktiviert, selbst wenn es einige Variables im <code>$_COOKIE</code> Array gibt</listitem>
									  <listitem><code>(boolean, true per Default) makeIdWithGetVariables</code> : wenn true, wird die Cache ID vom Inhalt des <code>$_GET</code> Arrays abhängig sein</listitem>
	                                  <listitem><code>(boolean, true per Default) makeIdWithPostVariables</code> : wenn true, wird die Cache ID vom Inhalt des <code>$_POST</code> Arrays abhängig sein</listitem>
	                                  <listitem><code>(boolean, true per Default) makeIdWithSessionVariables</code> : wenn true, wird die Cache ID vom Inhalt des <code>$_SESSION</code> Arrays abhängig sein</listitem>
	                                  <listitem><code>(boolean, true per Default) makeIdWithFilesVariables</code> : wenn true, wird die Cache ID vom Inhalt des <code>$_FILES</code> Arrays abhängig sein</listitem>
	                                  <listitem><code>(boolean, true per Default) makeIdWithCookieVariables</code> : wenn true, wird die Cache ID vom Inhalt des <code>$_COOKIE</code> Arrays abhängig sein</listitem>	                              
	                              </itemizedlist>              
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>regexps</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array()</code></entry>
	                          <entry>
	                          	  Ein assoziatives Array, um Optionen nur für einige REQUEST_URI zu setzen. Die Schlüssel
	                          	  sind reguläre Ausdrücke (PCRE), die Werte sind ein assoziatives Array mit spezifischen
	                          	  Optionen, die gesetzt werden sollen, wenn der reguläre Ausdruck auf $_SERVER['REQUEST_URI']
	                          	  passt (siehe die defaultOptions für eine Liste der verfügbaren Optionen); wenn verschiedene
	                          	  reguläre Ausdrücke auf $_SERVER['REQUEST_URI'] passen, wird nur der letzte verwendet.
	                          </entry>
	                     </row>
	                  </tbody>
	              </tgroup>
	          </table>
	    </sect3>   
    	<sect3 id="zend.cache.frontends.page.examples">
        	<title>Beispiele</title>
	        <para>
	            Die Verwendung von Zend_Cache_Frontend_Page ist wirklich trivial :
	            <programlisting role="php"><![CDATA[<?php
	           
// [...] // Benötigt, Konfiguration und Factory
	
$cache->start();
// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt, und das Skript stoppt hier
	
// Rest der Seite ...
	
?>]]>           </programlisting>
	        </para>
	        <para>
	        	Ein etwas komplexeres Beispiel, welches einen Weg zeigt, um ein zentralisiertes
	        	Cache Management in einer Bootstrap Datei zu erhalten (um es z.B. mit Zend_Controller´
	        	zu verwenden)
	        	<programlisting role="php"><![CDATA[<?php

// [...] du solltest es vermeiden, zu viele Zeilen vor dem Cache Bereich zu setzen
// [...] zum Beispiel sollten für optimale Performanz "require_once" oder "Zend::loadClass" 
// [...] nach dem Cache Bereich stehen

require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200,
   'debugHeader' => true, // für das Debugging 
   'regexps' => array(
       '^/$' => array('cache' => true),         // cache den gesamten IndexController         
       '^/index/' => array('cache' => true),    // cache den gesamten IndexController
       '^/article/' => array('cache' => false), // wir cachen nicht den ArticleController...
       '^/article/view/' => array(              // ...aber wir cachen die "View" Aktion von 
           'cache' => true,                     // diesem ArticleController
           'cacheWithPostVariables' => true,    // und wir cachen sogar wenn es einige Variablen in $_POST gibt
           'makeIdWithPostVariables' => true,   // (aber die Cache Id wird vom $_POST Array abhängig sein)
       )
   )	  
);
$backendOptions = array(
    'cacheDir' => '/tmp/' 
);

// erhalte ein Zend_Cache_Frontend_Page Objekt
$cache = Zend_Cache::factory('Page', 'File', $frontendOptions, $backendOptions);

$cache->start();

// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt, und das Skript stoppt hier

// [...] das Ende der Bootstrap Datei (diese Zeilen werden nicht ausgeführt, wenn der Cache ausgegeben wurde)
	        	
?>]]>           </programlisting>	        	
	        </para>	        
    	</sect3>
	</sect2>
    
</sect1>

<sect1 id="zend.cache.backends">
    <title>Zend_Cache Backends</title>
    
    <sect2 id="zend.cache.backends.file">
        <title>Zend_Cache_Backend_File</title>
        <para>
            Dieses Backend speichert Cache Datensätze in Dateien (in einem gewählten Verzeichnis).
        </para>
        <para>
            Mögliche Optionen sind :
        </para>          
        <table>
            <title>Mögliche Optionen</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Daten Typ</entry>
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDir</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'/tmp/'</code></entry>
                          <entry>
                              Verzeichnis, in dem die Cache Dateien gespeichert werden
                          </entry>
                      </row>
                      <row>
                          <entry><code>fileLocking</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Ein- / Ausschalten von fileLocking: kann die Beschädigung des Caches
                            unter schlechten Bedingungen verhindern, aber es hilft nicht bei
                            Multithreaded Webservern oder bei NFS Filesystemen...
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControl</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Ein- / Ausschalten von readControl: eingeschaltet wird ein Kontrollschlüssel
                            im Cache File inkludiert und dieser Schlüssel wird mit dem Schlüssel 
                            verglichen, der nach dem Lesen berechnet wird.
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControlType</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'crc32'</code></entry>
                          <entry>
                            Typ der Schreibkontrolle (nur wenn readControl eingeschaltet ist).
                            Mögliche Werte sind :
                            'md5' (bestes, aber am Langsamsten), 'crc32' (etwas weniger sicher, aber schneller, beste
                            Wahl), 'strlen' um nur die Länge zu testen (schnellstes).
                        </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryLevel</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0</code></entry>
                          <entry>
                             Level der gehashten Verzeichnis Struktur: 0 heißt "keine gehashte 
                             Verzeichnis Strutur, 1 heißt "ein Level von Verzeichnissen", 2 heißt
                             "zwei Levels"...
                             Diese Option kann den Cache nur dann schneller machen, wenn viele Tausende
                             Cache Dateien verwendet werden. Nur spezielle Messungen können helfen, den perfekten
                             Wert zu finden. Möglicherweise ist 1 oder 2 ein guter Anfang.
                          </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryUmask</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0700</code></entry>
                          <entry>
                              Umask für die gehashte Verzeichnis Struktur
                        </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
        <title>Zend_Cache_Backend_Sqlite</title>
        <para>
            Dieses Backend speichert die Cache Datensätze in einer SQLite Datenbank.
        </para>
        <para>
            Mögliche Optionen sind :
        </para>
        <table>
            <title>Mögliche Optionen</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                           <entry>Option</entry>
                        <entry>Daten Typ</entry>
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDBCompletePath (mandatory)</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>null</code></entry>
                          <entry>
                              Der komplette Pfad (inklusive Dateiname) der SQLite Datenbank
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.memcached">
        <title>Zend_Cache_Backend_Memcached</title>
        <para>
            Dieses Backend speichert Cache Datensätze in einem Memcache Server. <ulink url="http://www.danga.com/memcached/">memcached</ulink>
            ist ein hoch-performantes, verteiltes Speicher Objekt Caching System. Um dieses Backend zu benutzen,
            wird ein Memcached Dämon benötigt und <ulink url="http://pecl.php.net/package/memcache">die memcache PECL Erweiterung</ulink>.
        </para>
        <para>
        	Vorsicht: mit diesem Backend werden zur Zeit "Marker" nicht unterstützt genauso wie das
        	"doNotTestCacheValidity=true" Argument.
        </para>
        <para>
            Mögliche Optionen sind :
        </para>
        <table>
            <title>Mögliche Optionen</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Daten Typ</entry>
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>servers</code></entry>
                          <entry><code>array</code></entry>
                          <entry><code>array(array('host' => 'localhost','port' => 11211, 'persistent' => true))</code></entry>
                          <entry>
                              Ein Array von Memcached Servern; jeder Memcached Server wird durch ein
                              assoziatives Array beschrieben :
                              'host' => (string) : Der Name des Memcached Servers, 
                              'port' => (int) : Der Port des Memcached Servers, 
                              'persistent' => (bool) : Persistente Verbindungen für diesen Memcached Server verwenden oder nicht
                          </entry>
                      </row>
                      <row>
                          <entry><code>compression</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>flase</code></entry>
                          <entry>
                             true wenn on-the-fly Kompression verwendet werden soll
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.apc">
        <title>Zend_Cache_Backend_APC</title>
        <para>
            Dieses Backend speichert Cache Datensätze im Shared Memory durch die 
            <ulink url="http://pecl.php.net/package/APC">APC</ulink> (Alternativer PHP Cache) Erweiterung
            (welche natürlich für die Verwendung dieses Backends benötigt wird).
        </para>
        <para>
        	Vorsicht: mit diesem Backend werden "Marker" zur Zeit nicht unterstützt genauso wie das
        	"doNotTestCacheValidity=true" Argument.
        </para>
        <para>
            Es gibt keine Optionen für dieses Backend.
        </para>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->