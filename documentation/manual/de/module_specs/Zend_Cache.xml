<sect1 id="zend.cache.introduction">
    <title>Einführung</title>
    <para>
        <code>Zend_Cache</code> bietet einen generellen Weg an um Daten zu cachen.
    </para>
    <para>
        Cache Datensätze werden über ein Backend gespeichert (<code>File</code>, <code>Sqlite</code>...) mit
        einem flexiblen System von "ids" und "tags". Dann ist es einfach, zum Beispiel einen bestimmten Teil
        von gecachten Daten zu Löschen ("alle Cache Datensätze welche mit einem bestimmten Tag markiert sind"...).
    </para>
    <para>
    	Der Kern des Moduls ist wirklich sehr generell und flexibel. Nun, für spezielle Bedürfnisse, kann ein
    	Frontend (<code>Output</code>, <code>Function</code>...) benutzt werden, um einen ansprechenderen Weg
    	der Benutzung zu bekommen.
    </para>
    <example>
        <title>Ein erstes Beispiel mit dem Zend_Cache Kern</title>
        <para>
            In diesem ersten Beispiel wird der Kern von Zend_Cache direkt benutzt mit dem
            <code>File</code> Backend.
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
	'lifeTime' => 7200 // Cache Lebensdauer von 2 Stunden
);

$backendOptions = array(
    'cacheDir' => '/tmp/' // Verzeichnis in welches die Cache Dateien kommen 
);

// Erstellung eines Zend_Cache_Core Objektes
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

$id = 'foo'; // Cache Id von dem das "gecached werden soll"

if (!($cache->test($id))) {
	// Cache nicht gefunden
	
	// require_once ... für Perfektionsgründe müssen alle "require_once" NUR DANN geladen
	//                  werden wenn der Cache verpasst wurde
	// require_once ...
	
	// Erzeugung von dem das "gecached werden soll"
	// zum Beispiel
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	} 
	
	// Das Ergebnis wird in den Cache gespeichert
    $cache->save($data);

} else {
	// Cache gefunden
	
	$data = $cache->get($id);

}

// Irgendwas mit $data machen :)
// [...]
?>]]>       </programlisting>
       </para>
    </example>
    <note>
        Mit Zend_Cache_Core muß die "Cache Identifizierung" selbstständig gemanaged werden
    </note>
</sect1>

<sect1 id="zend.cache.factory">
    <title>Zend_Cache Factory</title>
    <para>
    	Es gibt nur einen Weg um ein <code>Zend_Cache_*</code> Objekt zu erzeugen. In allen 
    	Fällen (Backends und/oder Frontends) muß die <code>Zend_Cache</code> Factory benutzt werden.
    	Die Frontend Konstruktoren nicht direkt benutzen, da es nicht richtig funktionieren würde.
    </para>
    <para>
    	Ein guter Weg um eine verwendbare Instanz von <code>Zend_Cache_*</code> zu erzeugen wird im
    	folgenden Beispiel gezeigt :
    	<programlisting role="php"><![CDATA[<?php
    	
# Die Zend_Cache Factory wird "geladen"
require 'Zend/Cache.php'; 

# Ein Backend wird ausgewählt (zum Beispiel 'File' oder 'Sqlite'...)
$backendName = '[...]';

# Ein Frontend wird ausgewählt (zum Beispiel 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# Wir setzen ein Array von Optionen für das ausgewählte Frontend
$frontendOptions = array([...]);

# Wir setzen ein Array von Optionen für das ausgewählte Backend
$backendOptions = array([...]);

# Wir erzeugen eine gute Instanz
# (die letzten 2 Argumente sind natürlich optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

[...]

?>]]>   </programlisting> 
    </para> 
    <para>
    	In den folgenden Zeilen dieser Dokumentation wird angenommen das die <code>$cache</code>
    	Variable, wie im vorherigen Bespiel gezeigt, gesetzt wurde
    </para> 
</sect1>

<sect1 id="zend.cache.core">
    <title>Zend_Cache_Core</title>
    <sect2 id="zend.cache.core.introduction">
    	<title>Einführung</title>
    	<para>
    		<code>Zend_Cache_Core</code> ist ein spezielles Frontend weil es der Kern des Moduls ist.
    		Alle Frontends sind von dieser Klasse abgeleitet. Deswegen sind die meisten der Methoden 
    		und Optionen, welche anschließend beschrieben werden, auch in den anderen Frontends verfügbar.
    	</para>
    </sect2>
    <sect2 id="zend.cache.core.options">
    	<title>Gültige Optionen (für dieses Frontend in Zend_Cache Factory)</title>
	    <table>
    		<title>Gültige Optionen</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Option</entry>
				        <entry>Daten Typ</entry>
				        <entry>Default Wert</entry>
				        <entry>Beschreibung</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>caching</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
      						Ein- / Ausschalten des Cachings (can sehr nützlich sein für das 
      						debuggen von gecachten Skripten)
      					</entry>
      				</row>
      				<row>
      					<entry><code>lifeTime</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>3600</code></entry>
      					<entry>
        					Lebenszeit des Caches (in Sekunden), wenn dieser auf <code>null</code> 
        					gesetzt wird, ist der Cache für immer gültig.       
      					</entry>
      				</row>
      				<row>
      					<entry><code>logging</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>false</code></entry>
      					<entry>
        					Auf true gesetzt, wird logging durch <code>Zend_Log</code> aktiviert. 
        					(aber das System wird langsamer)
      					</entry>
      				</row>
      				<row>
      					<entry><code>writeControl</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Ein- / Ausschalten der Schreibkontrolle (der Cache wird gelesen
        					genau nach dem Schreiben, um defekte Einträge zu erkennen).
        					Einschalten von writeControl verlangsamt das Schreiben des Caches aber nicht
        					das Lesen des Caches (es können defekte Cache dateien erkannt werden, aber
        					es ist keine perfekte Kontrolle)
      					</entry>
      				</row>
      				<row>
      					<entry><code>automaticSerialization</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>false</code></entry>
      					<entry>
        					Ein- / Ausschalten der automatischen Serialisierung. Sie kann benutzt werden
        					um Daten, welche keine Strings sind, direkt zu speichern (aber es ist langsamer)
      					</entry>
      				</row>
      				<row>
      					<entry><code>automaticCleaningFactor</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0</code></entry>
      					<entry>
        					Ausschalten / Einstellen des automatischen Reinigungsprozesses (garbage collector) :
        					0 heißt kein automatisches Reinigen, 1 heißt systematische Cache Reinigung
        					und x (Integer) &gt; 1 heißt automatische zufällige Reinigung 1 mal bei allen
        					x Cache Schreibvorgängen.
      					</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    </sect2>
    <sect2 id="zend.cache.core.examples">
    	<title>Beispiele</title>
    	<para>
    		Ein erstes Beispiel wurde im Tutorial ganz am Anfang gegeben.
    	</para>
    	<para>
    		Wenn nur Strings in den Cache gespeichert werden (weil mit der "automaticSerialization" Option
    		ist es möglich Booleans zu speichern), kann eine kompaktere Konstruktion wie diese benutzt werden :
     	    <programlisting role="php"><![CDATA[<?php  
     	    
// [...] // require, Konfiguration und Factory

$id = 'foo'; // Cache Id von dem "was wir Cachen wollen"

if (!($data = $cache->get($id))) {
	// Cache nicht gefunden
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	}
	
    $cache->save($data);
    
} 

// [...] Irgendwas mit $data machen (zum Beispiel "echo $data;")
     	    
?>]]>       </programlisting> 
        </para>  
        <para>
        	Wenn mehrere Blöcke oder Daten gecached werden sollen, ist die Idee die selbe :
     	    <programlisting role="php"><![CDATA[<?php  
     	    
// [...] // require, Konfiguration und Factory

$id1 = 'foo'; // Cache Id von block1
$id2 = 'bar'; // Cache Id von block2

// BLOCK1
if (!($data = $cache->get($id1))) {
	// Cache nicht gefunden
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	}
	
    $cache->save($data);
    
} 
echo($data);

// NIE GECACHTER BLOCK
echo('NIE GECACHED !');

// BLOCK2
if (!($data = $cache->get($id2))) {
	// Cache nicht gefunden
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . '!';
	}
	
    $cache->save($data);
    
} 
echo($data);


?>]]>       </programlisting>         	
        </para>   	 	
    </sect2>   
    <sect2 id="zend.cache.core.idandtags">
    	<title>Cache ID und Tags</title>
    	<para>
    		Eine "cache id" ist ein eindeutiger Schlüssel welcher einen bestimmten Cache Eintrag identifiziert.
    		In einigen Frontends (Core, Output, ...) müssen die "cache ids" selbstständig behandelt werden.
    		Deswegen ist zum Beispiel Vorsicht geboten wenn Eindeutige Schlüssel für eine bestimmte Seite oder
    		einen Block verwendet werden.
    	</para>
    	<para>
    		"tags" sind ein Weg um Cache Einträge zu kategorisieren. Wenn der Cache mit <code>save()</code> Methode
    		gespeichert wird, kann für diesen Eintrag ein Array mit Markierungen, zum Anhängen, definiert werden.
    		Anschließend können alle markierte Cache Einträge mit einem übergebenen Marker gelöscht werden...
    		Das ist wirklich ein sehr mächtiger Web um Cache Einträge nach Gruppen zu managen.
    	</para>
    	<para>
    		Hier folgt die komplette Syntax der <code>save()</code> Methode :
    		<programlisting role="php"><![CDATA[<?php
     	    
    /**
     * Speichere einige Daten in einem Cache 
     * 
     * @param mixed $data Im Cache zu speichernde Daten (kann auch ein anderer Typ als String sein wenn automaticSerialization eingeschaltet ist)
     * @param cache $id   Cache ID (wenn nicht gesetzt, wird die letzte Cache ID benutzt)
     * @param array $tags Cache Marker
     * @return boolean    true wenn kein Problem auftrat
     */
    public function save($data, $id = null, $tags = array()) {}
    		
?>]]>       </programlisting>    	 
			Also kann zum Beispiel folgendes gemacht werden :
			<programlisting role="php"><![CDATA[<?php
			
// [...]
$cache->save('zu Speichernde Daten', 'uniqueID', array('tag1', 'tag4', 'tag5'));
// [...]	
			
?>]]>       </programlisting> 						   	
    	</para>
    </sect2>
    <sect2 id="zend.cache.core.clean">
    	<title>Reinigen des Caches</title>
    	<para>
    		Um eine bestimmte Cache Id zu entfernen/annulieren kann die <code>remove()</code>
    		Methode benutzt werden :
     	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->remove('idToRemove');
// [...]
    		
?>]]>       </programlisting>    		
    	</para>
    	<para>
    		Um mehrere Cache Ids in einer Operation zu entfernen/annulieren kann die <code>clean()</code>
    		Methode benutzt werden. Zum Beispiel um alle Cache Einträge zu entfernen :
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);
// [...]
    		
?>]]>       </programlisting>     		
			Wenn nur abgelaufene Cache Einträge entfernt werden sollen :
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
// [...]
    		
?>]]>       </programlisting>    
			Wenn Cache Einträge entfernt werden sollen die mit den Markern 'tag1' und 'tag2' übereinstimmen :
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tag1', 'tag3'));
// [...]
    		
?>]]>       </programlisting>    
			[...]			
    	</para>
    </sect2>
</sect1>
<sect1 id="zend.cache.output">
    <title>Zend_Cache_Output</title>
    <para>
    	WIRD NACHGEREICHT
    </para>
</sect1>    
<sect1 id="zend.cache.page">
    <title>Zend_Cache_Page</title>
    <para>
        WIRD NACHGEREICHT
    </para>
</sect1>  
<sect1 id="zend.cache.file">
    <title>Zend_Cache_File</title>
    <para>
        WIRD NACHGEREICHT
    </para>
</sect1> 
<sect1 id="zend.cache.function">
    <title>Zend_Cache_Function</title>
    <para>
        WIRD NACHGEREICHT
    </para>
</sect1> 
<sect1 id="zend.cache.class">
    <title>Zend_Cache_Class</title>
    <para>
        WIRD NACHGEREICHT
    </para>
</sect1> 
<sect1 id="zend.cache.backends">
    <title>Backends für Zend_Cache</title>
    <sect2 id="zend.cache.backends.file">
    	<title>Zend_Cache_Backend_File</title>
    	<para>
    		Dieses Backend speichert Cache Einträge in Dateien (in einem gewählten Verzeichnis).
    	</para>
    	<para>
    		Gültige Optionen sind :
    	</para>  		
	    <table>
    		<title>Gültige Optionen</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Option</entry>
				        <entry>Daten Typ</entry>
				        <entry>Standard Wert</entry>
				        <entry>Beschreibung</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>cacheDir</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>'/tmp/'</code></entry>
      					<entry>
      						Verzeichnis in welchem die Cache Dateien gespeichert werden
      					</entry>
      				</row>
      				<row>
      					<entry><code>fileLocking</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Ein- / Ausschalten der Datei Sperre : Kann die Verfälschung des Caches,
        					die bei schlechten Umständen auftreten könnte, verhindern. Aber diese
        					Option hilft nicht bei Multithread Webservern oder bei NFS Filesystemen...
      					</entry>
      				</row>
      				<row>
      					<entry><code>readControl</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
      					    Ein- / Auschalten der Schreibkontrolle: Wenn eingeschaltet, wird ein
      					    Kontrolle Schlüssel in der Cache Datei inkludiert und dieser Schlüssel
      					    wird verglichen mit dem, nach dem Lesen, berechneten.
      					</entry>
      				</row>
      				<row>
      					<entry><code>readControlType</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>'crc32'</code></entry>
      					<entry>
        					Typ der Schreibkontrolle (nur wenn Schreibkontrolle eingeschaltet wurde).
        					Gültige Werte sind : 'md5' (bestes aber am Langsamsten), 'crc32' (etwas weniger 
        					sicher aber schnell, bessere Wahl), 'strlen' nur für einen Test der Länge (schnellstes).
        				</entry>
      				</row>
      				<row>
      					<entry><code>hashedDirectoryLevel</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0</code></entry>
      					<entry>
      					    Ebene der gehashten Verzeichnis Struktur : 0 bedeutet "keine gehashte Verzeichnis 
      					    Struktur", 1 bedeutet "eine Ebene von Verzeichnissen", 2 bedeutet "zwei Ebenen"...
      					    Diese Option kann den Cache nur dann schneller machen, wenn viele tausende Cache
      					    Dateien vorhanden sind. Nur spezielle Messungen können helfen den perfekten Wert
      					    zu finden. Möglicherweise ist 1 oder 2 ein guter Startwert.
      					</entry>
      				</row>
      				<row>
      					<entry><code>hashedDirectoryUmask</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0700</code></entry>
      					<entry>
      						Umask für die gehashte Verzeichnis Struktur
        				</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    	</para>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
    	<title>Zend_Cache_Backend_Sqlite</title>
    	<para>
    		Dieses Backend speichert Cache Einträge in einer SQLite Datenbank.
     	</para>
    	<para>
    		Mögliche Optionen sind :
    	</para>
    	<table>
    		<title>Mögliche Optionen</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Option</entry>
				        <entry>Daten Typ</entry>
				        <entry>Standard Wert</entry>
				        <entry>Beschreibung</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>cacheDBCompletePath (mandatory)</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>null</code></entry>
      					<entry>
      						Der komplette Pfad (inklusive Dateiname) der SQLite Datenbank.
      					</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    	</para>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->