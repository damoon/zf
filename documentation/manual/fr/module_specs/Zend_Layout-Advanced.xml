<sect1 id="zend.layout.advanced">
    <title>Zend_Layout, utilisation avancée</title>

    <para>
        <code>Zend_Layout</code> permet d'être utilisée de manière plus pointue.
    </para>

    <para>
        Vous pouvez agir sur ces éléments:
    </para>

    <itemizedlist>
        <listitem><para>
                <emphasis>Objet de vue personnalisé.</emphasis>
                <code>Zend_Layout</code> accepte tout objet de vue implémentant 
				l'interface <code>Zend_View_Interface</code>. 
        </para></listitem>

        <listitem><para>
                <emphasis>Plugin contrôleur frontal personnalisé.</emphasis>
                <code>Zend_Layout</code> est livré avec un plugin qui rend 
				la layout automatiquement avant de renvoyer la réponse (utilisation 
				MVC). Vous pouvez injecter votre propre plugin.
        </para></listitem>

        <listitem><para>
                <emphasis>Aide d'action personnalisée.</emphasis>
                <code>Zend_Layout</code> est livrée avec une aide d'action 
				qui devrait en théorie suffir dans la majorité des cas. C'est un 
				proxy vers l'objet de <code>Zend_Layout</code>. Vous pouvez 
				cependant utiliser votre propre classe d'aide.
        </para></listitem>

        <listitem><para>
                <emphasis>Résolveur de chemin de script personnalisé</emphasis>.
                <code>Zend_Layout</code> vous permet d'utiliser votre <link
                    linkend="zend.filter.inflector">inflecteur</link> pour la résolution
				des scripts de layout ou de modifier l'inflecteur par défaut.
        </para></listitem>
    </itemizedlist>

    <sect2 id="zend.layout.advanced.view">
        <title>Objets de vue personnalisés</title>

        <para>
            <code>Zend_Layout</code> accepte des objets de vue implémentant 
            <code>Zend_View_Interface</code> ou étandant
            <code>Zend_View_Abstract</code> pour le rendu du script de layout.
            Passez le en paramètre au constructeur ou à <code>startMvc()</code>, 
			ou utilisez l'accesseur <code>setView()</code>:
        </para>

        <programlisting role="php"><![CDATA[<?php
$view = new My_Custom_View();
$layout->setView($view);
?>]]></programlisting>

        <note>
            <title>Attention à vos implémentations de Zend_View</title>

            <para>
                Même si <code>Zend_Layout</code> vous permet d'utiliser votre 
				propre objet de vue (implémentant <code>Zend_View_Interface</code>),
				vous pouvez rencontrer des problèmes si votre vue n'a pas accès à 
				certaines aides de vue, en particulier les aides 'layout' et
                <link linkend="zend.view.helpers.initial.placeholder">'placeholder'</link>.
                <code>Zend_Layout</code> effectue des affectations de variables 
				sur la vue via ces aides. 
            </para>

            <para>
                Si vous avez besoin d'un objet <code>Zend_View</code> personnalisé 
                qui ne supporte pas ces aides de vue, vous devrez alors trouver un moyen 
				de passer les variables de layout à la vue. Par exemple, en étendant 
				l'objet <code>Zend_Layout</code> et en rédéfinissant la méthode 
				<code>render()</code> en passant des variables à la vue.
				Aussi, vous pouvez créer votre propre plugin qui s'occupe de passer ces 
				variables avant le rendu de la layout.
            </para>

            <para>
                De même, si votre implémentation de la vue permet l'extension via des 
				plugins, vous pouvez à tout moment accéder aux variables de la layout 
				grâce à l'aide 
				<link linkend="zend.view.helpers.initial.placeholder">placeholder</link> 
				en utilisant la clé 'Zend_Layout':
            </para>

            <programlisting role="php"><![CDATA[<?php
$placeholders = new Zend_View_Helper_Placeholder();
$layoutVars   = $placeholders->placeholder('Zend_Layout')->getArrayCopy();
?>]]></programlisting>
        </note>
    </sect2>

    <sect2 id="zend.layout.advanced.plugin">
        <title>Plugin de contrôleur frontal personnalisé</title>

        <para>
            Lorsqu'utilisé avec les composants MVC, <code>Zend_Layout</code>
            enregistre un plugin de contrôleur frontal qui se charge du rendu de la 
			layout juste avant la fin de la boucle de dispatching. Ceci convient à la 
			majorité des cas, si cependant vous avez besoin de construire votre propre 
			plugin, passez son nom dans l'option <code>pluginClass</code> de la méthode 
			<code>startMvc()</code>.
        </para>

        <para>
            Votre plugin doit alors étendre <code>Zend_Controller_Plugin_Abstract</code>, 
			et devrait accepter un objet <code>Zend_Layout</code> lors de sa construction.
        </para>

        <para>
            La classe par défaut du plugin est 
			<code>Zend_Layout_Controller_Plugin_Layout</code>.
        </para>
    </sect2>

    <sect2 id="zend.layout.advanced.helper">
        <title>Aide d'action personnalisée</title>

        <para>
            Si les composants MVC sont utilisés, alors <code>Zend_Layout</code> 
            enregistre une classe d'aide d'action dans le gestionnaire d'aides 
			(helper broker). Par défaut, il s'agit de 
            <code>Zend_Layout_Controller_Action_Helper_Layout</code>. Cette aide 
			agit comme un proxy vers l'instance de <code>Zend_Layout</code> et 
			permet d'y accéder dans vos actions.
        </para>

        <para>
            Si vous voulez utiliser votre propre classe, celle-ci devra alors 
			étendre <code>Zend_Controller_Action_Helper_Abstract</code>. Passez le 
			nom de la classe dans l'option <code>helperClass</code> de la méthode 
            <code>startMvc()</code>.
        </para>
    </sect2>

    <sect2 id="zend.layout.advanced.inflector">
        <title>Résolution de chemin de script personnalisée (inflecteur)</title>

        <para>
            <code>Zend_Layout</code> utilise <code>Zend_Filter_Inflector</code> 
			pour établir une chaine de filtre permettant la résolution du nom de la 
			layout, vers le fichier y correspondant. Par défaut, les règles 
			'CamelCaseToDash' suivie de 'StringToLower' sont utilisées. Le suffixe
			'phtml' est ensuite ajouté:
        </para>

        <itemizedlist>
            <listitem><para>
                    'foo' sera transformé en 'foo.phtml'.
            </para></listitem>

            <listitem><para>
                    'FooBarBaz' sera transformé vers 'foo-bar-baz.phtml'.
            </para></listitem>
        </itemizedlist>

        <para>
            Vous pouvez personnaliser l'inflecteur de 3 manières différentes: 
			Modifier la cible et/ou le suffixe grâce à des accesseurs dans 
			<code>Zend_Layout</code>; Modifier les règles de l'inflecteur 
			associé à <code>Zend_Layout</code>; Ou encore créer votre propre 
			inflecteur et le passer à <code>Zend_Layout::setInflector()</code>.
        </para>

        <example id="zend.layout.advanced.inflector.accessors">
            <title>Ustilisation des accesseurs pour modifier l'inflecteur</title>

            <para>
                L'inflecteur par défaut de <code>Zend_Layout</code> utilise des 
				marqueurs statiques pour la cible et le suffixe. 2 accesseurs 
				vous sont donc proposés:
            </para>

            <programlisting role="php"><![CDATA[<?php
// Affecte une cible à l'inflecteur:
$layout->setInflectorTarget('layouts/:script.:suffix');

// Affecte le suffixe:
$layout->setViewSuffix('php');
?>]]></programlisting>
        </example>

        <example id="zend.layout.advanced.inflector.directmodification">
            <title>Modification directe de l'infecteur de Zend_Layout</title>

            <para>
                Les inflecteurs fonctionnent avec un cible et plusieurs règles.
				La cible par défaut utilisée pour <code>Zend_Layout</code> est 
				':script.:suffix'; ':script' représente la nom du script de layout,
				et ':suffix' est une règle statique.
            </para>

            <para>
                Imaginons que vous vouliez que le suffixe du script de layout soit 
                'html', et que vous vouliez séparer les mots en CamelCase avec des 
				underscores au lieu des tirets. De plus, vous voulez chercher vos 
				scripts dans un sousdossier 'layouts':
            </para>

            <programlisting role="php"><![CDATA[<?php
$layout->getInflector()->setTarget('layouts/:script.:suffix')
                       ->setStaticRule('suffix', 'html')
                       ->setFilterRule(array('CamelCaseToUnderscore'));
?>]]></programlisting>
        </example>

        <example id="zend.layout.advanced.inflector.custom">
            <title>Inflecteur personnalisé</title>

            <para>
                Dans la plupart des cas, modifier l'inflecteur sera suffisant.
				Vous pouvez cependant créer votre propre inflecteur, pour l'utiliser 
				à différents endroits par exemple, et le passer à 
				<code>Zend_Layout</code>:
            </para>

            <programlisting role="php"><![CDATA[<?php
$inflector = new Zend_Filter_Inflector('layouts/:script.:suffix');
$inflector->addRules(array(
    'script' => array('CamelCaseToUnderscore'),
    'suffix'  => 'html'
));
$layout->setInflector($inflector);
?>]]></programlisting>
        </example>

        <note>
            <title>L'inflecteur peut être désactivé</title>

            <para>
                L'inflecteur peut être désactivé si vous spécifiez, par exemple, 
				un chemin absolu pour un script utilisé par <code>Zend_Layout</code>.
				Les méthodes <code>enableInflection()</code> et 
                <code>disableInflection()</code> vous y aideront.
            </para>
        </note>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
