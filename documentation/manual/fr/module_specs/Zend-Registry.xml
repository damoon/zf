<sect1 id="zend.registry">
    <title>Zend::registry($index = null)</title>

    <para>
    Retourne la valeur stockée à la position $index du registre ou le registre lui-même.
    </para>

    <example>
        <title>Exemple d'usage de registry() / offsetGet()</title>
<programlisting role="php"><![CDATA[<?php	
Zend::registry($index=null)

// ou

$registre = Zend::registry();
$valeur = $registre->offsetGet($index);
?>]]></programlisting>
    </example>

    <para>
    Si une valeur a été stockée à la position <code>$index</code>, cette valeur sera retournée.
    Si l'argument <code>$index</code> vaut NULL, le registre lui-même sera retourné (une sous-classe 
    de <ulink url="http://www.php.net/~helly/php/ext/spl/classArrayObject.html">ArrayObject</ulink>
    ). Cette méthode enveloppe simplement la méthode
        <ulink url="http://www.php.net/manual/en/function.arrayobject-offsetget.php">
        offsetGet()</ulink>
        , et ajoute le comportement supplémentaire qui retourne le registre si $index n'est pas défini.
    </para>

    <para>
        Pour déterminer rapidement si un index existe dans le registre, utilisez Zend::isRegistered() :
    </para>

    <example>
        <title>Exemple d'utilisation de isRegistered() / offsetExists()</title>
<programlisting role="php"><![CDATA[<?php
Zend::isRegistered($index=null)

// ou

$registre = Zend::registry();
echo $registre->offsetExists($index) ? 'existe' : 'n\'existe pas';
?>]]></programlisting>
    </example>

    <para>
        Les itérations ne demandent que peu d'efforts :
    </para>

    <example>
        <title>Parcourir le registre</title>
<programlisting role="php"><![CDATA[<?php
foreach (Zend::registry() as $index => $value) {
    echo "$index => $value<br />\n";
}
?>]]></programlisting>
    </example>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
