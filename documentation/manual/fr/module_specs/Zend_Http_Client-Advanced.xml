<sect1 id="zend.http.client.advanced">
    <title>Zend_Http_Client - Utilisation avancée</title>

    <sect2 id="zend.http.client.redirections">
        <title>Redirections HTTP</title>
        <para>
            Par défaut, Zend_Http_Client gère automatiquement les redirections HTTP,
            et suivra jusqu'à 5 redirections. Ce comportement peut être modifié en changeant
            le paramètre de configuration 'maxredirects'.
        </para>
        <para>
            Conformément à la RFC HTTP/1.1, les codes réponse HTTP 301 et 302 devrait être
            traités par le client en envoyant à nouveau la même requête à l'adresse spécifiée
            - en utilisant la même méthode de requête. Cependant, la plupart
            des clients ne réagissent pas correctement et redirige toujours via une requête GET.
            Par défaut, Zend_Http_Client agit de même - Lors d'une redirection
            basée sur la réception d'un code 301 ou 302, tous les paramètres GET et POST sont
            remis à zéro, et une requête GET est envoyée à la nouvelle adresse. Ce
            comportement peut être changé en définissant le paramètre de configuration 'strictredirects'
            à TRUE :
            <example>
                <title>Forcer des redirections conformes au RFC 2616 lors de la réception d'un code statut 301 and 302</title>
                <programlisting role="php">
<![CDATA[<?php
    // Redirections strictes
    $client->setConfig(array('strictredirects' => true)

    // Redirections non strictes
    $client->setConfig(array('strictredirects' => false)
?>]]></programlisting>
            </example>
        </para>
        <para>
            Il est toujours possible d'obtenir le nombre de redirections effectuées
            après l'envoi d'une requête en invoquant la méthode getRedirectionsCount().
        </para>
    </sect2>

    <sect2 id="zend.http.client.cookies">
        <title>Ajout de cookies et gestion de leur persistence</title>
        <para>
            Zend_Http_Client fournit une interface simple afin d'ajouter des cookies
            à une requête de manière à ce qu'aucune modification directe de l'entête
            ne soit nécessaire. Ceci est réalisé via la méthode setCookie(). Cette
            méthode peut être utilisée de plusieurs manières :
        	<example>
                <title>Définition de cookies via setCookie()</title>
                <programlisting role="php">
<![CDATA[<?php
    // Simple et facile : en fournissant un nom de cookie et une valeur
    $client->setCookie('parfum', 'pépites de chocolat');

    // en fournissant directement une chaîne de cookie encodée (nom=valeur)
    // Notez que la valeur doit être déjà encodée au format URL
    $client->setCookie('parfum=p%C3%A9pites%20de%20chocolat');

    // En fournissant un objet Zend_Http_Cookie
    $cookie = Zend_Http_Cookie::factory('parfum=p%C3%A9pites%20de%20chocolat');
    $client->setCookie($cookie);
?>]]></programlisting>
            </example>
            Pour plus d'information sur les objets Zend_Http_Cookie, voir
        	<xref linkend="zend.http.cookies" />.
        </para>
        <para>
            Zend_Http_Client permet également la persistance des cookies -
            ce qui permet au client de stocker tous les cookies reçus et transmis,
            et de les retransmettre automatiquement lors des requêtes suivantes.
            Cela se révèle très utile lorsqu'il est nécessaire de s'identifier
            sur un site donné (et de recevoir ainsi un cookie de session) avant de
            pouvoir envoyer d'autres requêtes.
            <example>
                <title>Activer la persistance des cookies</title>
                <programlisting role="php">
<![CDATA[<?php
    // Pour activer la persistance des cookies, définissez un Magasin de cookie "Cookie Jar"
    $client->setCookieJar();

    // Première requête : s'identifier et démarrer une session
    $client->setUri('http://exemple.com/login.php');
    $client->addParameterPost('user', 'h4x0r');
    $client->addParameterPost('password', '1337');
    $client->request('POST');

    // Le magasin de cookies stocke automatiquement les
    // cookies transmis dans la réponse, un cookie de session par exemple

    // Maintenant nous pouvons envoyer notre requête suivante
    // les cookies stockés seront transmis automatiquement.
    $client->setUri('http://exemple.com/lire_actualite_membres.php');
    $client->request('GET');
?>]]></programlisting>
            </example>
            Pour plus d'information sur la classe Zend_Http_CookieJar, voir
        	<xref linkend="zend.http.cookies.cookiejar" />.
        </para>
    </sect2>

    <sect2 id="zend.http.client.custom_headers">
        <title>Définir des entêtes personnalisés</title>
        <para>
            Il est possible de définir des entêtes personnalisés en utilisant
            la méthode setHeaders().
            Cette méthode est très versatile et peut être utilisée de diverses
            manières comme le démontre l'exemple suivant :
            <example>
                <title>Définir un entête personnalisé unique</title>
                <programlisting role="php">
<![CDATA[<?php
    // Définition d'un entête unique, écrasant toute valeur précédemment déclarée
    $client->setHeaders('Host', 'www.exemple.com');

    // La même chose d'une autre manière
    $client->setHeaders('Host: www.example.com');

    // Définition de plusieurs valeurs pour le même entête (surtout utile pour les entêtes de cookies)
    $client->setHeaders('Cookie', array(
        'PHPSESSID=1234567890abcdef1234567890abcdef',
        'language=fr'
    ));
?>]]></programlisting>
            </example>
        </para>
        <para>
            setHeader() peut aussi être facilement utilisé pour définir des
            entêtes multiples en un seul appel, en fournissant un tableau d'entêtes
            comme paramètre unique :
            <example>
                <title>Définition de plusieurs entêtes personnalisés</title>
                <programlisting role="php">
<![CDATA[<?php
    // Définition de plusieurs entêtes, écrasant toute valeur précédemment déclarée
    $client->setHeaders(array(
        'Host' => 'www.exemple.com',
        'Accept-encoding', 'gzip,deflate',
        'X-Powered-By' => 'Zend Framework'));

    // Le tableau peut contenir uniquement des valeurs
    $client->setHeaders(array(
        'Host: www.exemple.com',
        'Accept-encoding: gzip,deflate',
        'X-Powered-By: Zend Framework'));
?>]]></programlisting>
            </example>
        </para>
    </sect2>

    <sect2 id="zend.http.client.file_uploads">
        <title>Envoi de fichiers</title>
        <para>
            Il est possible d'envoyer des fichiers au travers d'HTTP en utilisant
            la méthode setFileUpload. Cette méthode attend un nom de fichier
            comme premier paramètre, un nom de formulaire comme second paramètre,
            et des données comme troisième paramètre optionnel.
            Si le troisième paramètre est null, la valeur du premier paramètre
            est supposée être un fichier sur le disque dur et Zend_Http_Client
            essaiera de lire ce fichier et de l'envoyer. Si le troisième paramètre
            n'est pas null, la valeur de premier paramètre sera envoyée comme
            nom du fichier mais il n'est pas nécessaire que le fichier existe
            sur le disque dur.
            Le deuxième paramètre est toujours requis, et est équivalent à
            l'attribut "name" d'une balise &gt;input&lt;, si le fichier devait
            être envoyé à partir d'un formulaire HTML.
            Un quatrième paramètre optionnel fournit le type du fichier. S'il
            n'est pas spécifié et que Zend_Http_Client lit le fichier à partir
            du disque dur, la fonction mime_content_type sera utilisée pour
            tenter de définir, si possible, le type du fichier. Dans tous les
            cas, le type MIME par défaut sera application/octet-stream.
            <example>
                <title>Utilisation de setFileUpload pour envoyer des fichiers</title>
                <programlisting role="php">
<![CDATA[<?php
    // Envoi de données arbitraires comme fichier
    $texte = 'ceci est du texte ordinaire';
    $client->setFileUpload('du_texte.txt', 'upload', $texte, 'text/plain');

    // envoi d'un fichier existant
    $client->setFileUpload('/tmp/Backup.tar.gz', 'bufile');

    // envoi des fichiers
    $client->submit('POST');
?>]]></programlisting>
            </example>
            Dans le premier exemple, la variable $texte est envoyée et sera
            disponible dans $_FILES['upload'] côté serveur. Dans le second
            exemple, le fichier existant /tmp/Backup.tar.gz est envoyé au
            serveur et sera disponible dans $_FILES['bufile']. Son type sera
            défini automatiquement si possible. Sinon, le type sera défini
            comme 'application/octet-stream'.
        </para>
        <note>
            <title>Envoi de fichiers</title>
            <para>
                Lors de l'envoi de fichiers, le type de la requête HTTP
                est automatiquement défini comme 'multipart/form-data'.
                Gardez à l'esprit que vous devez utiliser la méthode POST
                ou la méthode PUT pour envoyer des fichiers. La plupart
                des serveurs ignoreront le corps de la requête si vous
                utilisez d'autres méthodes.
            </para>
        </note>
    </sect2>
    <sect2 id="zend.http.client.raw_post_data">
        <title>Envoyer des données brutes via POST</title>
        <para>
            Vous pouvez utiliser Zend_Http_Client pour envoyer des données
            brutes via POST en utilisant la méthode setRawData(). Cette
            méthode accepte deux paramètres : le premier contient les données
            à transmettre dans le corps de la requête. Le deuxième paramètre,
            optionnel, contient le type des données. Bien que ce paramètre
            soit optionnel, vous devriez normalement le définir avant l'envoi
            de la requête, soit via setRawData() ou via la méthode setEncType().
            <example>
                <title>Envoi de données brutes via POST</title>
                <programlisting role="php">
<![CDATA[<?php
    $xml = '<book>' .
           '  <title>Islands in the Stream</title>' .
           '  <author>Ernest Hemingway</author>' .
           '  <year>1970</year>' .
           '</book>';

    $client->setRawData($xml, 'text/xml')->request('POST');

    // Another way to do the same thing:
    $client->setRawData($xml)->setEncType('text/xml')->request('POST');
?>]]></programlisting>
            </example>
            The data should be available on the server side through PHP's
            $HTTP_RAW_POST_DATA variable or through the php://input stream.
        </para>
        <note>
            <title>Using raw POST data</title>
            <para>
                Setting raw POST data for a request will override any POST
                parameters or file uploads. You should not try to use both on
                the same request. Keep in mind that most servers will ignore
                the request body unless you send a POST request.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.http.client.http_authentication">
        <title>HTTP Authentication</title>
        <para>
            Currently, Zend_Http_Client only supports basic HTTP authentication.
            This feature is utilized using the setAuth() method. The method
            takes 3 parameters: The user name, the password and an optional
            authentication type parameter. As mentioned, currently only basic
            authentication is supported (digest authentication support is
            planned).
            <example>
                <title>Setting HTTP Authentication User and Password</title>
                <programlisting role="php">
<![CDATA[<?php
    // Using basic authentication
    $client->setAuth('shahar', 'myPassword!', Zend_Http_Client::AUTH_BASIC);

    // Since basic auth is default, you can just do this:
    $client->setAuth('shahar', 'myPassword!');
?>]]></programlisting>
            </example>
        </para>
    </sect2>

    <sect2 id="zend.http.client.multiple_requests">
        <title>Sending Multiple Requests With the Same Client</title>
        <para>
            Zend_Http_Client was also designed specifically to handle several
            consecutive requests with the same object. This is useful in cases
            where a script requires data to be fetched from several places, or
            when accessing a specific HTTP resource requires logging in and
            obtaining a session cookie, for example.
        </para>
        <para>
            When performing several requests to the same host, it is highly
            recommended to enable the 'keepalive' configuration flag. This way,
            if the server supports keep-alive connections, the connection to the
            server will only be closed once all requests are done and the Client
            object is destroyed. This prevents the overhead of opening and
            closing TCP connections to the server.
        </para>
        <para>
            When you perform several requests with the same client, but want
            to make sure all the request-specific parameters are cleared, you
            should use the resetParameters() method. This ensures that GET and
            POST parameters, request body and request-specific headers are
            reset and are not reused in the next request.
        </para>
        <note>
            <title>Reseting parameters</title>
            <para>
                Note that non-request specific headers are not reset when the
                resetParameters method is used. As a matter of fact, only the
                'Content-length' and 'Content-type' headers are reset. This
                allows you to set-and-forget headers like 'Accept-language' and
                'Accept-encoding'
            </para>
        </note>
        <para>
            Another feature designed specifically for consecutive requests is
            the Cookie Jar object. Cookie Jars allow you to automatically save
            cookies set by the server in the first request, and send them on
            consecutive requests transparently. This allows, for example, going
            through an authentication request before sending the actual data
            fetching request.
        </para>
        <para>
            If your application requires one authentication request per user,
            and consecutive requests might be performed in more than one script
            in your application, it might be a good idea to store the Cookie Jar
            object in the user's session. This way, you will only need to
            authenticate the user once every session.
        </para>
        <example>
            <title>Performing consecutive requests with one client</title>
            <programlisting role="php">
<![CDATA[<?php
    // First, instantiate the client
    $client = new Zend_Http_Client('http://www.example.com/fetchdata.php', array(
        'keepalive' => true
    ));

    // Do we have the cookies stored in our session?
    if (isset($_SESSION['cookiejar']) &&
        $_SESSION['cookiejar'] instanceof Zend_Http_CookieJar)) {

        $client->setCookieJar($_SESSION['cookiejar']);
    } else {
        // If we don't, authenticate and store cookies
        $client->setCookieJar();
        $client->setUri('http://www.example.com/login.php');
        $client->setParameterPost(array(
            'user' => 'shahar',
            'pass' => 'somesecret'
        ));
        $client->request(Zend_Http_Client::POST);

        // Now, clear parameters and set the URI to the original one
        // (note that the cookies that were set by the server are now
        // stored in the jar)
        $client->resetParameters();
        $client->setUri('http://www.example.com/fetchdata.php');
    }

    $response = $client->request(Zend_Http_Client::GET);

    // Store cookies in session, for next page
    $_SESSION['cookiejar'] = $client->getCookieJar();
?>]]></programlisting>
        </example>
    </sect2>
</sect1>