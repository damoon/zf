<sect1 id="zend.view.introduction">

    <title>Introduction</title>

    <para>
        <code>Zend_View</code> est une classe qui permet de travailler avec la partie "Vue" du motif de conception Modèle-Vue-Contrôleur. Elle existe pour aider à garder la vue séparée du modèle et des scripts du contrôleur. Elle fournie un système d'aide, de filtres d'affichage, et d'échappement de variables.
    </para>

    <para>
        <code>Zend_View</code> est un système de template agnostique ; vous pouvez utiliser PHP comme langage de template, ou créer des instances d'autres systèmes de templates, et les manipuler à travers les scripts de vue.
    </para>

    <para>
        L'utilisation de <code>Zend_View</code> se déroule en deux étapes principales :

        1. Votre script de contrôleur crée une instance de <code>Zend_View</code> et assigne des variables à cette instance.

        2. Le contrôleur dit à <code>Zend_View</code> d'effectuer le rendu d'une vue particulière, et de ce fait va donner le contrôle au script de vue, qui va générer l'affichage.
    </para>

    <sect2 id="zend.view.introduction.controller">

        <title>Script du Contrôleur</title>

        <para>
            Comme exemple simple, imaginons que votre contrôleur aie une liste de données sur des livres qu'il veut afficher en passant par une vue. Le contrôleur pourrait alors ressembler à ceci :
        </para>

        <programlisting role="php"><![CDATA[<?php
// utilise un modèle pour obtenir les données sur les livres : auteurs et titres
$data = array(
    array(
        'auteur' => 'Hernando de Soto',
        'titre' => 'Le mystère du capitalisme'
    ),
    array(
        'auteur' => 'Henry Hazlitt',
        'titre' => 'Les sciences économique en un cours'
    ),
    array(
        'auteur' => 'Milton Friedman',
        'titre' => 'Libre de choisir'
    )
);

// assigniation des données du livre à une instance Zend_View
Zend_Loader::loadClass('Zend_View');
$view = new Zend_View();
$view->books = $data;

// et appel du script de rendu d'affichage appelé "booklist.php"
echo $view->render('booklist.php');]]>
        </programlisting>

    </sect2>

    <sect2 id="zend.view.introduction.view">

        <title>Script de vue</title>

        <para>
            Maintenant, nous avons besoin d'associer le script de vue "booklist.php". C'est un script PHP comme les autres, à une exception près : il s'exécute dans la portée de l'instance <code>Zend_View</code>, ce qui veut dire que les référence à <code>$this</code> pointent vers les attributs et les méthodes de <code>Zend_View</code>. (Les variables assignées à l'instance par le contrôleur sont des propriétés publiques de l'instance <code>Zend_View</code>). Ainsi un script de vue de base pourrait ressembler à ceci:
      </para>

        <programlisting role="php"><![CDATA[<?php if ($this->books): ?>

    <!-- La table des livres -->
    <table>
        <tr>
            <th>Auteur</th>
            <th>Titre</th>
        </tr>

        <?php foreach ($this->books as $key => $val): ?>
        <tr>
            <td><?php echo $this->escape($val['auteur']) ?></td>
            <td><?php echo $this->escape($val['titre']) ?></td>
        </tr>
        <?php endforeach; ?>

    </table>

<?php else: ?>

    <p>Aucun livre à afficher</p>

<?php endif; ?>]]>
        </programlisting>

        <para>
            Notez l'utilisation de la méthode <code>escape</code> pour échapper les variables à afficher.
        </para>

    </sect2>

    <sect2 id="zend.view.introduction.options">
        <title>Options</title>

        <para>
            <code>Zend_View</code> possède plusieurs options qui peuvent être réglées pour changer le comportement de vos scripts de vues.
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>basePath :</code> indique le chemin de base où peuvent être trouvés les dossiers de scripts, d'aides et de filtres. Il considère une structure de dossiers de ce type :
                </para>

                <programlisting role="php"><![CDATA[
chemin/vers/
    helpers/
    filters/
    scripts/]]>
                </programlisting>

                <para>
                    Ceci peut être paramètré via les méthodes <code>setBasePath()</code>, <code>addBasePath()</code>, ou l'option <code>basePath</code> du constructeur.
                </para>
            </listitem>

            <listitem><para>
                <code>encoding :</code> indique l'encodage de caractère à utiliser avec <code>htmlentities()</code>, <code>htmlspecialchars()</code>, et tout autre opération. La valeur par défaut est ISO-8859-1 (latin1). Il peut être paramètré avec la méthode <code>setEncoding()</code> ou l'option <code>encoding</code> du constructeur.
            </para></listitem>

            <listitem><para>
                <code>escape :</code> indique le callback que doit utiliser <code>escape()</code>. Ceci pet être paramètré avec la méthode <code>setEscape()</code> ou l'option <code>escape</code> du constructeur.
            </para></listitem>

            <listitem><para>
                <code>filter :</code> indique un filtre à utiliser avant d'effectuer le rendu d'un script de vue. Ceci peut être paramètré avec les méthodes <code>setFilter()</code>, <code>addFilter()</code>, ou l'option <code>filter</code> du constructeur.
            </para></listitem>

            <listitem><para>
                <code>strictVars :</code> force <code>Zend_View</code> à émettre des "notices" et des "warnings" quand des variables non initialisées sont lues. Ceci peut être activé en appelant <code>strictVars(true)</code> ou en passant l'option <code>strictVars</code> au constructeur.
            </para></listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.view.introduction.accessors">
        <title>Utility Accessors</title>

        <para>
            Typically, you'll only ever need to call on <code>assign()</code>,
            <code>render()</code>, or one of the methods for setting/adding
            filter, helper, and script paths. However, if you wish to extend
            <code>Zend_View</code> yourself, or need access to some of its
            internals, a number of accessors exist:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>getVars()</code> will return all assigned variables.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>clearVars()</code> will clear all assigned variables;
                    useful when you wish to re-use a view object, but want to
                    control what variables are available..
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getScriptPath($script)</code> will retrieve the
                    resolved path to a given view script.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getScriptPaths()</code> will retrieve all registered
                    script paths.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getHelperPath($helper)</code> will retrieve the
                    resolved path to the named helper class.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getHelperPaths()</code> will retrieve all registered
                    helper paths.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getFilterPath($filter)</code> will retrieve the
                    resolved path to the named filter class.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getFilterPaths()</code> will retrieve all registered
                    filter paths.
                </para>
            </listitem>
        </itemizedlist>
    </sect2>

</sect1>