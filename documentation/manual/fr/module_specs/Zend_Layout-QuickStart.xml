<sect1 id="zend.layout.quickstart">
    <title>Zend_Layout dmarrage rapide</title>

    <para>
        Il y a deux modes d'utilisation de <code>Zend_Layout</code>: avec
        Zend Framework MVC, et sans.
    </para>

    <sect2 id="zend.layout.quickstart.layouts">
        <title>Scripts de layout</title>

        <para>
            Dans tous les cas, un script de layout est ncssaire.
            Les scripts de layout utilisent simplement Zend_View (ou une 
            implmentation particulire personnalise). Les variables de layout sont enregistres
            dans le <link linkend="zend.view.helpers.initial.placeholder">placeholder</link> 
            <code>Layout</code>, et peuvent tre accdes via l'aide de vue placeholder
            ou directement en tant que proprits de l'objet layout.
        </para>

        <para>
            Par exemple:
        </para>

        <programlisting role="php"><![CDATA[
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>My Site</title>
</head>
<body>
<?php 
    // rcupre la cl 'content' via l'aide de vue layout:
    echo $this->layout()->content; 

    // rcupre la cl 'foo' via l'aide de vue placeholder:
    echo $this->placeholder('Zend_Layout')->foo;

    // rcupre l'objet layout, et accde  diverses cls:
    $layout = $this->layout();
    echo $layout->bar;
    echo $layout->baz;
?>
</body>
</html>
]]></programlisting>

        <para>
            Toutes les aides de vue enregistres sont accessibles dans 
			<code>Zend_Layout</code> car il utilise <code>Zend_View</code> pour
            son propre rendu. Vous pouvez aussi accder aux variables de la vue.
			Les aides <link linkend="zend.view.helpers.initial.placeholder">placeholder
            </link> sont trs pratiques pour l'accs aux lments tels que &lt;head&gt;,
			les scripts, les meta, etc.:
        </para>

        <programlisting role="php"><![CDATA[
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title><?= $this->headTitle() ?></title>
    <?= $this->headScript() ?>
    <?= $this->headStyle() ?>
</head>
<body>
    <?= $this->render('header.phtml') ?>

    <div id="nav"><?= $this->placeholder('nav') ?></div>

    <div id="content"><= $this->layout()->content ?></div>

    <?= $this->render('footer.phtml') ?>
</body>
</html>
]]></programlisting>
    </sect2>

    <sect2 id="zend.layout.quickstart.mvc">
        <title>Utilisation de Zend_Layout avec le systme MVC de Zend Framework</title>

        <para>
            <code>Zend_Controller</code> propose une manire d'tendre ses fonctionnalits
			au travers de <link linkend="zend.controller.plugins">plugins de 
			contrleur frontal</link> et <link
            linkend="zend.controller.actionhelpers">d'aides d'action</link>.
			<code>Zend_View</code> propose aussi des <link
            linkend="zend.view.helpers">aides</link>. <code>Zend_Layout</code>
            utilise toutes ces possibilits lorsqu'employ avec les composants MVC.
        </para>

        <para>
            <code>Zend_Layout::startMvc()</code> cre une instance de
            <code>Zend_Layout</code> avec des paramtres de configuration optionnels.
			Cette mthode enregistre aussi un plugin de contrleur frontal qui s'occupe 
			du rendu du layout rempli, lorsque la boucle de dispatching est termine.
			Elle enregistre galement une aide d'action qui permet aux actions 
			d'accder  l'objet <code>layout</code>.
			Enfin, l'aide de vue layout, elle, donne accs  l'objet layout depuis 
			la vue.
        </para>

        <para>
            Regardons d'abord comment initialiser Zend_Layout afin de l'utiliser dans 
			un contexte MVC :
        </para>

        <programlisting role="php"><![CDATA[<?php
// Dans le fichier de dmarrage (bootstrap)
Zend_Layout::startMvc();
?>]]></programlisting>
        
        <para>
            <code>startMvc()</code> peut prendre en paramtre un tableau d'options ou 
			un objet <code>Zend_Config</code> pour personnaliser l'instance.
			Ces options sont dtailles dans <xref linkend="zend.layout.options" />.
        </para>

        <para>
            Dans le contrleur d'action, vous pouvez donc accder  l'instance de 
			layout via l'aide d'action :
        </para>

        <programlisting role="php"><![CDATA[<?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // dsactive les layouts pour cette action
        $this->_helper->layout->disableLayout();
    }

    public function bazAction()
    {
        // utilise un script de layout diffrent pour
		// cette action
        $this->_helper->layout->setLayout('foobaz');
    };
}
?>]]></programlisting>

        <para>
            Dans vos scripts de vue, utiliser l'aide <code>layout</code> pour 
			accder  l'instance de <code>Zend_Layout</code>. Notez que cette aide est diffrente
			des autres car elle ne retourne pas une chaine, mais bien un objet.
			Vous pouvez donc enchainer une mthode immdiatement :
        </para>

        <programlisting role="php"><![CDATA[
<?php $this->layout()->setLayout('foo'); // utilise un script de layout spcifique?>
]]></programlisting>

        <para>
            Autrement, vous pouvez n'importe o accder  votre instance de 
			<code>Zend_Layout</code> via la mthode statique 
			<code>getMvcInstance()</code> :
        </para>

        <programlisting role="php"><![CDATA[<?php
// Retourne null si startMvc() n'a pas t appele auparavant
$layout = Zend_Layout::getMvcInstance(); 
?>]]></programlisting>

        <para>
            Enfin, le plugin de contrleur frontal <code>Zend_Layout</code> dispose
			d'une caracteristique annexe au rendu automatique du layout : il analyse
			les segments de l'objet de rponse et les assigne en tant que variables de 
			layout dans vos scripts de layout. Le segment 'default' est assign  la 
			variable 'content'. Ceci permet de mettre la main sur le contenu rendu 
			dans l'action principale.
        </para>

        <para>
            Par exemple, supposons que votre code rencontre d'abord 
			<code>FooController::indexAction()</code>, qui va rendre du contenu dans le 
			segment par dfaut de la rponse. Ensuite il forward vers 
            <code>NavController::menuAction()</code>, qui rend son contenu dans un segment 
			nomm 'nav'. Enfin, vous forwardez vers 
			<code>CommentController::fetchAction()</code> pour rcuprer des 
			commentaires, mais vous les rendez aussi dans le segment par defaut de la rsponse
			(ce qui va rajouter du contenu). Votre script de layout peut alors rendre chaque 
			segment de manire spare :
        </para>

        <programlisting role="php"><![CDATA[
<body>
    <!-- rend /nav/menu -->
    <div id="nav"><?= $this->layout()->nav ?></div>

    <!-- rend /foo/index + /comment/fetch -->
    <div id="content"><?= $this->layout()->content ?></div>
</body>
]]></programlisting>
        
        <para>
            Cette approche est particulirement utile avec 
			<link linkend="zend.controller.actionhelpers.actionstack">l'aide d'action</link> 
			ActionStack et son <link linkend="zend.controller.plugins.standard.actionstack">
			plugin</link> du mme nom. Vous pouvez les utiliser pour grer une pile d'actions 
			et ainsi dcomposer vos processus.
        </para>
    </sect2>

    <sect2 id="zend.layout.quickstart.standalone">
        <title>Utilisation de Zend_Layout en composant indpendant</title>

        <para>
            Pris indpendament des composants MVC, Zend_Layout n'offre pas tout  fait les mmes 
			possibilits et la mme flxibilit. Cependant, vous bnficiez de deux avantages :
        </para>

        <itemizedlist>
            <listitem><para>
                    Des variables propres aux layouts.
            </para></listitem>

            <listitem><para>
                    Isolation du script de layout, de son contenu issu de scripts de vue.
            </para></listitem>
        </itemizedlist>

        <para>
            En tant que composant indpendant, instanciez un objet <code>Zend_Layout</code>, 
			configurez le au moyen d'accesseurs, passez vos variables comme des proprits de 
			l'objet, et rendez le layout :
        </para>

        <programlisting role="php"><![CDATA[<?php
$layout = new Zend_Layout();

// Spcification du chemin des scripts layout:
$layout->setLayoutPath('/path/to/layouts');

// passage de quelques variables :
$layout->content = $content;
$layout->nav     = $nav;

// Utilisation d'un script de layout 'foo' :
$layout->setLayout('foo');

// rendu de le layout :
echo $layout->render();
?>]]></programlisting>
    </sect2>

    <sect2 id="zend.layout.quickstart.example">
        <title>Layout d'exemple</title>

        <para>
            Une image vallant mieux qu'un paragraphe, voyez donc celle-ci qui dcrit l'utilisation :
        </para>

         <para>
            <inlinegraphic align="center" valign="middle"
                fileref="figures/zend.layout.quickstart.example.png" format="PNG" />
        </para>

        <para>
            Avec cette approche, vous pouvez rgler vos mises en forme css.
			En positionnement absolu, par exemple, vous pourriez rendre la barre de navigation 
			plus tard, en fin. Le mcanisme d'obtention du contenu reste le mme cependant.
        </para>
    </sect2>
</sect1>