<sect1 id="zend.cache.introduction">
    <title>Introduction</title>
    <para>
        <code>Zend_Cache</code> founit un moyen générique des mettre en cache des données.
    </para>
    <para>
      Le cache dans le Framework Zend opère via frontends alors que les caches d'enregistrements sont stockés
      grâce à des adapteurs de backend (<code>File</code>, <code>Sqlite</code>, <code>Memcache</code>...)
      à travers un système souple d'IDs et de balises. En les utilisant, il est simple de supprimer des
      types spécifiques d'enregistrements par la suite (par exemple: "supprime tous les enregistrement de
      cache marqué avec une balise donnée")
    </para>
    <para>
        Le coeur du module (<code>Zend_Cache_Core</code>) est générique, souple et configurable.
        Pour le moment, pour vos besoins spécifiques, il y a des frontends qui étendent <code>Zend_Cache_Core</code>.
        pour votre confort : <code>Output</code>, <code>File</code>, <code>Function</code> and <code>Class</code>.
    </para>
    <example>
        <title>Créer un frontend avec <code>Zend_Cache::factory()</code></title>
        <para>
            <code>Zend_Cache::factory()</code> instancie les objets corrects et les lie ensemble.
            Dans le premier exemple, nous allons utiliser le frontend <code>Core</code> avec le
            backend <code>File</code>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200, // temps de vie du cache de 2 heures
   'automaticSerialization' => true
);

$backendOptions = array(
    'cacheDir' => './tmp/' // Répertoire où stocker les fichiers de cache
);

// créer un objet Zend_Cache_Code
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?>]]></programlisting>
       </para>
       <para>
            Maintenant que nous avons un frontend, nous pouvons mettre en cache tout type de données.
            Nous avons activé la serialisation. Par exemple nous pouvons mettre en cache le résultat
            d'une requête SQL couteuse. Après qu'il soit mis en cache, il n'y a plus besoin de se connecter
            à la base de données. Les enregistrement récupéré depuis le cache sont désérialisés.
            <programlisting role="php"><![CDATA[<?php

// $cache initialisé dans l'exemple précédent

// on regarde si un cache existe déjà
if(!$result = $cache->get('myresult')) {

    // le cache est manquant, connexion à la base de données
    $db = Zend_Db::factory( [...] );

    $result = $db->fetchAll('SELECT * FROM grosse_table');

    $cache->save($result, 'myresult');

} else {

    // il y a un cache
    echo "This one is from cache!\n\n";

}

print_r($result);

?>]]></programlisting>
       </para>
    </example>
    <example>
        <title>Cache de sortie avec le frontend de sortie <code>Zend_Cache</code></title>
        <para>
            Nous marquons les sections dans lesquelles nous voulons une cache de sortie en ajoutant
            de la logique conditionnelle, en encapsulant la section entre les méthodes
            <code>start()</code> et <code>end()</code> (cela ressemble au premier exemple
            et est la core strategy de pour la mise en cache)
        </para>
        <para>
            A l'intéreieur, affichez vous données comme d'habitude toutes les sorties seront misent en cache
            quans la méthode <code>end()</code> est appelée.
            A la prochaine exécution, la section complète sera passée, au profit de la récupération de son cache
            (si le cache est encore valide).
            <programlisting role="php"><![CDATA[<?php

$frontendOptions = array(
   'lifeTime' => 30,                  // temps de vue du cache de 30 secondes
   'automaticSerialization' => false  // par défaut
);

$backendOptions = array('cacheDir' => './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// nous passons un identifiant unique à la méthode start()
if(!$cache->start('mypage')) {
    // output as usual:

    echo 'Hello world! ';
    echo 'Ceci est dy cache('.time().') ';

    $cache->end(); // la sortie est sauvegardée est envoyé au navigateur
}

echo 'Ceci n\' jamais mis en cache ('.time().').';

?>]]>       </programlisting>
       </para>
       <para>
           Notez que nous affichons le résultat de <code>time()</code> deux fois; c'est dans un but de
           démonstrations. Essayez de lancer la page est de la rafraichir plusieurs fois; you allez
           constater que la premier nombre ne change pas alors que le second change à chaque actualisation.
           C'est parce que le premier nombre a été mis en cache est sauvegardé.
           Après 30 secondes, le nombre devrait de nouveau correspondre au second nombre
           parce que le cache a espiré -- seulement pour être caché de nouveau.
           Vous devriez essayer ça dans votre navigateur ou dans une console.
       </para>
    </example>
    <note><para>
        Lorsque vous utilisez Zend_Cache, faite attention à l'identifiant du cache (passé à <code>save()</code>
        et <code>start()</code>). Il doit être unique pour chaque ressource que vous mettez en cache, sinon il
        est possible que des caches en efface d'autres, ou encore pire, s'affiche en lieu et place d'autres.
    </para></note>
</sect1>


<sect1 id="zend.cache.theory">
    <title>La théorie du cache</title>
    <para>
        Il y a trois concepts clés dans Zend_Cache.
        Le premier est l'identifiant unique (une chaîne) qui est utilisé pour identifier les enregistrements
        de cache.
        Le seconde est la directive <code>'lifeTime'</code> vue dans les exemples; elle définie combien de temps
        la ressource de cache est considéré comme à jour.
        Le troisième est l'exécution conditionnelle, ainsi chaque partie de votre code peut être passée entièrement,
        pour améliorer les performances.
        Le fonction principale du frontend (<code>Zend_Cache_Core::get()</code>) est toujours faite pour retourner
        false en cas de cache manquant, si cela donne du sens pour la nature d'un frontend.
        Cela permet aux utiliseurs d'entourer des parties de code qu'ils veulent mettre en cache (and passer) dans une
        instruction <code>if(){ ... }</code> ou la condition est une méthode Zend_Cache.
        A la fin de ces blocs, vous devez sauvegarder ce que vous avez généré (eg. <code>Zend_Cache_Core::save()</code>).
    </para>
    <note><para>
        Le design de l'exécution conditionelle de votre code généré n'est pas forcément dans des frontends.
        (<code>Function</code>, par exemple) quand toute la logique est implémentée à l'intérieur du frontend.
    </para></note>
    <note><para>
        Le 'Cache hit' est un terme pour une condition quand l'enregistremetn de cache est trouvé, valide, et
        à jour (en d'autres mots, qu'il n'a pas encore expiré).
        Le 'Cache miss' est tout le reste.
        Lorsque un 'Cache miss' survient, vous devez générer vos données (comme vous le feriez normallement)
        et le mettre en cache.
        Lorsque vous avez un 'Cache hit', le backend récupère pour vous et de façon transparente, les enregistrements.
    </para></note>
    <sect2 id="zend.cache.factory">
        <title>La méthode de fabrique de <code>Zend_Cache</code></title>
        <para>
            Une bonne manière de construire une instance utilisable d'un frontend  <code>Zend_Cache</code>
            est donnée dans l'exemple suivant:
            <programlisting role="php"><![CDATA[<?php

# Nous chargeons la fabrique Zend_Cache
require 'Zend/Cache.php';

# Nous choisissons un backend (par exemple 'File' ou 'Sqlite')
$backendName = '[...]';

# Nous choisissons un frontend (par exemple: 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# Nous définissons un tableau d'options pour le frontend choisit
$frontendOptions = array([...]);

# Nous définisson un tableau d'options pour le banckend choisit
$backendOptions = array([...]);

# Nous créons la bonne instance
# Bien sur, les deux derniers arguments sont optionnels
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

?>]]></programlisting>
        </para>
        <para>
            Dans les exemples suivants, nous nous assurerons que la variable <code>$cache</code>
            utilise un frontend valide, et que vous comprenez comment passer des paramètres à vos
            backends.
        </para>
        <note><para>
            Utilisez toujours <code>Zend_Cache::factory()</code> pour obtenir des instances de frontend.
            Instancier des frontend et des backends ne fonctionnera pas comme prévu.
        </para></note>
    </sect2>

    <sect2 id="zend.cache.tags">
        <title>Marquer les enregistrements</title>
        <para>
            Les balises sont un moyen de categoriser les enregistrements de cache.
            Quand vous sauvegardez un cache avec la méthode <code>save()</code>
            vous pouvez définir un tableau de balises qui s'appliqueront pour cette enregistrement.
            Ensuite vous serez en mesure de nettoyer tous les enregistrement de cache identifiés par
            une balise (ou des balises) données:
        <programlisting role="php"><![CDATA[<?php

$cache->save($large_donnees, 'monIDUnique', array('tagA', 'tagB', 'tagC'));

?>]]></programlisting></para>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>Nettoyer le cache</title>
        <para>
            Pour supprimer/invalider un identifiant de cache particulier, vous pouvez utiliser
            la méthode <code>remove()</code> :
             <programlisting role="php"><![CDATA[<?php

$cache->remove('idAEffacer');

?>]]></programlisting>
        </para>
        <para>
            Pour efface/invalider plusieurs identifiants de caches en une seule opération, vous pouvez
            utiliser la méthode <code>clean()</code>
            Par exemple, pour supprimer tous les caches :
              <programlisting role="php"><![CDATA[<?php
// nettoie tous les enregistrements
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// nettoie uniquement les caches obsolètes
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);

?>]]>       </programlisting>
            Si vous voulez effacer les caches correspondant aux balises 'tagA' et 'tagC':
              <programlisting role="php"><![CDATA[<?php

$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tagA', 'tagC'));

?>]]>       </programlisting>
        </para>
        <para>
            Les modes disponibles de nettoyage sont
            <code>CLEANING_MODE_ALL</code>, <code>CLEANING_MODE_OLD</code>,
            <code>CLEANING_MODE_MATCHING_TAG</code> et <code>CLEANING_MODE_NOT_MATCHING_TAG</code>.
            Ils sont à combiner avec un tableau de balises utilisées pour les opérations de nettoyage
        </para>
    </sect2>
</sect1>

<sect1 id="zend.cache.frontends">
    <title>frontends Zend_Cache</title>

    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Core</code> est un frontend spécial parce qu'il est le coeur du module.
                C'est un frontend de cache générique et est étendu par les autres classes.
            </para>
            <note><para>
                Tous les frontends héritent de <code>Zend_Cache_Core</code> ainsi les méthodes et les options
                (décrites ci-dessous) seront aussi disponibles dans les autres frontends, cependant ils
                ne sont pas documentés ici.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>Options disponibles</title>
            <para>
                Ces options sont passées à la méthode de fabrique comme montrées dans les exemples
                précédents.
            </para>
            <table>
                <title>Otions disponibles</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>booléen</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  active / désactive le caching (peut-être très utile
                                  pour les débogage de scripts en cache)
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                temps de vie (en secondes) du cache, si défini à <code>null</code>, le
                                cache est valide infiniment
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>booléen</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                si définit à true, le logging par <code>Zend_Log</code> est activé
                                (mais le système sera plus lent)
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>booléen</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Active / désactive le contrôle d'écriture (le cache est lu juste après
                                l'écriture pour détecter des entrées corrompues), activer writeControl
                                va un tout petit peu ralentire l'écriture du cache, mais pas la lecture
                                (il peut détecter des fichiers de cache corrompus, mais ça n'est pas un
                                contrôle parfait).
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>booléen</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Active / désactive la sérialization automatique, il peut être
                                utilisé pour enregistrer directement des données qui ne sont pas des
                                chaînes de caractères (mais c'est plus lent).
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                Active / désactive le nettoyage automatique( garbage collector):
                                0 signifie aucun nettoyage automatique de cache,
                                1 signifie un nettoyage systématique du cache
                                et x &gt; 1 signifie le nettoyage aléatoire 1 fois toute les
                                x écritures.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.core.examples">
            <title>Exemples</title>
            <para>
                Un exemple est donné dans le manuel, tout au début.
            </para>
            <para>
                Si vous stocker uniquement des chaînes de caractères dans le cache (parce qu'avec l'option "automaticSerialization",
                il est possible de stocker des booléns), vous pouvez utiliser une construction plus compact comme:
                 <programlisting role="php"><![CDATA[<?php

// nous avons déjà $cache

$id = 'myBigLoop'; // id de cache de "ce que l'on veut cacher"

if (!($data = $cache->get($id))) {
    // cache miss

    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}

// fait quelque chose avec $data (affichage, passage ailleurs, etc, etc)

?>]]>       </programlisting>
            </para>
            <para>
                Si vous voulez cacher des blocs multiples ou des instances de données, l'idée
                reste la même:
                 <programlisting role="php"><![CDATA[<?php

// on s'assure que l'on utilise des identifiant uniques
$id1 = 'foo';
$id2 = 'bar';

// block 1
if (!($data = $cache->get($id1))) {
    // cache missed

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}
echo($data);

// ça n'est pas affecté par la mise en cache
echo('NEVER CACHED! ');

// block 2
if (!($data = $cache->get($id2))) {
    // cache missed

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }

    $cache->save($data);

}
echo($data);

?>]]>       </programlisting>
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontend.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontend.output.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Output</code> est un frontend capturant la sortie.
                Il utilise la bufferisation de sortie de PHP pour capturer tout ce qui passe entre les méthodes
                <code>start()</code> et <code>end()</code> .
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.output.options">
            <title>Options disponibles</title>
            <para>
                Ce frontend n'a pas d'options spécifiques autres que celles de <code>Zend_Cache_Core</code>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontend.output.examples">
            <title>Exemples</title>
            <para>
                Un exemple est donnée dans le manuel, tout au début.
                Le voici avec des changements mineurs:
                 <programlisting role="php"><![CDATA[<?php

// s'il y a un cache miss, la bufferisation de sortie est lancée
if(!$cache->start('mypage')):

// affiche tout comme d'habitude
echo 'Hello world! ';
echo 'This is cached ('.time().') ';

$cache->end(); // output buffering ends
endif;

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
            </para>
            <para>
                Utiliser cette forme est assez simple pour définir une mise de cache de sortie dans vos projets
                en production, avec peu de refactorisation de code.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontend.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontend.function.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Function</code> met en cache les résultats des appels de fonction.
                Elle a une seule méthode principale appelée <code>call()</code> qui prend un nom de fonction
                et des paramètres pour l'appel dans un tableau.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.function.options">
            <title>Options disponibles</title>
            <table>
                <title>Options disponibles</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>booléen</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  si true, les appels de fonction seront mis en cache par défaut
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  les noms de fonctions seront toujours mis en cache
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  les noms de fonctions ne doivent jamais être mis en cache
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontend.function.examples">
            <title>Exemples</title>
            <para>
                Utiliser la fonction <code>call()</code> est le même qu'utiliser le
                code <code>call_user_func_array()</code> en PHP:
                 <programlisting role="php"><![CDATA[<?php

$cache->call('veryExpensiveFunc', $params);

# $params est dans un tableau
# par exemple, pour appeler (avec mise en cache) veryExpensiveFunc(1, 'foo', 'bar'), vous devriez utiliser
# $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar'))

?>]]>       </programlisting>
            </para>
            <para>
                <code>Zend_Cache_Frontend_Function</code> est assez intelligente pour mettre en cache
                la valeur de retour de la fonction, aisi que sa sortie interne.
            </para>
            <note><para>
                Vous pouvez passer n'importe quelle fonction utilisateur à l'exception de
                <code>array()</code>, <code>echo()</code>, <code>empty()</code>, <code>eval()</code>,
                <code>exit()</code>, <code>isset()</code>, <code>list()</code>, <code>print()</code>
                et <code>unset()</code>.
            </para></note>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontend.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontend.class.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Class</code> est différent de <code>Zend_Cache_Frontend_Function</code>
                parce qu'elle permet de mettre en cache les objets et les méthodes statiques.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.class.options">
            <title>Options disponibles</title>
            <table>
                <title>Options disponibles</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cachedEntity</code> (required)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  si définit à un nom de classe, nous allons mettre en cache une claisse
                                  abstraite et utiliser uniquement les appels statiques; si définis à un objet,
                                  nous allons mettre en cache les méthodes de ces objets.
                              </entry>
                         </row>
                         <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>booléen</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  si true, les appels vont être caché par défault
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  les noms des méthodes qui seront toujours mis
                                  en cache
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  les nomes des méthodes qui ne doivent jamais être misent en cache
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontend.class.examples">
            <title>Exemples</title>
            <para>
                Par exemple, pour mettre en cache des appels statiques:
                <programlisting role="php"><![CDATA[<?php

class test {

    # Méthode statique
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => 'test' // Le nom de la classe
);
// [...]

# l'appel caché
$res = $cache->foobar('1', '2');

?>]]>           </programlisting>
                Pour mettre en cache des appels classiques aux méthodes:
                <programlisting role="php"><![CDATA[<?php

class test {

    private $_string = 'hello !';

    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => new test() // Une instance de la classe
);
// [...]

# L'appel mis en cache
$res = $cache->foobar2('1', '2');

?>]]>           </programlisting>
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> est un frontend conduit par la modification
                d'un "fichier maître". C'est vraiment intéressant, par exemple, dans les problématiques
                de configuration ou de templates.
            </para>
            <para>
                Pour l'instant, vous avez un fichier de configuration XML qui est parsé par une
                fonction qui retourne un "objet config" (comme avec <code>Zend_Config</code>).
                Avec <code>Zend_Cache_Frontend_File</code>, vous pouvez stocker l'objet config dans le cache
                (pour éviter de parser le XML du fichier de config chaque fois) mais avec une sorte de
                forte dépendance au fichier maître. Ainsi si le fichier XML de config est modifié, le cache
                est immédiatement invalidé.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Options disponibles</title>
            <table>
                <title>Options disponibles</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>masterFile (mandatory)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  le chemin complet et le nom du fichier maître
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Exemples</title>
            <para>
                L'utilisation de ce frontend est la même que celle de<code>Zend_Cache_Core</code>.
                Il n'y a pas besoin d'exemple spécifique - la seule chose à faire est de définir
                le <code>masterFile</code> lors de l'utilisation de la fabrique.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.page">
    	<title>Zend_Cache_Frontend_Page</title>
    	<sect3 id="zend.cache.frontends.page.introduction">
        	<title>Introduction</title>
        	<para>
	            <code>Zend_Cache_Frontend_Page</code> est comme <code>Zend_Cache_Frontend_Output</code>
	            mais créé pour une page complete. Il est impossible d'utiliser <code>Zend_Cache_Frontend_Page</code>
	            pour mettre en cacher un bloc unique.
	        </para>
	        <para>
	            D'un autre côté, la "cache id", est calculé automatiquement avec <code>$_SERVER['REQUEST_URI']</code> et
	            (en fonction des options) <code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>,
	            <code>$_COOKIE</code>, <code>$_FILES</code>.
	            De plus, vous avez seulement une méthode pour appeler (<code>start()</code>)
	            parce que l'appel à <code>end()</code> est totalement automatique lorsque la page est terminé.
	        </para>
	        <para>
	            Pour le moment, ça n'est pas implémenté mais nous prévoyons d'ajouter un système de condition
	            HTTP pour économiser de la bande passant. (le système enverra une entête HTTP 304 Not Modified
	            si le cache est trouvé, et si le navigateur a déjà la bonne version).
	        </para>
	        <note><para>
                Zend_Cache_Frontend_Page est vraiment en version alpha, et est prévue d'être
                amélioré plus tard.
	        </para></note>
    	</sect3>
    	<sect3 id="zend.cache.frontends.page.options">
	        <title>Options disponibles (pour ce frontend dans la fabrique Zend_Cache)</title>
	        <table>
	            <title>Options disponibles</title>
	            <tgroup cols="4">
	                 <thead>
	                      <row>
	                        <entry>Option</entry>
	                        <entry>Type de données</entry>
	                        <entry>Valeur par défaut</entry>
	                        <entry>Description</entry>
	                    </row>
	                 </thead>
	                 <tbody>
	                 	 <row>
	                          <entry><code>httpConditional</code></entry>
	                          <entry><code>booléen</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              utilisez le système httpConditionnal ou pas (pas encore implémenté)
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>debugHeader</code></entry>
	                          <entry><code>booléen</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              si true, un text de débogage est ajouté avant chaque page de cache
	                          </entry>
	                     </row>
	                     <row>
	                     	  <entry><code>defaultOptions</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array(...see below...)</code></entry>
	                          <entry>
	                              un tableau associatif d'options par défaut:
	                              <itemizedlist>
	                                  <listitem><code>(booléen, true par défaut) cache</code> : le cache est activé si true</listitem>
	                                  <listitem><code>(booléen, false par défaut) cacheWithGetVariables</code> : si true, le cache est toujours activé même s'il y a des variables dans le tableau <code>$_GET</code></listitem>
	                                  <listitem><code>(booléen, false par défaut) cacheWithPostVariables</code> : si true, le cache est toujours activé même s'il y a des variables dans le tableau <code>$_POST</code></listitem>
	                                  <listitem><code>(booléen, false par défaut) cacheWithSessionVariables</code> : si true, le cache est toujours activé s'il y a des variables dans le tableau <code>$_SESSION</code></listitem>
	                                  <listitem><code>(booléen, false par défaut) cacheWithFilesVariables</code> : si true, le cache est toujours activé s'il y a des variables dans le tableau <code>$_FILES</code></listitem>
	                                  <listitem><code>(booléen, false par défaut) cacheWithCookieVariables</code> : si true, le cache est toujours activé s'il y a des variables dans le tableau <code>$_COOKIE</code></listitem>
									  <listitem><code>(booléen, true par défaut) makeIdWithGetVariables</code> : si true, l'identifiant du cache sera indépendant du contenu du tableau<code>$_GET</code></listitem>
	                                  <listitem><code>(booléen, true par défaut) makeIdWithPostVariables</code> : si true, l'identifiant du cache sera indépendant du contenu du tableau<code>$_POST</code></listitem>
	                                  <listitem><code>(booléen, true par défaut) makeIdWithSessionVariables</code> : si true, l'identifiant du cache sera indépendant du contenu du tableau<code>$_SESSION</code></listitem>
	                                  <listitem><code>(booléen, true par défaut) makeIdWithFilesVariables</code> : si true, l'identifiant du cache sera indépendant du contenu du tableau<code>$_FILES</code></listitem>
	                                  <listitem><code>(booléen, true par défaut) makeIdWithCookieVariables</code> : si true, l'identifiant du cache sera indépendant du contenu du tableau<code>$_COOKIE</code></listitem>
	                              </itemizedlist>
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>regexps</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array()</code></entry>
	                          <entry>
	                              un tableau associatif pour définir les options, uniquement pour des REQUEST_URI, les clés sont des regex PCRE,
	                              les valeurs sont des tableaus associatifs avec des options spécifiques pour définir si les correspondances des
	                              regexs dans $_SERVER['REQUEST_URI'] (voir les options par défaut pour la liste des options disponibles) ; si
	                              plusieurs regexs correspondent à un $_SERVER['REQUEST_URI'], seul la dernière sera utilisée.
	                          </entry>
	                     </row>
	                  </tbody>
	              </tgroup>
	          </table>
	    </sect3>
    	<sect3 id="zend.cache.frontends.page.examples">
        	<title>Exemples</title>
	        <para>
	            Utilisation de Zend_Cache_Frontend_Page est vraiment trivial :
	            <programlisting role="php"><![CDATA[<?php

// [...] // require, configuration et factory

$cache->start();
// si le cache est trouvé, le résultat est envoyé au navigateur et le script s'arrête là

// reste de la page ...

?>]]>           </programlisting>
	        </para>
	        <para>
	            un exemple plus complexe qui montre un moyen pour obtenir une gestion centralisée du cache dans un fichier
	            d'amorçage (pour utiliser avec Zend_Controller par exemple)
	        	<programlisting role="php"><![CDATA[<?php

// vous devriez éviter de mettre trop de lignes avant la section de cache
// [...] par exemple, pour des performances optimales, "require_once" ou "Zend::loadClass" devrait être
// [...] après la section de cache

require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200,
   'debugHeader' => true, // for debuging
   'regexps' => array(
       '^/$' => array('cache' => true),         // met en cache la totalité d'IndexController
       '^/index/' => array('cache' => true),    // met en cache la totalité d'IndexController
       '^/article/' => array('cache' => false), // nous ne mettons pas en cache l'ArticleController...
       '^/article/view/' => array(              // ...mais nous mettons en cache l'action "view"
           'cache' => true,                     // de cet ArticleController
           'cacheWithPostVariables' => true,    // et nous mettons en cache même lorsqu'il y a des variables dans $_POST
           'makeIdWithPostVariables' => true,   // (mais le cache sera dépendent du tableau $_POST)
       )
   )
);
$backendOptions = array(
    'cacheDir' => '/tmp/'
);

// obtenir un objet Zend_Cache_Frontend_Page
$cache = Zend_Cache::factory('Page', 'File', $frontendOptions, $backendOptions);

$cache->start();
// si nous trouvons un cache, le résultat est envoyé au navigateur, et le script s'arrête là

// [...] la fin du fichier de démarrage ( ces lignes ne seront pas exécutée si on trouve un cache)

?>]]>           </programlisting>
	        </para>
    	</sect3>
	</sect2>
</sect1>

<sect1 id="zend.cache.backends">
    <title>Zend_Cache backends</title>

    <sect2 id="zend.cache.backends.file">
        <title>Zend_Cache_Backend_File</title>
        <para>
            Ces backends stockent les enregistrements de cache dans des fichiers (dans un dossier choisit).
        </para>
        <para>
            Les options disponibles sont :
        </para>
        <table>
            <title>Options disponibles</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Type de données</entry>
                        <entry>Valeur par défaut</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDir</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'/tmp/'</code></entry>
                          <entry>
                              Répertoire ou stocker les fichiers de cache
                          </entry>
                      </row>
                      <row>
                          <entry><code>fileLocking</code></entry>
                          <entry><code>booléen</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Active / désactive le verrou de fichier : peut éviter la corruption
                            du cache dans de mauvaises circonstances, mais il n'aide en rien sur
                            des serveur multithreadé ou sur des systèmes de fichier NFS...
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControl</code></entry>
                          <entry><code>booléen</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Active / désactive le contrôle de lecture : si activé, une clé de contrôle
                            est embarquée dans le fichier de cache et cette clé est comparée avec celle
                            calculée après la lecture.
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControlType</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'crc32'</code></entry>
                          <entry>
                            Type de contrôle de lecture (seulement si le contrôle de lecture est activé).
                            Les valeurs disponibles sont :
                            'md5' (meilleur mais plus lent), 'crc32' (un peu moins sécurisé, mais plus rapide, c'est
                            un meilleur choix),
                            'strlen' pour un test de longueur uniquement (le plus rapide).
                        </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryLevel</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0</code></entry>
                          <entry>
                            Niveau de structure du hash du répertoire:
                            0 signifie "par de hashage de la structure du répertoire",
                            1 signifie "un niveau de répertoire",
                            2 signifie "deux niveaux"...
                            Cette option peut accélérer le cache seulement lorsque vous avez plusieurs
                            centaines des fichiers de cache.
                            Seuls des benchs spécifique peuvent vous aider à choisir la meilleure valeur
                            pour vous. 1 ou 2, peut-être un bon départ.
                          </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryUmask</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0700</code></entry>
                          <entry>
                              Umask pour l'arboresence
                        </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
        <title>Zend_Cache_Backend_Sqlite</title>
        <para>
            Ce backend stocke les enregistrements de cache dans une base de donnée SQLite.
        </para>
        <para>
            Les options disponibles sont :
        </para>
        <table>
            <title>Options disponibles</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Type de données</entry>
                        <entry>Valeur par défaut</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDBCompletePath (mandatory)</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>null</code></entry>
                          <entry>
                              Le chemin complet (nom du fichier inclus) de la base de donnée SQLite
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.memcached">
        <title>Zend_Cache_Backend_Memcached</title>
        <para>
            Ces backends stockent les enregistrements de cache dans un serveur memcached.
            <ulink url="http://www.danga.com/memcached/">memcached</ulink> est un système de cache
            en mémoire distribuée, de haute performance.
            Pour utiliser ce backend, vous devez avec un démon memcached et l'extension
            <ulink url="http://pecl.php.net/package/memcache">the memcache PECL extension</ulink>.
        </para>
        <para>
        	Be careful : with this backend, "tags" are not supported for the moment as
        	the "doNotTestCacheValidity=true" argument.
        </para>
        <para>
            Les options disponibles sont :
        </para>
        <table>
            <title>Options disponibles</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Type de données</entry>
                        <entry>Valeur par défaut</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>servers</code></entry>
                          <entry><code>array</code></entry>
                          <entry><code>array(array('host' => 'localhost','port' => 11211, 'persistent' => true))</code></entry>
                          <entry>
                              Un tableau de serveurs memcached; chaque server memcached est décrit par un tableau associatif:
                              'host' => (string) : le nom du seveur memcached,
                              'port' => (int) : le port du serveur memcached,
                              'persistent' => (bool) : utilisation ou pas des connexions persistents pour ce serveur memecached.
                          </entry>
                      </row>
                      <row>
                          <entry><code>compression</code></entry>
                          <entry><code>booléen</code></entry>
                          <entry><code>flase</code></entry>
                          <entry>
                             vrai si vous voulez utiliser la compression à la volée
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.apc">
        <title>Zend_Cache_Backend_APC</title>
        <para>
            Ce backend stocke les enregistrements de cache en mémoire partagée grâce à l'extension
            the <ulink url="http://pecl.php.net/package/APC">APC</ulink> (Alternative PHP Cache).
        </para>
        <para>
            Attention: avec ce backend, "tags" ne sont pas supporté pour le moment comme argument
        	"doNotTestCacheValidity=true".
        </para>
        <para>
            Il n'y a pas d'options pour ce backend.
        </para>
    </sect2>
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->