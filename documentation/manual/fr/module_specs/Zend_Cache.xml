<sect1 id="zend.cache.introduction">
    <title>Introduction</title>
    <para>
        <code>Zend_Cache</code> founit un moyen générique des mettre en cache des données.
    </para>
    <para>
      Le cache dans le Framework Zend opère via frontends alors que les caches d'enregistrements sont stockés
      grâce à des adapteurs de backend (<code>File</code>, <code>Sqlite</code>, <code>Memcache</code>...)
      à travers un système souple d'IDs et de balises. En les utilisant, il est simple de supprimer des
      types spécifiques d'enregistrements par la suite (par exemple: "supprime tous les enregistrement de
      cache marqué avec une balise donnée")
    </para>
    <para>
        Le coeur du module (<code>Zend_Cache_Core</code>) est générique, souple et configurable.
        Pour le moment, pour vos besoins spécifiques, il y a des frontends qui étendent <code>Zend_Cache_Core</code>.
        pour votre confort : <code>Output</code>, <code>File</code>, <code>Function</code> and <code>Class</code>.
    </para>
    <example>
        <title>Créer un frontend avec <code>Zend_Cache::factory()</code></title>
        <para>
            <code>Zend_Cache::factory()</code> instancie les objets corrects et les lie ensemble.
            Dans le premier exemple, nous allons utiliser le frontend <code>Core</code> avec le
            backend <code>File</code>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200, // temps de vie du cache de 2 heures
   'automaticSerialization' => true
);

$backendOptions = array(
    'cacheDir' => './tmp/' // Répertoire où stocker les fichiers de cache
);

// créer un objet Zend_Cache_Code
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?>]]></programlisting>
       </para>
       <para>
            Maintenant que nous avons un frontend, nous pouvons mettre en cache tout type de données.
            Nous avons activé la serialisation. Par exemple nous pouvons mettre en cache le résultat
            d'une requête SQL couteuse. Après qu'il soit mis en cache, il n'y a plus besoin de se connecter
            à la base de données. Les enregistrement récupéré depuis le cache sont désérialisés.
            <programlisting role="php"><![CDATA[<?php

// $cache initialisé dans l'exemple précédent

// on regarde si un cache existe déjà
if(!$result = $cache->get('myresult')) {

    // le cache est manquant, connexion à la base de données
    $db = Zend_Db::factory( [...] );

    $result = $db->fetchAll('SELECT * FROM grosse_table');

    $cache->save($result, 'myresult');

} else {

    // il y a un cache
    echo "This one is from cache!\n\n";

}

print_r($result);

?>]]></programlisting>
       </para>
    </example>
    <example>
        <title>Cache de sortie avec le frontend de sortie <code>Zend_Cache</code></title>
        <para>
            Nous marquons les sections dans lesquelles nous voulons une cache de sortie en ajoutant
            de la logique conditionnelle, en encapsulant la section entre les méthodes
            <code>start()</code> et <code>end()</code> (cela ressemble au premier exemple
            et est la core strategy de pour la mise en cache)
        </para>
        <para>
            A l'intéreieur, affichez vous données comme d'habitude toutes les sorties seront misent en cache
            quans la méthode <code>end()</code> est appelée.
            A la prochaine exécution, la section complète sera passée, au profit de la récupération de son cache
            (si le cache est encore valide).
            <programlisting role="php"><![CDATA[<?php

$frontendOptions = array(
   'lifeTime' => 30,                  // temps de vue du cache de 30 secondes
   'automaticSerialization' => false  // par défaut
);

$backendOptions = array('cacheDir' => './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// nous passons un identifiant unique à la méthode start()
if(!$cache->start('mypage')) {
    // output as usual:

    echo 'Hello world! ';
    echo 'Ceci est dy cache('.time().') ';

    $cache->end(); // la sortie est sauvegardée est envoyé au navigateur
}

echo 'Ceci n\' jamais mis en cache ('.time().').';

?>]]>       </programlisting>
       </para>
       <para>
           Notez que nous affichons le résultat de <code>time()</code> deux fois; c'est dans un but de
           démonstrations. Essayez de lancer la page est de la rafraichir plusieurs fois; you allez
           constater que la premier nombre ne change pas alors que le second change à chaque actualisation.
           C'est parce que le premier nombre a été mis en cache est sauvegardé.
           Après 30 secondes, le nombre devrait de nouveau correspondre au second nombre
           parce que le cache a espiré -- seulement pour être caché de nouveau.
           Vous devriez essayer ça dans votre navigateur ou dans une console.
       </para>
    </example>
    <note><para>
        Lorsque vous utilisez Zend_Cache, faite attention à l'identifiant du cache (passé à <code>save()</code>
        et <code>start()</code>). Il doit être unique pour chaque ressource que vous mettez en cache, sinon il
        est possible que des caches en efface d'autres, ou encore pire, s'affiche en lieu et place d'autres.
    </para></note>
</sect1>


<sect1 id="zend.cache.theory">
    <title>La théorie du cache</title>
    <para>
        Il y a trois concepts clés dans Zend_Cache.
        Le premier est l'identifiant unique (une chaîne) qui est utilisé pour identifier les enregistrements
        de cache.
        Le seconde est la directive <code>'lifeTime'</code> vue dans les exemples; elle définie combien de temps
        la ressource de cache est considéré comme à jour.
        Le troisième est l'exécution conditionnelle, ainsi chaque partie de votre code peut être passée entièrement,
        pour améliorer les performances.
        Le fonction principale du frontend (<code>Zend_Cache_Core::get()</code>) est toujours faite pour retourner
        false en cas de cache manquant, si cela donne du sens pour la nature d'un frontend.
        Cela permet aux utiliseurs d'entourer des parties de code qu'ils veulent mettre en cache (and passer) dans une
        instruction <code>if(){ ... }</code> ou la condition est une méthode Zend_Cache.
        A la fin de ces blocs, vous devez sauvegarder ce que vous avez généré (eg. <code>Zend_Cache_Core::save()</code>).
    </para>
    <note><para>
        Le design de l'exécution conditionelle de votre code généré n'est pas forcément dans des frontends.
        (<code>Function</code>, par exemple) quand toute la logique est implémentée à l'intérieur du frontend.
    </para></note>
    <note><para>
        Le 'Cache hit' est un terme pour une condition quand l'enregistremetn de cache est trouvé, valide, et
        à jour (en d'autres mots, qu'il n'a pas encore expiré).
        Le 'Cache miss' est tout le reste.
        Lorsque un 'Cache miss' survient, vous devez générer vos données (comme vous le feriez normallement)
        et le mettre en cache.
        Lorsque vous avez un 'Cache hit', le backend récupère pour vous et de façon transparente, les enregistrements.
    </para></note>
    <sect2 id="zend.cache.factory">
        <title>The <code>Zend_Cache</code> factory method</title>
        <para>
            A good way to build a usable instance of a <code>Zend_Cache</code> Frontend is given
            in the following example :
            <programlisting role="php"><![CDATA[<?php

# We "load" the Zend_Cache factory
require 'Zend/Cache.php';

# We choose a backend (for example 'File' or 'Sqlite'...)
$backendName = '[...]';

# We choose a frontend (for example 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# We set an array of options for the choosen frontend
$frontendOptions = array([...]);

# We set an array of options for the choosen backend
$backendOptions = array([...]);

# We make the good instance
# (of course, the two last arguments are optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

?>]]></programlisting>
        </para>
        <para>
            In the following examples we will assume that the <code>$cache</code> variable holds a
            valid, instantiated frontend as shown and that you understand how to pass parametres
            to your chosen backends.
        </para>
        <note><para>
            Always use <code>Zend_Cache::factory()</code> to get frontend instances. Instantiating
            frontends and backends yourself will not work as expected.
        </para></note>
    </sect2>

    <sect2 id="zend.cache.tags">
        <title>Tagging records</title>
        <para>
            Tags are a way to categorize cache records. When you save a cache with the <code>save()</code>
            method, you can set an array of tags to apply for this record. Then you will be
            able to clean all cache records tagged with a given tag (or tags):
        <programlisting role="php"><![CDATA[<?php

$cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));

?>]]></programlisting></para>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>Cleaning the cache</title>
        <para>
            To remove/invalidate in particular cache id, you can use the <code>remove()</code>
            method :
             <programlisting role="php"><![CDATA[<?php

$cache->remove('idToRemove');

?>]]></programlisting>
        </para>
        <para>
            To remove/invalidate several cache ids in one operation, you can use the <code>clean()</code>
            method. For example to remove all cache records :
              <programlisting role="php"><![CDATA[<?php

// clean all records
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// clean only outdated
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);

?>]]>       </programlisting>
            If you want to remove cache entries matching the tags 'tagA' and 'tagC':
              <programlisting role="php"><![CDATA[<?php

$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tagA', 'tagC'));

?>]]>       </programlisting>
        </para>
        <para>
            Available cleaning modes are: <code>CLEANING_MODE_ALL</code>, <code>CLEANING_MODE_OLD</code>,
            <code>CLEANING_MODE_MATCHING_TAG</code> and <code>CLEANING_MODE_NOT_MATCHING_TAG</code>. The
            latter are, as their names suggest, combined with an array of tags in cleaning operations.
        </para>
    </sect2>
</sect1>

<sect1 id="zend.cache.frontends">
    <title>Zend_Cache frontends</title>

    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Core</code> is a special frontend because it is the core
                of the module. It is a generic cache frontend and is extended by other classes.
            </para>
            <note><para>
                All frontends inherit from <code>Zend_Cache_Core</code> so that its methods and options
                (described below) would also be available in other frontends, therefore they won't be
                documented there.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>Available options</title>
            <para>
                These options are passed to the factory method as demonstrated in previous examples.
            </para>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  enable / disable caching (can be very usefull for the debug of
                                  cached scripts)
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                cache lifetime (in seconds), if set to <code>null</code>, the
                                cache is valid forever.
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                if set to true, logging through <code>Zend_Log</code> is activated
                                (but the system is slower)
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Enable / disable write control (the cache is read
                                just after writing to detect corrupt entries), enabling writeControl
                                will lightly slow the cache writing but not the cache reading (it
                                can detect some corrupt cache files but it's not a perfect control)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Enable / disable automatic serialization, it can be used to save directly datas
                                which aren't strings (but it's slower)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                Disable / Tune the automatic cleaning process (garbage collector):
                                0 means no automatic cache cleaning, 1 means systematic cache cleaning
                                and x &gt; 1 means automatic random cleaning 1 times in x write operations.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.core.examples">
            <title>Examples</title>
            <para>
                An example is given in the manual at the very beginning.
            </para>
            <para>
                If you store only strings into cache (because with "automaticSerialization" option, it's possible
                to store some booleans), you can use a more compact construction like:
                 <programlisting role="php"><![CDATA[<?php

// we assume you already have $cache

$id = 'myBigLoop'; // cache id of "what we want to cache"

if (!($data = $cache->get($id))) {
    // cache miss

    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}

// [...] do something with $data (echo it, pass it on etc.)

?>]]>       </programlisting>
            </para>
            <para>
                If you want to cache multiple blocks or data instances, the idea is the same:
                 <programlisting role="php"><![CDATA[<?php

// make sure you use unique identifiers:
$id1 = 'foo';
$id2 = 'bar';

// block 1
if (!($data = $cache->get($id1))) {
    // cache missed

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}
echo($data);

// this isn't affected by caching
echo('NEVER CACHED! ');

// block 2
if (!($data = $cache->get($id2))) {
    // cache missed

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }

    $cache->save($data);

}
echo($data);

?>]]>       </programlisting>
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontend.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontend.output.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Output</code> is an output-capturing frontend. It utilizes
                output buffering in PHP to capture everything between its <code>start()</code> and
                <code>end()</code> methods.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.output.options">
            <title>Available options</title>
            <para>
                This frontend doesn't have any specific options other than those of
                <code>Zend_Cache_Core</code>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontend.output.examples">
            <title>Examples</title>
            <para>
                An example is given in the manual at the very beginning. Here it is with minor changes:
                 <programlisting role="php"><![CDATA[<?php

// if it is a cache miss, output buffering is triggered
if(!$cache->start('mypage')):

// output everything as usual
echo 'Hello world! ';
echo 'This is cached ('.time().') ';

$cache->end(); // output buffering ends
endif;

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
            </para>
            <para>
                Using this form it is fairly easy to set up output caching in your already working project
                with little or no code refactoring.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontend.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontend.function.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Function</code> caches the results of function calls. It has
                a single main method named <code>call()</code> which takes a function name and parameters
                for the call in an array.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.function.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  if true, function calls will be cached by default
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  function names which will always be cached
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  function names which must never be cached
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontend.function.examples">
            <title>Examples</title>
            <para>
                Using the <code>call()</code> function is the same as using
                <code>call_user_func_array()</code> in PHP:
                 <programlisting role="php"><![CDATA[<?php

$cache->call('veryExpensiveFunc', $params);

# $params is an array
# for example to call (with caching) veryExpensiveFunc(1, 'foo', 'bar'), you will use
# $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar'))

?>]]>       </programlisting>
            </para>
            <para>
                <code>Zend_Cache_Frontend_Function</code> is smart enough to cache both the
                return value of the function and its internal output.
            </para>
            <note><para>
                You can pass any builtin or user defined function with the exception of
                <code>array()</code>, <code>echo()</code>, <code>empty()</code>, <code>eval()</code>,
                <code>exit()</code>, <code>isset()</code>, <code>list()</code>, <code>print()</code>
                and <code>unset()</code>.
            </para></note>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontend.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontend.class.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Class</code> is different from <code>Zend_Cache_Frontend_Function</code>
                because it allows caching of object and static method calls.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.class.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cachedEntity</code> (required)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  if set to a class name, we will cache an abstract class and will use
                                  only static calls; if set to an object, we will cache this object methods
                              </entry>
                         </row>
                         <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  if true, calls will be cached by default
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  method names which will always be cached
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  method names which must never be cached
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontend.class.examples">
            <title>Examples</title>
            <para>
                For example, to cache static calls :
                <programlisting role="php"><![CDATA[<?php

class test {

    # Static method
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => 'test' // The name of the class
);
// [...]

# The cached call
$res = $cache->foobar('1', '2');

?>]]>           </programlisting>
                To cache classic method calls :
                <programlisting role="php"><![CDATA[<?php

class test {

    private $_string = 'hello !';

    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => new test() // An instance of the class
);
// [...]

# The cached call
$res = $cache->foobar2('1', '2');

?>]]>           </programlisting>
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> is a frontend driven by the
                modification time of a "master file". It's really interesting for examples
                in configuration or templates issues.
            </para>
            <para>
            	For instance, you have an XML configuration file which is parsed by a function
            	which returns a "config object" (like with <code>Zend_Config</code>). With
            	<code>Zend_Cache_Frontend_File</code>, you can store the "config object" into
            	cache (to avoid the parsing of the XML config file at each time) but with a
            	sort of strong dependency on the "master file". So, if the XML config file
            	is modified, the cache is immediatly invalidated.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>masterFile (mandatory)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  the complete path and name of the master file
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Examples</title>
            <para>
                Use of this frontend is the same than of <code>Zend_Cache_Core</code>. There
                is no need of a specific example - the only thing to do is to
                define the <code>masterFile</code> when using the factory.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.page">
    	<title>Zend_Cache_Frontend_Page</title>
    	<sect3 id="zend.cache.frontends.page.introduction">
        	<title>Introduction</title>
        	<para>
	            <code>Zend_Cache_Frontend_Page</code> is like <code>Zend_Cache_Frontend_Output</code>
	            but designed for a complete page. It's impossible to use <code>Zend_Cache_Frontend_Page</code>
	            for caching only a single block.
	        </para>
	        <para>
	        	On the other hand, the "cache id" is calculated automatically with
	        	<code>$_SERVER['REQUEST_URI']</code> and (depending on options)
	        	<code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>, <code>$_COOKIE</code>, <code>$_FILES</code>.
	        	More over, you have only one method to call (<code>start()</code>) because the
	        	<code>end()</code> call is fully automatic when the page is ended.
	        </para>
	        <para>
	        	For the moment, it's not implemented but we plan to add a HTTP conditional system
	        	to save bandwith (the system will send a HTTP 304 Not Modified if the cache is hit
	        	and if the browser has already the good version).
	        </para>
	        <note><para>
                Zend_Cache_Frontend_Page is really "alpha stuff" and is meant to be improved further down the road.
	        </para></note>
    	</sect3>
    	<sect3 id="zend.cache.frontends.page.options">
	        <title>Available options (for this frontend in Zend_Cache factory)</title>
	        <table>
	            <title>Available options</title>
	            <tgroup cols="4">
	                 <thead>
	                      <row>
	                        <entry>Option</entry>
	                        <entry>Data Type</entry>
	                        <entry>Default Value</entry>
	                        <entry>Description</entry>
	                    </row>
	                 </thead>
	                 <tbody>
	                 	 <row>
	                          <entry><code>httpConditional</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              use the httpConditional system (not implemented for the moment)
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>debugHeader</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              if true, a debug text is added before each cached pages
	                          </entry>
	                     </row>
	                     <row>
	                     	  <entry><code>defaultOptions</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array(...see below...)</code></entry>
	                          <entry>
	                              an associative array of default options :
	                              <itemizedlist>
	                                  <listitem><code>(boolean, true by default) cache</code> : cache is on if true</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithGetVariables</code> : if true, cache is still on even if there are some variables in <code>$_GET</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithPostVariables</code> : if true, cache is still on even if there are some variables in <code>$_POST</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithSessionVariables</code> : if true, cache is still on even if there are some variables in <code>$_SESSION</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithFilesVariables</code> : if true, cache is still on even if there are some variables in <code>$_FILES</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithCookieVariables</code> : if true, cache is still on even if there are some variables in <code>$_COOKIE</code> array</listitem>
									  <listitem><code>(boolean, true by default) makeIdWithGetVariables</code> : if true, the cache id will be dependent of the content of the <code>$_GET</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithPostVariables</code> : if true, the cache id will be dependent of the content of the <code>$_POST</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithSessionVariables</code> : if true, the cache id will be dependent of the content of the <code>$_SESSION</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithFilesVariables</code> : if true, the cache id will be dependent of the content of the <code>$_FILES</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithCookieVariables</code> : if true, the cache id will be dependent of the content of the <code>$_COOKIE</code> array</listitem>
	                              </itemizedlist>
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>regexps</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array()</code></entry>
	                          <entry>
	                          	  an associative array to set options only for some REQUEST_URI, keys are (PCRE) regexps, values are
	                          	  associative arrays with specific options to set if the regexp matchs on $_SERVER['REQUEST_URI']
                                  (see defaultOptions for the list of available options) ; if several regexps match the $_SERVER['REQUEST_URI'],
                                  only the last one will be used
	                          </entry>
	                     </row>
	                  </tbody>
	              </tgroup>
	          </table>
	    </sect3>
    	<sect3 id="zend.cache.frontends.page.examples">
        	<title>Examples</title>
	        <para>
	            Use of Zend_Cache_Frontend_Page is really trivial :
	            <programlisting role="php"><![CDATA[<?php

// [...] // require, configuration and factory

$cache->start();
// if the cache is hit, the result is sent to the browser and the script stop here

// rest of the page ...

?>]]>           </programlisting>
	        </para>
	        <para>
	        	a more complex example which shows a way to get a centralized cache management in a bootstrap file
	        	(for using with Zend_Controller for example)
	        	<programlisting role="php"><![CDATA[<?php

// [...] you should avoid to put too much lines before the cache section
// [...] for example, for optimal performances, "require_once" or "Zend::loadClass" should be
// [...] after the cache section

require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200,
   'debugHeader' => true, // for debuging
   'regexps' => array(
       '^/$' => array('cache' => true),         // cache the whole IndexController
       '^/index/' => array('cache' => true),    // cache the whole IndexController
       '^/article/' => array('cache' => false), // we don't cache the ArticleController...
       '^/article/view/' => array(              // ...but we cache the "view" action of
           'cache' => true,                     // this ArticleController
           'cacheWithPostVariables' => true,    // and we cache even there are some variables in $_POST
           'makeIdWithPostVariables' => true,   // (but the cache will be dependent of the $_POST array)
       )
   )
);
$backendOptions = array(
    'cacheDir' => '/tmp/'
);

// getting a Zend_Cache_Frontend_Page object
$cache = Zend_Cache::factory('Page', 'File', $frontendOptions, $backendOptions);

$cache->start();
// if the cache is hit, the result is sent to the browser and the script stop here

// [...] the end of the bootstrap file (these lines won't be executed if the cache is hit)

?>]]>           </programlisting>
	        </para>
    	</sect3>
	</sect2>
</sect1>

<sect1 id="zend.cache.backends">
    <title>Zend_Cache backends</title>

    <sect2 id="zend.cache.backends.file">
        <title>Zend_Cache_Backend_File</title>
        <para>
            This backends stores cache records into files (in a choosen directory).
        </para>
        <para>
            Available options are :
        </para>
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDir</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'/tmp/'</code></entry>
                          <entry>
                              Directory where to store cache files
                          </entry>
                      </row>
                      <row>
                          <entry><code>fileLocking</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Enable / disable fileLocking : Can avoid cache corruption under
                            bad circumstances but it doesn't help on multithread webservers
                            or on NFS filesystems...
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControl</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Enable / disable read control : if enabled, a control key is
                            embeded in the cache file and this key is compared with the
                            one calculated after the reading.
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControlType</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'crc32'</code></entry>
                          <entry>
                            Type of read control (only if read control is enabled). Available values are :
                            'md5' (best but slowest), 'crc32' (lightly less safe but faster, better choice),
                            'strlen' for a length only test (fastest).
                        </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryLevel</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0</code></entry>
                          <entry>
                            Hashed directory structure level :     0 means "no hashed directory
                             structure", 1 means "one level of directory", 2 means "two levels"...
                             This option can speed up the cache only when you have many thousands of
                             cache files. Only specific benchs can help you to choose the perfect
                             value for you. Maybe, 1 or 2 is a good start.
                          </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryUmask</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0700</code></entry>
                          <entry>
                              Umask for the hashed directory structure
                        </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
        <title>Zend_Cache_Backend_Sqlite</title>
        <para>
            This backends stores cache records into a SQLite database.
        </para>
        <para>
            Available options are :
        </para>
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                           <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDBCompletePath (mandatory)</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>null</code></entry>
                          <entry>
                              The complete path (filename included) of the SQLite database
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.memcached">
        <title>Zend_Cache_Backend_Memcached</title>
        <para>
            This backends stores cache records into a memcached server. <ulink url="http://www.danga.com/memcached/">memcached</ulink>
            is a high-performance, distributed memory object caching system. To use this backend,
            you need a memcached daemon and <ulink url="http://pecl.php.net/package/memcache">the memcache PECL extension</ulink>.
        </para>
        <para>
        	Be careful : with this backend, "tags" are not supported for the moment as
        	the "doNotTestCacheValidity=true" argument.
        </para>
        <para>
            Available options are :
        </para>
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>servers</code></entry>
                          <entry><code>array</code></entry>
                          <entry><code>array(array('host' => 'localhost','port' => 11211, 'persistent' => true))</code></entry>
                          <entry>
                              An array of memcached servers ; each memcached server is described by an associative array :
                              'host' => (string) : the name of the memcached server,
                              'port' => (int) : the port of the memcached server,
                              'persistent' => (bool) : use or not persistent connections to this memcached server
                          </entry>
                      </row>
                      <row>
                          <entry><code>compression</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>flase</code></entry>
                          <entry>
                             true if you want to use on-the-fly compression
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.apc">
        <title>Zend_Cache_Backend_APC</title>
        <para>
            This backends stores cache records in shared memory through
            the <ulink url="http://pecl.php.net/package/APC">APC</ulink> (Alternative PHP Cache) extension
            (which is of course need for using this backend).
        </para>
        <para>
        	Be careful : with this backend, "tags" are not supported for the moment as
        	the "doNotTestCacheValidity=true" argument.
        </para>
        <para>
            There is no option for this backend.
        </para>
    </sect2>
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->