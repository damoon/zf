<sect1 id="zend.xmlrpc.server">
    <title>Zend_XmlRpc_Server</title>

    <sect2 id="zend.xmlrpc.server.introduction">
        <title>Introduction</title>

        <para>Zend_XmlRpc_Server fournit un serveur XML-RPC qui suit les spécifications
            <ulink url="http://www.xmlrpc.com/spec"> dictées par www.xmlrpc.com</ulink>.
            Il fournit aussi la méthode system.multicall(), permettant le traitement de requêtes multiples.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.usage">
        <title>Usage de base</title>

        <para>
            Voici un exemple d'une utilisation basique :
        </para>

        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'My/Service/Class.php';

$server = new Zend_XmlRpc_Server();
$server->setClass('My_Service_Class');
echo $server->handle();]]>
        </programlisting>
    </sect2>

    <sect2 id="zend.xmlrpc.server.structure">
        <title>Structures du serveur</title>

        <para>
            Zend_XmlRpc_Server se décompose en un objet serveur (lui-même), un objet requête, réponse, et 
            des objets d'erreurs.
        </para>

        <para>
            Pour démarrer un serveur Zend_XmlRpc_Server, vous devez attacher une ou plusieurs classes ou fonctions
            au serveur, grâce à  <code>setClass()</code> et <code>addFunction()</code>.
        </para>

        <para>
            Lorsque c'est fait, vous pourriez passer un objet <code>Zend_XmlRpc_Request</code> à
            <code>Zend_XmlRpc_Server::handle()</code>, sinon par défaut il utilisera un objet
            <code>Zend_XmlRpc_Request_Http</code> qui récupèrera la requête depuis <code>php://input</code>.
        </para>

        <para>
            <code>Zend_XmlRpc_Server::handle()</code> va alors essayer de traiter la requête. Cette méthode retournera
            un objet <code>Zend_XmlRpc_Response</code> ou <code>Zend_XmlRpc_Server_Fault</code>. Tous deux possèdent 
            une méthode <code>__toString()</code> qui crée une réponse XML valide XML-RPC.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.conventions">
        <title>Conventions</title>
        <para>
            Zend_XmlRpc_Server permet d'attacher des classes et/ou des fonctions au serveur XML-RPC. Grace à 
            Zend_Server_Reflection, l'introspection va utiliser les blocs de commentaires pour determiner les types d'arguments
            et de réponse de la fonction/classe.
        </para>

        <para>
            Les types XML-RPC n'ont pas forcément de correspondance native vers un type PHP. Le code fera de son mieux pour deviner
            le type de données approprié, en se basant sur les valeurs listées dans les tags @param et @return. Certains types XML-RPC
            n'ont par contre pas d'équivalent PHP direct, ils devront alors être spécifiés manuellement sous forme de tags phpdoc :            
        </para>

        <itemizedlist>
            <listitem><para>dateTime.iso8601, une chaine formattée comme
                    YYYYMMDDTHH:mm:ss</para></listitem>
            <listitem><para>base64, données encodées en base64</para></listitem>
            <listitem><para>struct, tableau associatif</para></listitem>
        </itemizedlist>

        <para>
            Voici un exemple d'utilisation de type particulier:
        </para>

        <programlisting role="php"><![CDATA[<?php
/**
* This is a sample function
*
* @param base64 $val1 Base64-encoded data
* @param dateTime.iso8601 $val2 An ISO date
* @param struct $val3 An associative array
* @return struct
*/
function myFunc($val1, $val2, $val3)
{
}]]>
        </programlisting>

        <para>
            PhpDocumentor ne vérifie (valide) pas les types des paramètres, mais les types sont obligatoires pour que le
            serveur puisse lui, valider les paramètres passés aux appels des méthodes.
        </para>

        <para>
            Il est parfaitement valide de spécifier plusieurs types pour les paramètres et les retours de méthodes.
            La spécification XML-RPC suggère que system.methodSignature retourne un tableau des possibilités au regard des
            paramètres d'entrée de la méthode, et de son type de sortie. Ceci ce fait grace au caractère '|' de PhpDocumentor
        </para>

        <programlisting role="php"><![CDATA[<?php
/**
* This is a sample function
*
* @param string|base64 $val1 String or base64-encoded data
* @param string|dateTime.iso8601 $val2 String or an ISO date
* @param array|struct $val3 Normal indexed array or an associative array
* @return boolean|struct
*/
function myFunc($val1, $val2, $val3)
{
}]]>
        </programlisting>

        <para>
            Attention toutefois, une signature multiple peut prêter à confusion au regard des personnes utilisant votre
            service. En général une fonction ne devrait posséder qu'une seule signature.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.namespaces">
        <title>Utiliser des espaces de nommages (Namespaces)</title>

        <para>
            XML-RPC accepte le concept d'espace de nom, ce qui permet de grouper les méthodes XML-RPC. Ceci aide à prévenir les 
            colisions de noms (deux fonctions avec le même nom), de différentes classes. Par exemple le serveur XML-RPC sert des 
            méthodes dans l'espace 'system' :
        </para>

        <itemizedlist>
            <listitem><para>system.listMethods</para></listitem>
            <listitem><para>system.methodHelp</para></listitem>
            <listitem><para>system.methodSignature</para></listitem>
        </itemizedlist>

        <para>
            En interne la correspondance est faite avec les méthodes du même nom, de Zend_XmlRpc_Server.
        </para>

        <para>
            Si vous voulez ajouter un espace de noms aux méthodes que vous servez, procédez alors comme suit :
        </para>

        <programlisting role="php"><![CDATA[<?php
// Toutes les méthodes publiques de My_Service_Class seront accessibles via
// myservice.METHODNAME
$server->setClass('My_Service_Class', 'myservice');

// la fonction 'somefunc' sera accessible via funcs.somefunc
$server->addFunction('somefunc', 'funcs');]]>
        </programlisting>
    </sect2>

    <sect2 id="zend.xmlrpc.server.request">
        <title>Requêtes personnalisées</title>

        <para>
            La plupart du temps, vous utiliserez l'objet de requête par défaut Zend_XmlRpc_Request_Http, sans vous
            en occuper. En revanche si vous avez un besoin spécifique, comme par exemple jourlaiser la requête, traiter une
            requête CLI, GUI, ou autre environnement, vous devrez alors créer un objet étendant Zend_XmlRpc_Request.
            Implémentez les méthodes getMethod() et getParams() afin que le serveur puisse analyser ces informations pour traiter
            la requête.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.response">
        <title>Résponses personnalisées</title>

        <para>
            Comme avec les objets de requête, Zend_XmlRpc_Server peut retourner des objets de réponse personnalisés.
            Par défaut il s'agit d'objets Zend_XmlRpc_Response_Http qui envoient un en-tête HTTP Content-Type HTTP pour
            XML-RPC. Vous pourriez utiliser des objets de réponse personnalisés pour par exemple renvoyer les réponses vers
            STDOUT, ou les journaliser.
        </para>

        <para>
            Pour utiliser une classe de réponse personnalisée, utilisez Zend_XmlRpc_Server::setResponseClass() avant d'appeler handle().
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.fault">
        <title>Gérer les exceptions pour les erreurs (Faults)</title>

        <para>
            Zend_XmlRpc_Server attrape les Exceptions générées par vos classes/fonctions, et génère une réponse
            XML-RPC 'fault' lorsqu'une exception a été rencontrée. Par défaut, les message et code des exceptions ne
            sont pas attachés dans la réponse XML-RPC. Ceci est du au fait que de telles exceptions peuvent en dire trop,
            au regard de la sécurité d evotre application.
        </para>

        <para>
            Des classes d'exception peuvent cependant être mises en liste blanche, et donc utilisées pour les réponses d'erreur ('fault').
            Utilisez simplement Zend_XmlRpc_Server_Fault::attachFaultException() en lui passant une classe d'exception :
        </para>

        <programlisting role="php"><![CDATA[<?php
Zend_XmlRpc_Server_Fault::attachFaultException('My_Project_Exception');]]>
        </programlisting>

        <para>
            Si vous héritez correctement vos exceptions, vous pouvez alors passer en liste blanche l'exception la plus bas niveau,
            et ainsi accepter plusieurs types d'exceptions qui en hériteront. Evidemment, les Zend_XmlRpc_Server_Exceptions sont elles
            automatiquement mises en liste blanches, afin de pouvori traiter les requêtes vers des méthodes inexistantes, ou toute autre
            erreur 'générique'.
        </para>

        <para>
            Toute exception rencontrée, mais non mise en liste blanche, donnera naissance à une réponse d'erreur avec le code
            '404' et le message 'Unknown error'.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.caching">
        <title>Cacher la définition du serveur entre les requêtes</title>
        <para>
            Attacher beaucoup de classes au serveur XML-RPC peut consommer beaucoup de ressources, car l'introspection
            de chaque classe/fonction est mise en place.
        </para>
        <para>
            Pour améliorer les performances, Zend_XmlRpc_Server_Cache peut être utilisé pour mettre en cache la définition d'un
            serveur. Combiné à __autoload(), ceci améliore grandement les performances.
        </para>
        <para>
            Un exemple d'utilisation :
        </para>
        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Loader.php';
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Cache.php';

function __autoload($class)
{
    Zend_Loader::loadClass($class);
}

$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';
$server = new Zend_XmlRpc_Server();

if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    require_once 'My/Services/Glue.php';
    require_once 'My/Services/Paste.php';
    require_once 'My/Services/Tape.php';

    $server->setClass('My_Services_Glue', 'glue');   // glue. namespace
    $server->setClass('My_Services_Paste', 'paste'); // paste. namespace
    $server->setClass('My_Services_Tape', 'tape');   // tape. namespace

    Zend_XmlRpc_Server_Cache::save($cacheFile, $server);
}

echo $server->handle();]]>
        </programlisting>
        <para>
            L'exemple ci dessus essaye de récupérer la définition du serveur via le fichier xmlrpc.cache. Si ceci échoue, 
            alors les classes nécéssaires au service sont chargées, attachées au serveur, et une tentative de création de cache
            est lancée.
        </para>
    </sect2>

    <sect2 id="zend.xmlrpc.server.use">
        <title>Exemples d'utilisation</title>
        <para>
            Voici quelques exemples qui démontrent les diverses options disponibles pour un serveur XML-RPC.
        </para>
        <sect3 id="zend.xmlrpc.server.use.case1">
            <title>Utilisation basique</title>

            <para>
                L'exemple ci dessous attahce une fonction au service XML-RPC.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';

/**
 * Return the MD5 sum of a value
 *
 * @param string $value Value to md5sum
 * @return string MD5 sum of value
 */
function md5Value($value)
{
    return md5($value);
}

$server = new Zend_XmlRpc_Server();
$server->addFunction('md5Value');
echo $server->handle();]]>
            </programlisting>
        </sect3>

        <sect3 id="zend.xmlrpc.server.use.case2">
            <title>Attacher une classe</title>

            <para>
                L'exemple ci dessous montre comment attacher les méthodes publiques d'une classes en tant que méthodes XML-RPC.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Services/Comb.php';

$server = new Zend_XmlRpc_Server();
$server->setClass('Services_Comb');
echo $server->handle();]]>
            </programlisting>
        </sect3>

        <sect3 id="zend.xmlrpc.server.use.case3">
            <title>Attacher plusieurs classes grâce aux espaces de nom</title>

            <para>
                L'exemple ci dessous montre comment attacher plusieurs classes grâce aux espaces de nom.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

$server = new Zend_XmlRpc_Server();
$server->setClass('Services_Comb', 'comb');   // methods called as comb.*
$server->setClass('Services_Brush', 'brush'); // methods called as brush.*
$server->setClass('Services_Pick', 'pick');   // methods called as pick.*
echo $server->handle();]]>
            </programlisting>
        </sect3>

        <sect3 id="zend.xmlrpc.server.use.case4">
            <title>Spécifier les exceptions à utiliser en cas d'erreurs dans les réponses XML-RPC</title>

            <para>
                L'exemple ci dessous montre comment spécifier les exceptions à utiliser en cas d'erreurs dans les réponses XML-RPC.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Utilise les Services_Exception pour les erreurs
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server->setClass('Services_Comb', 'comb');   // methods called as comb.*
$server->setClass('Services_Brush', 'brush'); // methods called as brush.*
$server->setClass('Services_Pick', 'pick');   // methods called as pick.*
echo $server->handle();]]>
            </programlisting>
        </sect3>

        <sect3 id="zend.xmlrpc.server.use.case5">
            <title>Utiliser un objet de requête personnalisé</title>

            <para>
                L'exemple suivant montre comment utiliser un objet de requête personnalisé.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Request.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Utilise les Services_Exception pour les erreurs
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server->setClass('Services_Comb', 'comb');   // methods called as comb.*
$server->setClass('Services_Brush', 'brush'); // methods called as brush.*
$server->setClass('Services_Pick', 'pick');   // methods called as pick.*

// Crée un objet de requête
$request = new Services_Request();

echo $server->handle($request);]]>
            </programlisting>
        </sect3>

        <sect3 id="zend.xmlrpc.server.use.case6">
            <title>Utiliser un objet de réponse personnalisé</title>

            <para>
                L'exemple suivant montre comment utiliser un objet de réponse personnalisé.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Request.php';
require_once 'Services/Response.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Utilise les Services_Exception pour les erreurs
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server->setClass('Services_Comb', 'comb');   // methods called as comb.*
$server->setClass('Services_Brush', 'brush'); // methods called as brush.*
$server->setClass('Services_Pick', 'pick');   // methods called as pick.*

// Crée un objet de requête
$request = new Services_Request();

// Utilise une réponse personnalisée
$server->setResponseClass('Services_Response');

echo $server->handle($request);]]>
            </programlisting>
        </sect3>

        <sect3 id="zend.xmlrpc.server.use.case7">
            <title>Cache entre les requêtes</title>

            <para>
                Les exemples suivants montrent comment gérer une politique de cache inter-requêtes.
            </para>

            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Zend/XmlRpc/Server/Cache.php';
require_once 'Services/Request.php';
require_once 'Services/Response.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Specifier un fichier de cache
$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';

// Utilise les Services_Exception pour les erreurs
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();

// Essaye de récupérer la définition du serveur via le cache
if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    $server->setClass('Services_Comb', 'comb');   // methods called as comb.*
    $server->setClass('Services_Brush', 'brush'); // methods called as brush.*
    $server->setClass('Services_Pick', 'pick');   // methods called as pick.*

    // Sauve le cache
    Zend_XmlRpc_Server_Cache::save($cacheFile, $server));
}

// Crée un objet de requête
$request = new Services_Request();

// Utilise une réponse personnalisée
$server->setResponseClass('Services_Response');

echo $server->handle($request);]]>
            </programlisting>
        </sect3>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
