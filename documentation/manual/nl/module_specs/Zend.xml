<sect1 id="zend.introduction">
    <title>Inleiding</title>
    <para>
	De Zend klasse is de basisklasse van de Zend Framework. Deze klasse kwam tot
	stand wegens het feit dat de framework het DRY (Don't Repeat Yourself) princiepe 
	aanhangt. Ze bevat alleen statische methodes, en deze methodes bevatten
	functionaliteit die voor vele componenten van de Zend Framework nodig zijn.
    </para>
</sect1>

<sect1 id="zend.loadfile">
    <title>Zend::loadFile()</title>

    <para>
    <code>Zend::loadFile()</code> laadt een PHP bestand dat PHP kan bevatten. 
	Het is een omwikkeling voor de PHP functie 
	<ulink url="http://php.net/include"><code>include()</code></ulink> welke een
    <code>Zend_Exception</code> opwerpt in geval van mislukking.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
loadFile($filename, $dirs=null, $once=false)

?>]]></programlisting>

    <para>Het <code>$filename</code> argument specifieert het bestand 
	dat moet worden geladen, en mag geen padinformatie bevatten. Er wordt een 
	veiligheidscheck gedaan op <code>$filename</code>. De <code>$filename</code>
	mag alleen alfanumerieke tekens, min-tekens ("-"), underscores ("_") of 
	punten (".") bevatten. Geen enkele van deze beperkingen zijn van 
	toepassing op het argument <code>$dirs</code>.
    </para>

    <para>Het argument <code>$dirs</code> specifieert paden waarin voor het 
	bestand moet worden gezocht. Indien <code>NULL</code>, wordt er alleen in
	het <code>include_path</code> gezocht. Indien het een string of een array
	is, zullen de gespecifeerde pad(en) worden doorzocht, plus het
	<code>include_path</code>.
    </para>

    <para>
	Het argument <code>$once</code> is een boolean welke aanduid of de PHP 
	functies <ulink url="http://php.net/include"><code>include()</code></ulink>
	of <ulink url="http://php.net/include_once"><code>include_once()</code></ulink> 
	moeten worden gebruikt om het bestand te laden.
    </para>
</sect1>

<sect1 id="zend.loadclass">
    <title>Zend::loadClass()</title>
    <para>
    <code>Zend::loadClass()</code> laadt een PHP bestand waarvan de bestandsnaam 
	opgebouwd is zoals "<code>$className.php</code>", en gaat dan het 
	bestaan van de klasse <code>$className</code> na.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
loadClass($class, $dirs)

?>]]></programlisting>

    <para>
	Indien het bestand niet werd gevonden of indien de klasse niet bestaat na 
	het laden word er een <code>Zend_Exception</code> opgeworpen.
	<code>Zend::loadFile()</code> wordt gebruikt voor het laden van het bestand,
	en het <code>$dirs</code> argument wordt er onmiddellijk aan doorgegeven...
    </para>

    <para>
	Indien u vraagt voor een klasse met underscores in de naam en <code>$dirs</code>
	is null (standaard waarde), zal <code>Zend::loadClass()</code> zelf de
	<code>$dirs</code> ontdekken vanaf de klassenaam door underscores naar
	padscheiders te vertalen. Bijvoorbeeld, indien <code>$class</code> de waarde
    <code>Zend_Example_Class</code> heeft, zal dit gemapt worden naar het pad
    <code>Zend/Example/Class.php</code>.
    </para>
</sect1>

<sect1 id="zend.loadinterface">
    <title>Zend::loadInterface()</title>
    <para>
    <code>Zend::loadInterface()</code> werkt net zoals <code>Zend::loadClass()</code>, 
	maar laadt een interface in plaats van een klasse.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
loadInterface($interface, $dirs)

?>]]></programlisting>

    <para>
	De methode <code>Zend::loadClass()</code> kan niet gebruikt worden voor 
	het laden van interfaces omdat de PHP functie 
	<ulink url="http://php.net/class_exists"><code>class_exists()</code></ulink>
	het bestaan van interfaces niet kan nagaan (sinds PHP 5.0.2).
	Gebruik <code>Zend::loadInterface()</code> in plaats ervan.
    </para>

    <para>
	Indien je vraagt voor een interface met underscores in de naam en <code>$dirs</code>
	is null (standaard waarde), zal <code>Zend::loadInterface()</code> zelf de
	<code>$dirs</code> ontdekken vanaf de interfacenaam door underscores naar
	padscheiders te vertalen. Bijvoorbeeld, indien <code>$interface</code> de waarde
    <code>Zend_Example_Interface</code> heeft, zal dit gemapt worden naar het pad
    <code>Zend/Example/Interface.php</code>.
    </para>
</sect1>

<sect1 id="zend.isreadable">
    <title>Zend::isReadable()</title>

    <para>Geeft de waarde <code>TRUE</code> terug indien een bastand leesbaar
	is, anders <code>FALSE</code>.</para>

    <programlisting role="php"><![CDATA[<?php
	
isReadable($filename)

?>]]></programlisting>

    <para>Het argument <code>$filename</code> specifieert de bestandsnaam die
	nagegaan dient te worden, en mag padinformatie bevatten. Deze methode is
	een omwikkeling voor de PHP functie
	<ulink url="http://php.net/is_readable"><code>is_readable()</code></ulink>.
	De PHP functie zoekt niet in <code>include_path</code>, terwijl 
	<code>Zend::isReadable()</code> dat wèl doet.
    </para>
</sect1>

<sect1 id="zend.dump">
    <title>Zend::dump()</title>

    <para>
	<code>Zend::dump()</code> drukt informatie over een uitdrukking af 
	(of geeft deze terug). Het is een omwikkeling voor de PHP functie
	<ulink url="http://php.net/var_dump"><code>var_dump()</code></ulink>. Ze
	omvat de weergave in (X)HTML <code>&lt;pre&gt;</code> afbakeningen en
	kan die optioneel prefixen met een stuk tekst.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
dump($var, $label=null, $echo=true)

?>]]></programlisting>

    <para>
	Het <code>$var</code> argument specifieert de uitdrukking of variabele
	waarvoor de informatie zal worden afgedrukt.
    </para>

    <para>
	<code>$label</code> is optioneel en kan eender welke tekst bevatten. Die zal
	dan vòòr de weergave van <code>Zend::dump()</code> worden afgedrukt.
	Dit is handig wanneer je informatie over vele variabelen op een enkele
	pagina weergeeft.
    </para>

    <para>
	De boolean <code>$echo</code> kontroleert of de weergave van
	<code>Zend::dump()</code> wordt weergegeven of niet. Indien het <code>TRUE</code>
	is, wordt deze weergegeven. Ongeacht de waarde van <code>$echo</code> zal de
	output altijd worden terugegeven.
    </para>
</sect1>


<sect1 id="zend.register">
    <title>Zend::register()</title>

    <para>
	Een objekt in de objektenlijst opslaan.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
register($name, $object)

?>]]></programlisting>

    <para>
	De registry is een mechanisme voor het verstrekken van singleton instanties 
	van objekten aan de toepassingsruimte. Het objekt wordt slechts éénmaal
	opgeslaan en kan opgevraagd worden wanneer nodig. Het is steeds dezelfde
	instantie van het objekt dat word terugegeven.
    </para>

    <para>
	<code>$name</code> is eender welke string die toelaat het objekt een naam
	te geven in de objektenlijst. Deze naam kan dan aan <code>Zend::registry()</code>
	worden doorgegeven om het objekt opnieuw te verkrijgen.
    </para>

    <para>
	Het <code>$name</code> argument moet een string zijn, alleen objekten mogen
	opgeslaan worden in de registry, een objekt kan nooit worden verwijderd
	uit de registry en een objektinstantie kan slechts éénmaal worden
	opgeslaan in de registry.
	Het niet nakomen van deze regels zal een <code>Zend_Exception</code> opwerpen.
    </para>
</sect1>

<sect1 id="zend.registry">
    <title>Zend::registry()</title>

    <para>
	Geeft een objekt van de registry terug of een lijst van alle objekten in de registry.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
registry($name=null)

?>]]></programlisting>

    <para>
	Indien het <code>$name</code> argument <code>NULL</code> is zal een array 
	terugegeven worden waarvan de keys de namen van de objekten in de registry 
	zijn en de waarden de klassenamen van de objekten.
    </para>

    <para>
	Als <code>$name</code> een string is zal de overeenkomstige objekt handle 
	worden teruggegeven. Indien er geen objekt bestaat in de registry met
	de naam <code>$name</code> zal er een  <code>Zend_Exception</code>
	worden opgeworpen.
    </para>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->