<sect1 id="zend.cache.frontends">
    <title>Zend_Cache frontends</title>
    
    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>Introductie</title>
            <para>
                <code>Zend_Cache_Core</code> is een speciale frontend omdat het de kern van de module is. Het is een generieke cache frontend en wordt uitgebreid door andere classes.
            </para>
            <note><para>
                Alle frontends erven van <code>Zend_Cache_Core</code> zodat zijn methodes en opties (zoals hieronder beschreven) ook beschikbaar zijn in andere frontends, dus ze zullen hier niet worden gedocumenteerd.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>Beschikbare opties</title>
            <para>
                Deze opties worden doorgegeven aan de factory methode zoals hierboven gedemonstreerd.
            </para>
            <table>
                <title>Beschikbare opties</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Optie</entry>
                            <entry>Data Type</entry>
                            <entry>Standaard Waarde</entry>
                            <entry>Omschrijving</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  zet de caching aan of uit (kan handig zijn om te debuggen)
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                Levensduur van de cache (in seconden), wanneer de waarde <code>null</code> is, blijft de cache altijd geldig.
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Wanneer dit op true staat, wordt logging via <code>Zend_Log</code> aangezet (maar wordt het systeem trager)
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Zet schrijfcontrole aan (de cache wordt direct na schrijven gelezen om corrupte records te herkennen), door writeControl aan te zetten zal de cache iets trager wegschrijven maar het lezen wordt niet trager (het kan sommige corrupte cache bestanden herkennen maar is geen perfecte controle) 
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Zet de automatische serialisatie aan of uit, dit kan worden gebruikt om direct informatie op te slaan dat geen string is (maar het is trager)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                Stel het automatische opschoonsysteem in (garbage collector): 0 betekent geen automatische opschoning, 1 betekent systematisch cache opschonen en x &gt; 1 betekent willekeurig opschonen 1 keer per x schrijf operaties.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.core.examples">
            <title>Voorbeelden</title>
            <para>
                Een voorbeeld wordt gegeven aan het begin van de handleiding.
            </para>
            <para>
                Wanneer je alleen strings in de cache wil opslaan (want met "automaticSerialization" is het mogelijk ook sommige booleans op te slaan), kan je een compactere constructie gebruiken:
            </para>
            <programlisting role="php"><![CDATA[<?php  
             
// we gaan er vanuit dat je $cache al hebt

$id = 'mijnGroteLoop'; // cache id van "wat we willen cachen"

if (!($data = $cache->get($id))) {
    // cache miss
    
    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 

// [...] doe iets met $data (echo het, stuur het door enz.)
             
?>]]>       </programlisting> 
            <para>
                Als je meerdere blokken of data instanties wilt cachen, is het idee hetzelfde:
            </para>
            <programlisting role="php"><![CDATA[<?php  
             
// Zorg ervoor dat je unieke identifiers hebt:
$id1 = 'foo';
$id2 = 'bar';

// blok 1
if (!($data = $cache->get($id1))) {
    // cache miss
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 
echo($data);

// Dit wordt niet door de cache beinvloed
echo('NOOIT GECACHED! ');

// blok 2
if (!($data = $cache->get($id2))) {
    // cache miss
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }
    
    $cache->save($data);
    
} 
echo($data);

?>]]>       </programlisting>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontend.output.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Output</code> is an output-capturing frontend. It utilizes
                output buffering in PHP to capture everything between its <code>start()</code> and
                <code>end()</code> methods.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.output.options">
            <title>Available options</title>
            <para>
                This frontend doesn't have any specific options other than those of
                <code>Zend_Cache_Core</code>.
            </para>
        </sect3>
        
        <sect3 id="zend.cache.frontend.output.examples">
            <title>Examples</title>
            <para>
                An example is given in the manual at the very beginning. Here it is with minor changes:
            </para>
            <programlisting role="php"><![CDATA[<?php

// if it is a cache miss, output buffering is triggered
if(!$cache->start('mypage')):

// output everything as usual
echo 'Hello world! ';
echo 'This is cached ('.time().') ';

$cache->end(); // output buffering ends
endif;

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
            <para>
                Using this form it is fairly easy to set up output caching in your already working project
                with little or no code refactoring.
            </para>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontend.function.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Function</code> caches the results of function calls. It has
                a single main method named <code>call()</code> which takes a function name and parameters
                for the call in an array.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.function.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  if true, function calls will be cached by default                
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  function names which will always be cached               
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  function names which must never be cached               
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.function.examples">
            <title>Examples</title>
            <para>
                Using the <code>call()</code> function is the same as using
                <code>call_user_func_array()</code> in PHP:
            </para>
            <programlisting role="php"><![CDATA[<?php

$cache->call('veryExpensiveFunc', $params);

# $params is an array
# for example to call (with caching) veryExpensiveFunc(1, 'foo', 'bar'), you will use
# $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar'))

?>]]>       </programlisting>
            <para>
                <code>Zend_Cache_Frontend_Function</code> is smart enough to cache both the
                return value of the function and its internal output.
            </para>
            <note><para>
                You can pass any builtin or user defined function with the exception of
                <code>array()</code>, <code>echo()</code>, <code>empty()</code>, <code>eval()</code>,
                <code>exit()</code>, <code>isset()</code>, <code>list()</code>, <code>print()</code>
                and <code>unset()</code>. 
            </para></note>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontend.class.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Class</code> is different from <code>Zend_Cache_Frontend_Function</code>
                because it allows caching of object and static method calls.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.class.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cachedEntity</code> (required)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  if set to a class name, we will cache an abstract class and will use
                                  only static calls; if set to an object, we will cache this object methods             
                              </entry>
                         </row>
                         <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  if true, calls will be cached by default                
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  method names which will always be cached               
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  method names which must never be cached               
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.class.examples">
            <title>Examples</title>
            <para>
                For example, to cache static calls :
            </para>
            <programlisting role="php"><![CDATA[<?php

class test {
   
    # Static method
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => 'test' // The name of the class
);
// [...]

# The cached call
$res = $cache->foobar('1', '2');

?>]]>       </programlisting>
            <para>
                To cache classic method calls :
            </para>
            <programlisting role="php"><![CDATA[<?php

class test {
   
    private $_string = 'hello !';
      
    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => new test() // An instance of the class
);
// [...]

# The cached call
$res = $cache->foobar2('1', '2');

?>]]>       </programlisting>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> is a frontend driven by the 
                modification time of a "master file". It's really interesting for examples
                in configuration or templates issues.
            </para>
            <para> 
            	For instance, you have an XML configuration file which is parsed by a function 
            	which returns a "config object" (like with <code>Zend_Config</code>). With
            	<code>Zend_Cache_Frontend_File</code>, you can store the "config object" into
            	cache (to avoid the parsing of the XML config file at each time) but with a
            	sort of strong dependency on the "master file". So, if the XML config file
            	is modified, the cache is immediatly invalidated.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>masterFile (mandatory)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  the complete path and name of the master file                 
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>   
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Examples</title>
            <para>
                Use of this frontend is the same than of <code>Zend_Cache_Core</code>. There
                is no need of a specific example - the only thing to do is to 
                define the <code>masterFile</code> when using the factory.
            </para>
        </sect3>
    </sect2>
    
    <sect2 id="zend.cache.frontends.page">
    	<title>Zend_Cache_Frontend_Page</title>
    	<sect3 id="zend.cache.frontends.page.introduction">
        	<title>Introduction</title>
        	<para>
	            <code>Zend_Cache_Frontend_Page</code> is like <code>Zend_Cache_Frontend_Output</code>
	            but designed for a complete page. It's impossible to use <code>Zend_Cache_Frontend_Page</code>
	            for caching only a single block.
	        </para>
	        <para>
	        	On the other hand, the "cache id" is calculated automatically with
	        	<code>$_SERVER['REQUEST_URI']</code> and (depending on options) 
	        	<code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>, <code>$_COOKIE</code>, <code>$_FILES</code>.
	        	More over, you have only one method to call (<code>start()</code>) because the
	        	<code>end()</code> call is fully automatic when the page is ended.
	        </para>
	        <para>
	        	For the moment, it's not implemented but we plan to add a HTTP conditional system
	        	to save bandwith (the system will send a HTTP 304 Not Modified if the cache is hit
	        	and if the browser has already the good version).
	        </para>
	        <note><para>
                Zend_Cache_Frontend_Page is really "alpha stuff" and is meant to be improved further down the road.
	        </para></note>
    	</sect3>
    	<sect3 id="zend.cache.frontends.page.options">
	        <title>Available options (for this frontend in Zend_Cache factory)</title>
	        <table>
	            <title>Available options</title>
	            <tgroup cols="4">
	                 <thead>
	                      <row>
	                        <entry>Option</entry>
	                        <entry>Data Type</entry>
	                        <entry>Default Value</entry>
	                        <entry>Description</entry>
	                    </row>
	                 </thead>
	                 <tbody>
	                 	   <row>
	                          <entry><code>httpConditional</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              use the httpConditional system (not implemented for the moment)                 
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>cacheWith{Get,Post,Session,Files,Cookie}Variables</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                                if true,  cache is still on even if there are some variables in the corresponding superglobal array ;
	                                if false,  cache is off if there are some variables in the corresponding superglobal array             
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>makeIdWith{Get,Post,Session,Files,Cookie}Variables</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>true</code></entry>
	                          <entry>
	                                if true, we have to use the content of the corresponding superglobal array to make a cache id
	                                if false, the cache id won't be dependent of the content of the corresponding superglobal array
	                          </entry>
	                     </row>
	                  </tbody>
	              </tgroup>
	          </table>
	    </sect3>   
    	<sect3 id="zend.cache.frontends.page.examples">
        	<title>Examples</title>
	        <para>
	            Use of Zend_Cache_Frontend_Page is really trivial :
	        </para>
            <programlisting role="php"><![CDATA[<?php
	           
// [...] // require, configuration and factory
	
$cache->start();
# if the cache is hit, the result is sent to the browser and the script stop here
	
// rest of the page ...
	
?>]]>       </programlisting>
    	</sect3>
	</sect2>
    
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->