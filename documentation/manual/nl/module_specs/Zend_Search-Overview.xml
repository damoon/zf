<sect1 id="zend.search.overview">
    <title>Overzicht</title>

    <sect2 id="zend.search.introduction">
        <title>Inleiding</title>
        <para>
			Zend Search_Lucene is een algemene tekst search engine die volledig in PHP 5 is geschreven.
			Vermist het zijn indexbestanden op het bestandssysteem schrijft en geen database server nodig
			heeft, kan het zoekmogelijkheden aanbieden aan vrijwel elke door PHP gestuurde webstek.
			Zend_Search_Lucene biedt de volgende mogelijkheden:
            
            <itemizedlist>
                <listitem>
                    <para>Geordend zoeken - betere resultaten eerst</para>
                </listitem>
                <listitem>
                    <para>
					   Veel krachtige querytypes: ##VERT. phrase queries, wildcard queries,
					   proximity queries, range queries## en meer
                        <footnote>
                           <para>
						     Alleen ##VERT. term and multi term queries are supported at this time.##
                           </para>
                        </footnote>
                    </para>
                </listitem>
                <listitem>
                    <para>Zoeken op een bepaald veld (bv: titel, auteur, inhoud)</para>
                </listitem>
            </itemizedlist>
        
			Zend_Search_Lucene werd afgeleid van het Apache Lucene projekt. Voor meer informatie over Lucene kan
			je terecht op:
            <ulink url="http://lucene.apache.org/java/docs/"/>.
        </para>
    </sect2>
    
	<sect2 id="zend.search.index-creation.documents-and-fields">
		<title>Dokument en Veld Objekten</title>
            <para>
				Zend_Search_Lucene beschouwt dokumenten als eenheden voor de indexering. Een dokument wordt dan
				opgedeeld in benoemde velden en velden hebben inhoud waarop kan gezocht worden.
            </para>
        
            <para>
				Een dokument wordt voorgesteld als een Zend_Search_Lucene_Document objekt, en dit objekt bevat
				Zend_Search_Lucene_Field objekten die de velden voorstellen.
            </para>
        
            <para>
				Belangrijk: eender welke informatie kan aan de index worden toegevoegd. 
                ##VERT. Application-specific information or metadata## kan worden opgeslaan in
				de dokumentvelden en later worden opgevraagd met het dokument ##VERT. during search.##
            </para>
        
            <para>
                ##VERT. It is the responsibility of your application to control the indexer.
                This means that data can be indexed from any source
                that is accessible by your application.  For example, this could be the
                filesystem, a database, an HTML form, etc.##
            </para>            
            
            <para>
                <code>Zend_Search_Lucene_Field</code> class provides several static methods to create fields with
                different characteristics:
            </para>
        
            <programlisting role="php"><![CDATA[<?php
$doc = new Zend_Search_Lucene_Document();

// Field is not tokenized, but is indexed and stored within the index.
// Stored fields can be retrived from the index.
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype', 
                                                 'autogenerated'));

// Field is not tokenized nor indexed, but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created', 
                                                   time()));

// Binary String valued Field that is not tokenized nor indexed,
// but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Binary('icon', 
                                                $iconData));

// Field is tokenized and indexed, and is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Text('annotation', 
                                              'Document annotation text'));

// Field is tokenized and indexed, but that is not stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', 
                                                  'My document content'));

?>]]></programlisting>
        
            <para>
                You could give names for fields by your own choice.  A "contents" field name is used to search 
                by default.  It's good idea to place main document data into this field with this name.
            </para>
	</sect2>
	
	<sect2 id="zend.search.index-creation.understanding-field-types">
		<title>Understanding Field Types</title>
        <itemizedlist>
            <listitem>
                <para>
                    <code>Keyword</code> fields are stored and indexed, meaning they can be searched as well as 
                    displayed them back in search results. They are not split up into seperate 
                    words by tokenization.  Enumerated database fields usually translate well to Keyword 
                    fields in Zend_Search_Lucene.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnIndexed</code> fields are not searchable, but they are returned with search hits.  Database 
                    timestamps, primary keys, file system paths, and other external identifiers are good 
                    candidates for UnIndexed fields.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Binary</code> fields are not tokenized or indexed, but are stored for retrieval with search hits. 
                    They can be used to store any data encoded as a binary string, such as an image icon.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Text</code> fields are stored, indexed, and tokenized. Text fields are appropriate for storing 
                    information like subjects and titles that need to be searchable as well as returned with 
                    search results.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnStored</code> fields are tokenized and indexed, but not stored in the index. Large amounts of 
                    text are best indexed using this type of field. Storing data creates a larger index on 
                    disk, so if you need to search but not redisplay the data, use an UnStored field. 
                    UnStored fields are practical when using a Zend_Search_Lucene index in 
                    combination with a relational database. You can index large data fields with UnStored 
                    fields for searching, and retrieve them from your relational database by using a seperate 
                    fields as an identifier.
    		   </para>

                <table>
                    <title>Zend_Search_Lucene_Field Types</title>
                    <tgroup cols="4">
                        <thead>
                            <row>
                                <entry>Field Type</entry>
                                <entry>Stored</entry>
                                <entry>Indexed</entry>
                                <entry>Tokenized</entry>
                                <entry>Binary</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Keyword</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>UnIndexed</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>Binary</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                                <entry>Yes</entry>
                            </row>
                            <row>
                                <entry>Text</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>UnStored</entry>
                                <entry>No</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                            </row>                        
                        </tbody>
                    </tgroup>
                </table>
    	   </listitem>
	   </itemizedlist>
	</sect2>    
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->
