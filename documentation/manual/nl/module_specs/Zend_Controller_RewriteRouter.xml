<sect1 id="zend.controller.rewriterouter.introduction">
    <title>Introductie</title>
	<para>
		Zend_Controller_RewriteRouter is een nieuwe versie van de framework router. Routing is het process waarbij een URI wordt genomen en uit elkaar wordt gehaald om te bepalen welke controller en action van deze controller de request dient te krijgen. Deze definitie van controller, action en optionele parameters wordt verpakt in een waardenobject genaamd Zend_Controller_Dispatcher_Token, welke wordt afgehandeld door de Zend_Controller_Dispatcher. Routing gebeurt eenmalig: Wanneer de request wordt ontvangen, alvorens de eerste controller wordt aangesproken.
	</para>
	<para>
		Zend_Controller_RewriteRouter is ontworpen om mod_rewrite-achtige functionaliteit te ondersteunen gebruik makend van pure php structuren. Het is losjes gebaseerd op Ruby on Rails routing en vereist geen bestaande kennis van webserver URL rewriting. Het is ontworpen om te werken met een enkele mod_rewrite regel (een van de volgende):
	</para>
	<programlisting role="php"><![CDATA[
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php]]></programlisting>
	<programlisting role="php"><![CDATA[
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1	]]></programlisting>
</sect1>

<sect1 id="zend.controller.rewriterouter.usage">
	<title>Een router gebruiken</title>

	<para>
		Om een RewriteRouter juist te kunnen gebruiken dien je het te instantieren, een aantal routes te definieren en het in de controller te injecteren. De volgende code illustreert de procedure:
	</para>

	<programlisting role="php"><![CDATA[
/* -- maak een nieuwe router -- */

$router = new Zend_Controller_RewriteRouter();
$router->addRoute('user', 'user/:username', array('controller' => 'user', 'action' => 'info'));

/* -- geef de router aan de controller door -- */

$ctrl = Zend_Controller_Front::getInstance();
$ctrl->setRouter($router);]]></programlisting>
</sect1>

<sect1 id="zend.controller.rewriterouter.basic">
	<title>Basis Routes</title>

	<para>
		Het hart van de RewriteRouter is de definitie van de routes. Routes worden aangemaakt door het aanroepen van de addRoute methode van RewriteRouter:
	</para>

	<programlisting role="php"><![CDATA[
$router->addRoute('user', 'user/:username');]]></programlisting>

	<para>
		De eerste parameter is de naam van de route. Deze is op het moment van schrijven niet nodig maar zal in de toekomst gebruikt worden in een URL view helper om het mogelijk te maken makkelijk URLs te genereren in je views. Indien je een al gedefinieerde route wilt hergebruiken, kan je deze met de getRoute methode van de RewriteRouter verkrijgen.
	</para>

	<para>
		De tweede parameter is een route dat door de URL kan worden gebruikt - bijvoorbeeld, de bovenstaande route kan worden gebruikt als: <code>http://example.com/user/martel</code>. De dubbele punt in een route markeert een URL variabele welke toegankelijk zal zijn via een Zend_Controller_Action::_getParam methode. In ons voorbeeld wordt een enkele parameter genaamd username gezet naar een waarde 'martel'.
	</para>

	<note>
		Routes worden gematched in omgekeerde volgorde, zorg dus dat de meest generieke routes als eerste worden gedefinieerd.
	</note>

	<note>
		De huidige implementatie staat het gebruik van alle karakters toe behalve de slash (/) in variabele identifiers maar het wordt sterk aangeraden om alleen php vriendelijke karakters te gebruiken. In toekomstige implementaties zal dit waarschijnlijk worden aangepast, wat bugs kan introduceren in je code.
	</note>

	<para>
		Er zijn twee speciale variabelen die in de routes kunnen worden gebruikt - 'controller' en 'action'. Deze speciale variabelen zullen worden gebruikt om een controller en/of een action te vinden binnen een URL. De 'action' variabele moet altijd worden gedefinieerd in ofwel de route of als een standaard parameter. De 'controller' variabele zal standaard de IndexController zijn wanneer hij niet gedefinieerd is.
	</para>

	<programlisting role="php"><![CDATA[
$router->addRoute('user', ':controller/:action');]]></programlisting>

	<para>
		Wanneer je je browser wijst naar 'http://example.com/news/latest' met deze route gedefinieerd zal Zend_Controller_Dispatcher de latestAction van de NewsController aanroepen.
	</para>

</sect1>

<sect1 id="zend.controller.rewriterouter.variable-defaults">
	<title>Variable defaults</title>

	<para>
		Every variable in the route can have a default. To provide it you have to add a third parameter to the addRoute
		method. This third parameter is an array with keys as variable names and values as desired defaults.
	</para>

	<programlisting role="php"><![CDATA[
$router->addRoute('archive', 'archive/:year', array('year' => 2006));]]></programlisting>
	<para>
		What may not be clearly visible is that the above route will match URLs like 'http://example.com/archive/2005' and
		'http://example.com/archive'. In the latter case the variable year will have a value of 2006.
	</para>

	<para>
		In the above example we haven't set a controller so it will always result in a noRoute action of an
		IndexController. To make it usable you have to provide a valid controller and a valid action as a default:
	</para>

	<programlisting role="php"><![CDATA[
$router->addRoute('archive', 'archive/:year', array('year' => 2006, 'controller' => 'archive', 'action' => 'show'));]]></programlisting>

</sect1>

<sect1 id="zend.controller.rewriterouter.variable-requirements">
	<title>Variable requirements</title>

	<para>
		One can add a fourth parameter where variable requirements can be set. These are defined as regular
		expressions:
	</para>

	<programlisting role="php"><![CDATA[
$router->addRoute('archive', 'archive/:year', array('year' => 2006), array('year' => '\d+'));]]></programlisting>

	<note>
		Unlike Ruby on Rails, ZF RewriteRouter will match a route and use a default when a fourth parameter variable requirement is not met. So the
		URL of 'http://example.com/archive/test' will match the above route and set the year to 2006. This functionality
		may be altered in the future as it is being discussed at the moment of writing of this documentation.
	</note>

</sect1>

<sect1 id="zend.controller.rewriterouter.rewritebase">
	<title>Base URL and subdirectories</title>

	<para>
		Unlike the original Router, RewriteRouter can be used in subdirectories - it automatically detects your base URL and
		sets it accordingly. For example: if you keep your <code>index.php</code> in a webserver subdirectory named
		<code>/projects/myapp/index.php</code> rewrite base (base URL) will be set to <code>/projects/myapp</code>. This string will then be 
		stripped from the beginning of the path before calculating any route matches. This frees one from the necessity of prepending it to
		any of your routes. The route of <code>'user/:username'</code> will match URIs like
		<code>http://localhost/projects/myapp/user/martel</code> and <code>http://example.com/user/martel</code>.
	</para>

	<note>
		Automatic rewrite base is case sensitive, so make sure your URL will match a subdirectory name in a filesystem
		(even on Windows machines). If it doesn't you will get to noRoute action.
	</note>

	<para>
		Should rewrite base be detected incorrectly you can override it with your own base path with the help of the
		setRewriteBase method of the RewriteRouter class:
	</para>

	<programlisting role="php"><![CDATA[
$router->setRewriteBase('/projects/myapp');]]></programlisting>

	<note>
		This step won't be necessary in most cases and is strongly discouraged as it introduces another configuration variable
		which would have to be altered when one moves code to another directory configuration.
	</note>

</sect1>

<sect1 id="zend.controller.rewriterouter.default-routes">
	<title>Default routes</title>

	<para>
		Zend_Controller_RewriteRouter is preconfigured with two default routes. The first handles  your root URL and is
		mapped to indexAction of IndexController: so you have to provide them as outlined in the
		<xref linkend="zend.controller.getting-started" />
		(see <xref linkend="zend.controller.overview.indexcontroller" />).
		The second default route is included to provide compatibility with the first version of the router. It will match URIs in
		the shape of <code>'controller/action'</code>.
	</para>

	<para>
		Default rules are configured as:
	</para>

	<programlisting role="php"><![CDATA[
// Default route for root URL
$this->addRoute('default', '', array('controller' => 'index', 'action' => 'index'));

// Route for Router v1 compatibility
$this->addRoute('compat', ':controller/:action', array('controller' => 'index', 'action' => 'index'));]]></programlisting>

	<note>
		Though Zend_Controller_RewriteRouter is configured for backwards compatibility it will not match
		<code>controller/action</code> URIs with additional parameters just yet.
	</note>

</sect1>
