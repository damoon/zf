<sect1 id="zend.cache.introduction">
    <title>مقدمة</title>
    <para>
        <code>Zend_Cache</code> يوفر إمكانية عمل cache للبيانات.
    </para>
      <para>
          عملية الـ caching فى إطار عمل Zend يتم إدارتها من خلال مجموعة من الـ frontends فى حين ان سجلات الـ cache يتم حفظها 
           و استرجاعها عن طريق backend adapters مثل (<code>File</code>, <code>Sqlite</code>, <code>Memcache</code>...) 
          و يستخدم ايضا IDs و tags. بهذه الطريقة يكن من السهل حذف مجموعات محددة من السجلات بعد ذلك.
          على سبيل المثال ("حذف كل سجلات الـ cache المعرفة بـ tag معين")
          
      
    </para>
    
    <para>
        Core هو (<code>Zend_Cache_Core</code>) و هو يمثل المرونة و الشمولية و قابلية تعديل الخصائص (configurable).
        حتى الأن يوجد مجموعة من الـ cache frontends تمتد عن <code>Zend_Cache_Core</code> و التى ستخدم احتياجاتك.
        و هى : <code>Output</code>, <code>File</code>, <code>Function</code> و <code>Class</code>.
        
      
    </para>
    <example>
        <title>إنشاء frontend بواسطة <code>()Zend_Cache::factory</code></title>

        <para>
            <code>()Zend_Cache::factory</code> ينشئ الـ objects المتوافقة معا و التى 
            ستحتاجها لإتمام عملك. فى هذا المثال, سنستخدم frontend و هو <code>Core</code> 
            و سنستخدم ايضا backend  وهو <code>File</code>.
        
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200, // cache lifetime of 2 hours 
   'automaticSerialization' => true
);

$backendOptions = array(
    'cacheDir' => './tmp/' // Directory where to put the cache files
);

// getting a Zend_Cache_Core object
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?>]]></programlisting>
       </para>
       <para>
            
            الأن لدينا frontend و أيضا يمكننا عمل cache لأى نوع من البيانات (لأننا قمنا بتشغيل الـ serialization ) .
 على سبيل المثال , يمكننا عمل cache لبيانات ناتجة عن تنفيذ استعلام كبير على قاعدة بيانات .
 بعد عمل cache لهذه البيانات, لن نحتاج الى ان نتصل حتى بقاعدة البيانات فى المرات القادمة; كل ما علينا 
هو جلب هذه البيانات من الـ cache و استخدامها (سيتم عمل unserialization للبيانات ضمنيا ).
            <programlisting role="php"><![CDATA[<?php

// $cache initialized in previous example

// see if a cache already exists:
if(!$result = $cache->get('myresult')) {

    // cache miss; connect to the database
    
    $db = Zend_Db::factory( [...] );
    
    $result = $db->fetchAll('SELECT * FROM huge_table');
    
    $cache->save($result, 'myresult');
    
} else {

    // cache hit! shout so that we know
    echo "This one is from cache!\n\n";
    
}

print_r($result);

?>]]></programlisting>
       </para>
    </example>
    <example>
        <title>عمل cache للخرج بإستخدام الـ Output frontend الخاصة بـ <code>Zend_Cache</code></title>
        <para>
           سنقوم بتحديد الأماكن التى نريد عمل cache لخرجها و ذلك بإستخدامنا لبعض الأكواد الشرطية, 
سنضع بلوك الكود المحدد ما بين الـ method المسمى <code>()start</code> و الأخر المسمى <code>()end</code> .
( هذا يعيد هيكلة المثال الأول و هذه هى الفكرة الأساسية للـ caching ).
        </para><para>
           بالداخل ستقوم بإخراج البيانات كالمعتاد, كل الخرج سيكن قد تم عمل cache له عندما يتم الوصول الى <code>()end</code> .
عند تشغيل هذا الكود مرة اخرى, لن يتم تنفيذ الكود المحدد فى هذا المكان لكن سيتم جلب البيانات من الـ cache 
- و هذا طالما ان البيانات فى الـ cache مازالت قابلة للإستخدام .
            <programlisting role="php"><![CDATA[<?php

$frontendOptions = array(
   'lifeTime' => 30,                  // cache lifetime of half a minute
   'automaticSerialization' => false  // this is default anyway
);

$backendOptions = array('cacheDir' => './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// we pass a unique identifier to the start() method
if(!$cache->start('mypage')) {
    // output as usual:
    
    echo 'Hello world! ';
    echo 'This is cached ('.time().') ';
    
    $cache->end(); // the output is saved and sent to the browser
}

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
       </para>
       <para>
           لاحظ اننا نقوم بإخراج ناتج الدالة <code>()time</code> مرتين; و هذا نستخدمه هنا فقط للتوضيح.
جرب ان تشغل هذا مرة ثم قم بإعادة تشغيله عدة مرات متتالية, ستلاحظ ان الرقم الأول لا يتغير و 
لكن الرقم الثانى يتغير مع مرور الوقت, هذا لأن الرقم الأول تم اخراجه فى منطقة الـ cache المحددة فى الكود 
و بالتالى تم حفظه فى الـ cache على عكس بقية البيانات المخرجة.
بعد نصف دقيقة سيصبح الرقمين متساويين لأن فترة صلاحية البيانات فى الـ cache قد انتهت 
( لقد قمنا بوضع قيمة lifeTime الى 30 ثانية ). و بهذا سيتم تحديث قيمة البيانات المخزنة فى الـ cache 
من جديد. - جرب هذا بنفسك فى متصفحك لتفهم ما يحدث.
       </para>
    </example>
    <note><para>
        عند إستخدام Zend_Cache, ركز على إعطاء معرف مميز للـ cache (الذى تمرره الى
 <code>()start</code> و <code>()save</code> ) و يجب الا يتكرر فى عمليات cache اخرى. 
الوقوع فى هذا الخطأ سيسبب تداخل بين البيانات و اسوأ ما سيحدث هو أن هذه البيانات ستظهر فى اماكن ظهور بيانات أخرى.
    </para></note>
</sect1>


<sect1 id="zend.cache.theory">
    <title>مفهوم الـ caching </title>
    <para>
        هناك ثلاث مفاهيم رئيسية فى Zend_Cache. الأول هو المعرف المميز و هو عيارة عن string 
و الذى يستخدم لتعريف البيانات المسجلة فى الـ cache. 
الثانى هو التعليمة <code>'lifeTime'</code> كما رأيتها فى المثال السابق, هى تعرف الفترة الزمنية التى 
يتم اعتبار البيانات المحفوظة فى الـ cache و بهذا المعرف قابلة للإستخدام "طازجة" . 
المفهوم الثالث هو التنفيذ الشرطى للأكواد, حيث يتم اهمال جزء من الكود و لا يتم تنفيذه و هذا يزيد من كفائة الأداء (performance) .
الدالة الأساسية (<code>()Zend_Cache_Core::get</code>) تم تصميمها لتعيد false 
 عندما لا تجد البيانات المطلوبة فى الـ cache قابلة للإستخدام . 
هذا يسمح للمستخدم النهائى (انت المبرمج) من تحديد جزء من الكود الذى يريد عمل cache له داخل جملة 
<code>{ ... }()if</code> حيث ان الشرط هو هذه الدالة من Zend_Cache .
فى نهاية هذه البلوكات يجب ان تقوم بحفظ الناتج , بإستخدام 
(<code>()Zend_Cache_Core::save</code>).
    </para>
    <note><para>
        عملية التنفيذ الشرطى للأكواد لا تكن مهمة فى بعض الحالات ( مثل إستخدام الـ frontend المسمى 
<code>Function</code> ) حيث سيكون الجزء المنطقى من الكود معرف داخل الـ frontend نفسه.
    </para></note>
    <note><para>
        المصطلح 'Cache hit' و الذى رأيته فى المثال نستخدمه للتعبير عن انه تم إيجاد بيانت فى الـ cache تنتمى 
لهذا المعرف و هذه البيانات قابلة للإستخدام و "طازجة" (بمعنى اخر لم تنتهى فترة صلاحيتها). 
المصطلح 'cache miss' هو عكس ما سبق, فعندما يحدث cache miss يجب ان تقوم بإنتاج بياناتك من 
جديد (كما يحدث فى الأوضاع الطبيعية) ثم تقم بعمل cache لها . 
و عندما يحدث cache hit تقم الـ backend تلقائياً بجلب البيانات من الـ cache .

    </para></note>
    <sect2 id="zend.cache.factory">
        <title>الـ factory method فى <code>Zend_Cache</code></title>
        <para>
            طريقة جيدة لإنشاء frontend instance قابل لإستخدام من <code>Zend_Cache</code> نستعرضها فى 
المثال التالى : 
            <programlisting role="php"><![CDATA[<?php
        
# We "load" the Zend_Cache factory 
require 'Zend/Cache.php'; 

# We choose a backend (for example 'File' or 'Sqlite'...)
$backendName = '[...]';

# We choose a frontend (for example 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# We set an array of options for the choosen frontend
$frontendOptions = array([...]);

# We set an array of options for the choosen backend
$backendOptions = array([...]);

# We make the good instance 
# (of course, the two last arguments are optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

?>]]></programlisting> 
        </para> 
        <para>
            فى الأمثلة التالية سنعتبر ان المتغير <code>cache$</code> يحتوى frontend instance صالح للإستخدام 
كما هو موضح فى المثال السابق, و انك تفهم كيفية تمرير parameters للـ backends التى تود إستخدامها.
        </para>
        <note><para>
            دائما إستخدم <code>()Zend_Cache::factory</code> لتنشئ frontend instance . 
إنشاء  الـ frontend instance و الـ backends instance بنفسك مباشرة لن يعمل كما تتوقع.
        </para></note>
    </sect2>
    
    <sect2 id="zend.cache.tags">
        <title>إستخدام الـ tags</title>
        <para>
            الـ tags طرق لتقسيم البيانات فى الـ cache الى اقسام معرفة, عندما تقم بحفظ cache بإستخدام 
<code>()save</code> يمكنك ان تقم بتمرير array تحتوى على الـ tags التى تتوافق مع هذا الـ 
record (او البيانت المخزنة فى الـ cache ) . 
بالتالى ستستطيع حذف كل الـ cache records المنسوبة الى tag او مجموعة tags محددة.
        </para>
        <programlisting role="php"><![CDATA[<?php
             
$cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));
            
?>]]></programlisting>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>تنظيف الـ cache</title>
        <para>
            لحذف او تحديد معرف cache على انه غير قابل للإستخدام, يمكنك استخدام <code>()remove</code> 
 كما فى المثال التالى :
        </para>
        <programlisting role="php"><![CDATA[<?php 
             
$cache->remove('idToRemove');
            
?>]]></programlisting>            
        <para>
            لحذف او تحديد اكثر من معرف cache على انهم غير قابلين للإستخدام, يمكنك استخدام 
<code>()clean</code> , على سبيل المثال يمكنك حذف كل الـ cache records .
        </para>
        <programlisting role="php"><![CDATA[<?php 

// clean all records
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// clean only outdated
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
            
?>]]>   </programlisting>    
        <para>
            إن اردت حذف الـ cache records التى تنتمى الى tags محددة, مثلا 'tagA' و 'tagC' 
يمكنك استخدام :
        </para>
        <programlisting role="php"><![CDATA[<?php 
             
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tagA', 'tagC'));
            
?>]]>   </programlisting>
        <para>
            الـ cleaning modes المتوفرة هى : 
<code>CLEANING_MODE_ALL</code> تقوم بحذف كل الـ cache records الموجودة
 
,  <code>CLEANING_MODE_OLD</code> تقوم بحذف الـ records القديمة او الغير 
 صالحة للإستخدام  
,
 <code>CLEANING_MODE_MATCHING_TAG</code> تقوم بحذف كل الـ records التى تنتمى الى مجموعة tags محددة 
,<code>CLEANING_MODE_NOT_MATCHING_TAG</code> تقوم بحذف كل الـ records 
التى لا تنتمى الى مجموعة الـ tags الممررة. 

        </para>
    </sect2>
</sect1>

<sect1 id="zend.cache.frontends">
    <title>الـ frontends المتوفرة فى Zend_Cache</title>
    
    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>مقدمة</title>
            <para>
                <code>Zend_Cache_Core</code> هو frontend مميز لأنه جوهر الـ module . 
هو عبارة cache frontend عام و هناك classes أخرى ممتدة منه.
            </para>
            <note><para>
                كل الـ frontends ترث من <code>Zend_Cache_Core</code> و بهذا كل الـ methods 
و الـ options الخاصة به (سيتم توضيحها لاحقاً) متوفرة فى الـ frontends الأخرى , لذلك لن نقوم بشرحها هناك.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>الـ options المتوفرة</title>
            <para>
                هذه الـ options يتم تمريرها الى الـ factory method كما كان موضحاً فى امثلة سابقة.
            </para>
            <table>
                <title>الـ options المتوفرة لـ Zend_Cache_Core</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>الـ Option</entry>
                            <entry>الـ Data Type</entry>
                            <entry>الـ Default Value</entry>
                            <entry>الوصف</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  تقوم بإقاف او تشغيل عملية الـ caching ( من الممكن ان تكن مفيدة عند عمل debuging للكود الواقع فى 
نطاق عمل عملية الـ caching ).              
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                فترة صلاحية الـ cache record (بالثوانى), إن كانت قيمتها تساوى null فسيكون الـ cache record 
صالح للإستخدام دائما.      
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                إن كانت قيمتها تساوى TRUE, سيتم تنشيط عملية الـ loging من خلال <code>Zend_Log</code> . 
(لكن سيبطئ من عمل النظام نسبياً)       
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                               تقوم بايقاف او تشغيل الـ write control (أى سيتم قرائة الـ cache بعد حفظه للتأكد من 
عدم وجود اخطاء به). 
تشغيل الـ write control سيتسبب فى ابطاء عملية كتابة "حفظ" الـ cache قليلا, لكنه 
لن يؤثر فى علية القرائة. 
(يمكن ان بساعد فى اكتشاف ملفات الـ cache المعطوبة "الفاسدة" و لكنه برغم ذالك لا يعتبر 
control ممتاز )       
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                تقوم بتشغيل او ايقاف عملية الـ serialization التلقائية , يمكن ان يتم استخدامها عند الحاجة لحفظ 
بيانات مباشرة , حيث ان هذه البيانات ليست من النوع string.
 (لكنها ابطء)           
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                تقوم بتشغيل او ايقاف عملية التنظيف (garbage collector): 
القيمة 0 تعنى إيقاف عملية التنظيف التلقائى للـ cache , 
القيمة 1 تعنى تشغيل عملية التنظيف بشكل منتظم, 
و عندما تكن القيمة هى x &gt; 1 سيتم تنفيذ عملية تنظيف تلقائى عشوائية لكل عدد x من 
عمليات الكتابة.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.core.examples">
            <title>امثلة</title>
            <para>
                تم اعطاء مثال فى بداية هذا الفصل.
            </para>
            <para>
                إن كنت تقم بحفظ بيانات من النوع string فقط فى الـ cache (من الممكن حفظ 
بيانات من النوع bool ايضا بتشغيل الـ option المسمى "automaticSerialization" ) , 
يمكنك ان تستخدم بنية كود ادق مثل هذه :
            </para>
            <programlisting role="php"><![CDATA[<?php  
             
// we assume you already have $cache

$id = 'myBigLoop'; // cache id of "what we want to cache"

if (!($data = $cache->get($id))) {
    // cache miss
    
    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 

// [...] do something with $data (echo it, pass it on etc.)
             
?>]]>       </programlisting> 
            <para>
                إن كنت تريد حفظ اكثر من بلوك او مجموعة بيانات مختلفة, فهى نفس الفكرة :
            </para>
            <programlisting role="php"><![CDATA[<?php  
             
// make sure you use unique identifiers:
$id1 = 'foo';
$id2 = 'bar';

// block 1
if (!($data = $cache->get($id1))) {
    // cache missed
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 
echo($data);

// this isn't affected by caching
echo('NEVER CACHED! ');

// block 2
if (!($data = $cache->get($id2))) {
    // cache missed
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }
    
    $cache->save($data);
    
} 
echo($data);

?>]]>       </programlisting>                        
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontend.output.introduction">
            <title>مقدمة</title>
            <para>
                <code>Zend_Cache_Frontend_Output</code> هو frontend يستخدم فى التقاط البيانات 
المخرجة. يستخدم خاصية الـ output buffering التى تقدمها لغة PHP ليلتقط كل شئ يتم اخراجه بين 
الـ methods المسمى <code>()start</code> و <code>()end</code>.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.output.options">
            <title>الـ options المتوفرة</title>
            <para>
                هذا الـ frontend لا يحتوى اى options جديدة بخلاف الموجودة فى 
<code>Zend_Cache_Core</code>.
            </para>
        </sect3>
        
        <sect3 id="zend.cache.frontend.output.examples">
            <title>امثلة</title>
            <para>
                تم اعطاء مثال فى بداية هذا الفصل, ها هو مع بعض التعديلات الصغيرة:
            </para>
            <programlisting role="php"><![CDATA[<?php

// if it is a cache miss, output buffering is triggered
if(!$cache->start('mypage')):

// output everything as usual
echo 'Hello world! ';
echo 'This is cached ('.time().') ';

$cache->end(); // output buffering ends
endif;

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
            <para>
                بإستخدام هذه الطريقة يمكنك بسهولة إدخال خاصية الـ caching لمخرجات الأكواد فى مشروعك بإستخدام القليل او 
ربما عدم الأحتياج لعمل refactoring.
            </para>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontend.function.introduction">
            <title>مقدمة</title>
            <para>
                تقوم <code>Zend_Cache_Frontend_Function</code> بعمل cache 
لناتج استدعاء دالة ما, و لديها method واحد رئيسى يسمى <code>()call</code> و الذى 
يأخذ اسم الدالة المراد استدعائها و array تحتوتى الـ parameters التى سيتم تمريرها لهذه الدالة.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.function.options">
            <title>الـ options المتوفرة</title>
            <table>
                <title>الـ options المتوفرة لـ Zend_Cache_Frontend_Function</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>الـ Option</entry>
                            <entry>الـ Data Type</entry>
                            <entry>الـ Default Value</entry>
                            <entry>الوصف</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  إن كانت قيمتها true , سيتم تنفيذ عملية الـ cache لكل عملية استدعاء دالة (by default).              
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  اسماء الـ functions التى سيتم عمل cache لها دائما.              
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  اسماء الـ functions التى لا يجب عمل cache لها ابدا.           
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.function.examples">
            <title>امثلة</title>
            <para>
                استخدام الـ method المسمى <code>()call</code> هو نفس طريقة استخدام 
دالة لغة PHP المسمى <code>()call_user_func_array</code> :
            </para>
            <programlisting role="php"><![CDATA[<?php

$cache->call('veryExpensiveFunc', $params);

# $params is an array
# for example to call (with caching) veryExpensiveFunc(1, 'foo', 'bar'), you will use
# $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar'))

?>]]>       </programlisting>
            <para>
                <code>Zend_Cache_Frontend_Function</code> ذكية كفاية لتقوم بعمل 
cache لكل من ناتج الدالة العائد من "return" و البيانات المخرجة داخل الدالة (مثل عمل طباعة 
لبعض البيانات من داخل الدالة).
            </para>
            <note><para>
                يمكنك تمرير اى دالة سواء كانت من دوال اللغة او دالة انت انشئتها بإستثناء الدوال التالية : 
<code>array</code>,
 <code>echo</code>, 
<code>empty</code>,
 <code>eval</code>,
   
  <code>exit</code>,
 <code>isset</code>, 
<code>list</code>
, <code>print</code>
   
  <code>unset</code>.
            </para></note>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontend.class.introduction">
            <title>مقدمة</title>
            <para>
                يختلف <code>Zend_Cache_Frontend_Class</code> عن 
<code>Zend_Cache_Frontend_Function</code> حيث انه 
يقوم بعمل cache لعمليات استدعاء الـ objects و الـ static methods.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.class.options">
            <title>الـ options المتوفر</title>
            <table>
                <title>الـ options المتوفرة لـ Zend_Cache_Frontend_Class</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>الـ Option</entry>
                            <entry>الـ Data Type</entry>
                            <entry>الـ Default Value</entry>
                            <entry>الوصف</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cachedEntity</code> (مطلوب)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  إن كانت قيمتها عبارة عن اسم class, سيتم عمل cache للـ class على انه abstract 
و سيتم استخدام طلبات الـ static mithods الخاصة به. 
إذا كانت قيمتها عبارة عن object, سيتم عمل cache لكل الـ methods الخاصة 
بهذا الـ object.        
                              </entry>
                         </row>
                         <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  إن كانت تحمل القيمة true, كل الطلبات "calls" سيتم عمل cache لها تلقائيا.                
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                 اسماء الـ methods التى يستم عمل cache لها دائما.             
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  اسماء الـ methods التى لا يجب عمل cache لها ابدا.              
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.class.examples">
            <title>امثلة</title>
            <para>
                مثال على عمل cache لأستدعائات الـ static methods:
            </para>
            <programlisting role="php"><![CDATA[<?php

class test {
   
    # Static method
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => 'test' // The name of the class
);
// [...]

# The cached call
$res = $cache->foobar('1', '2');

?>]]>       </programlisting>
            <para>
                لعمل cache للـ methods العادية:
            </para>
            <programlisting role="php"><![CDATA[<?php

class test {
   
    private $_string = 'hello !';
      
    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => new test() // An instance of the class
);
// [...]

# The cached call
$res = $cache->foobar2('1', '2');

?>]]>       </programlisting>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>مقدمة</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> هو frontend يعتمد 
على اخر وقت تعديل ملف معين "master file". 
يتم استخدامه على سبيل المثال مع ملفات الـ configuration او الملفات التى تخص 
الـ templating.
            </para>
            <para> 
            	على سبيل المثال: انت لديك ملف XML يحتوى على الـ configurations الخاصة ببرنامجك, 
هذا الملف يتم قرائة محتوياته بإستخدام دالة معينة و التى تعيد "return" إلينا "config object" 
(مثل <code>Zend_Config</code> ). 
عن طريق <code>Zend_Cache_Frontend_File</code> يمكنك 
حفظ الـ "config object" فى الـ cache (لتتجنب عملية قرائة ملف الـ XML عند كل مرة) 
لكن بالأعتماد بشدة على الـ "master file" اى ملف الـ XML.
إذاً, إن تم تعديل ملف الـ XML سيتم اعتبار النسخة فى الـ cache غير صالحة للإستخدام و سيتم إنشاء 
اخرى جديدة.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>الـ options المتوفرة</title>
            <table>
                <title>الـ options المتوفرة لـ Zend_Cache_Frontend_File</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>الـ Option</entry>
                            <entry>الـ Data Type</entry>
                            <entry>الـ Default Value</entry>
                            <entry>الوصف</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>masterFile (إجبارى)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  المسار الكامل للملف "master file".               
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>   
        <sect3 id="zend.cache.frontends.file.examples">
            <title>امثلة</title>
            <para>
                إستخدام هذا الـ frontend هو نفس طريقة استخدام <code>Zend_Cache_Core</code>, 
لذلك لا يوجد حاجة إلى مثال جديد, الشئ الوحيد الذى ستقوم به هو تعريف قيمة 
<code>masterFile</code> عند إستخدام الـ factory.
            </para>
        </sect3>
    </sect2>
    
    <sect2 id="zend.cache.frontends.page">
    	<title>Zend_Cache_Frontend_Page</title>
    	<sect3 id="zend.cache.frontends.page.introduction">
        	<title>مقدمة</title>
        	<para>
	            <code>Zend_Cache_Frontend_Page</code> يتشابه مع 
<code>Zend_Cache_Frontend_Output</code> إلا انه تم تصميمه 
لعمل cache لصفحة كاملة. 
فلا يمكن إستخدام <code>Zend_Cache_Frontend_Page</code> 
لعمل cache لجزء او بلوك معين فقط.
	        </para>
	        <para>
	        	على الجانب الأخر, الـ "cache id" يتم حسابه من خلال 
<code>['SERVER['REQUEST_URI_$</code> و (اعتمادا على قيم الـ options يستخدم التالى) 
<code>GET</code>, <code>POST</code>, 
<code>SESSION</code>, <code>COOKIE</code>, 
<code>FILES</code>.
غير ذلك, يجب عليك استدعاء method واحد فقط و هو (<code>()start</code>) لأن 
<code>()end</code> يتم إستدعائه تلقائيا عند إنتهاء الصفحة.
	        </para>
	        <para>
	        	الى هذه اللحظة لم يتم تنفيذه لكننا ننوى إضافة نظام HTTP شرطى لحفظ المذيد من الـ bandwith 
(سيقوم النظام بإرسال الهيدر "HTTP 304" أى لم يتم تعديل الملف و هذا إذا تم إيجاد نسخة cache 
قابلة للأستخدام "طازجة" و إذا كان لدى المتصفح ايضا نسخة صالحة "طازجة" من هذه الصفحة.
	        </para>
	        <note><para>
              Zend_Cache_Frontend_Page يعتبر فى المرحلة alpha الأن , إى انه سيتم عمل
 تطويرات جديدة له مع مرور الوقت.
	        </para></note>
    	</sect3>
    	<sect3 id="zend.cache.frontends.page.options">
	        <title>الـ options المتوفرة</title>
	        <table>
	            <title>الـ options المتوفرة لـ Zend_Cache_Frontend_Page</title>
	            <tgroup cols="4">
	                 <thead>
	                      <row>
	                        <entry>الـ Option</entry>
	                        <entry>الـ Data Type</entry>
	                        <entry>الـ Default Value</entry>
	                        <entry>الوصف</entry>
	                    </row>
	                 </thead>
	                 <tbody>
	                 	 <row>
	                          <entry><code>httpConditional</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              إستخدم نظام الـ HTTP الشرطى "httpConditional system" (لم يتم دعمه الى الأن).                 
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>debugHeader</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              إن كانت تحمل القيمة true, بيانات الـ debugging سيتم إضافتها قبل كل صفحة لها cache.              
	                          </entry>
	                     </row>
	                     <row>
	                     	  <entry><code>defaultOptions</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>(.انظر الوصف.)array</code></entry>
	                          <entry>
	                              associative array تحتوى على الـ default options :
	                              <itemizedlist>
	                                  <listitem><code>(boolean, true by default) cache</code> : إن كانت تحمل قيمة true فالـ cache مفعل</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithGetVariables</code> : إن كانت تحمل القيمة true فالـ cache مفعل حتى لو كان هناك قيم فى المصفوفة <code>GET_$</code></listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithPostVariables</code> : إن كانت تحمل القيمة true فالـ cache مفعل حتى لو كان هناك قيم فى المصفوفة <code>POST_$</code></listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithSessionVariables</code> : إن كانت تحمل القيمة true فالـ cache مفعل حتى لو كان هناك قيم فى المصفوفة <code>SESSION_$</code></listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithFilesVariables</code> : إن كانت تحمل القيمة true فالـ cache مفعل حتى لو كان هناك قيم فى المصفوفة <code>FILES_$</code></listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithCookieVariables</code> : إن كانت تحمل القيمة true فالـ cache مفعل حتى لو كان هناك قيم فى المصفوفة <code>COOKIE_$</code></listitem>
									  <listitem><code>(boolean, true by default) makeIdWithGetVariables</code> : إن كانت تحمل القيمة true فقيمة الـ "cache id" تعتمد على محتويات المصفوفة  <code>GET_$</code></listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithPostVariables</code> : إن كانت تحمل القيمة true فقيمة الـ "cache id" تعتمد على محتويات المصفوفة  <code>POST_$</code></listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithSessionVariables</code> : إن كانت تحمل القيمة true فقيمة الـ "cache id" تعتمد على محتويات المصفوفة  <code>SESSION_$</code></listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithFilesVariables</code> : إن كانت تحمل القيمة true فقيمة الـ "cache id" تعتمد على محتويات المصفوفة  <code>FILES_$</code></listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithCookieVariables</code> : إن كانت تحمل القيمة true فقيمة الـ "cache id" تعتمد على محتويات المصفوفة  <code>COOKIE_$</code></listitem>	                              
	                              </itemizedlist>              
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>regexps</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array()</code></entry>
	                          <entry>
	                          	  associative array تضع بها الـ options الخاصة بـ REQUEST_URI.
المفتاح "key" سيكون عبارة عن جملة regex من النوع (PCRE), و القيم "values" 
ستكون عبارة عن associative array تحتوى مجموعة من الـ options التى سيتم 
تنفيذها إذا توافقت جملة الـ regex مع ['SERVER['REQUEST_URI_$ 
(انظر الى defaultOptions لقائمة بالـ options المتوفرة). 
إذا توافقت اكثر من جملة regexp مع قيمة ['SERVER['REQUEST_URI_$ , سيتم 
إستخدام اخر واحد فقط.      
	                          </entry>
	                     </row>
	                  </tbody>
	              </tgroup>
	          </table>
	    </sect3>   
    	<sect3 id="zend.cache.frontends.page.examples">
        	<title>امثلة</title>
	        <para>
	            إستخدام Zend_Cache_Frontend_Page سهل جدا :
	        </para>
            <programlisting role="php"><![CDATA[<?php
	           
// [...] // require, configuration and factory
	
$cache->start();
// if the cache is hit, the result is sent to the browser and the script stop here
	
// rest of the page ...
	
?>]]>       </programlisting>
	        <para>
	        	مثال اكثر تعقيدا يوضح اسلوب لتنفيذ إدارة مركزية للـ cache داخل ملف bootstrap 
"ملف رئيسى لتشغيل البرنامج".
(مثلا للإستخدام مع Zend_Controller)
            </para>
            <programlisting role="php"><![CDATA[<?php

// [...] you should avoid to put too much lines before the cache section 
// [...] for example, for optimal performances, "require_once" or "Zend::loadClass" should be 
// [...] after the cache section        	

require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200,
   'debugHeader' => true, // for debuging 
   'regexps' => array(
       '^/$' => array('cache' => true),         // cache the whole IndexController         
       '^/index/' => array('cache' => true),    // cache the whole IndexController
       '^/article/' => array('cache' => false), // we don't cache the ArticleController...
       '^/article/view/' => array(              // ...but we cache the "view" action of 
           'cache' => true,                     // this ArticleController
           'cacheWithPostVariables' => true,    // and we cache even there are some variables in $_POST
           'makeIdWithPostVariables' => true,   // (but the cache will be dependent of the $_POST array)
       )
   )	  
);
$backendOptions = array(
    'cacheDir' => '/tmp/' 
);

// getting a Zend_Cache_Frontend_Page object
$cache = Zend_Cache::factory('Page', 'File', $frontendOptions, $backendOptions);

$cache->start();
// if the cache is hit, the result is sent to the browser and the script stop here

// [...] the end of the bootstrap file (these lines won't be executed if the cache is hit)
	        	
?>]]>       </programlisting>
    	</sect3>
	</sect2>   
</sect1>

<sect1 id="zend.cache.backends">
    <title>Zend_Cache backends</title>
    
    <sect2 id="zend.cache.backends.file">
        <title>Zend_Cache_Backend_File</title>
        <para>
            هذا الـ backend يقوم بحفظ الـ cache records فى ملفات (داخل مجلد يتم تحديده). 
        </para>
        <para>
           الـ options المتوفرة
        </para>          
        <table>
            <title>الـ options المتوفرة لـ Zend_Cache_Backend_File</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>الـ Option</entry>
                        <entry>الـ Data Type</entry>
                        <entry>الـ Default Value</entry>
                        <entry>الوصف</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDir</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'/tmp/'</code></entry>
                          <entry>
                              المجلد حيث سيتم حفظ ملفات الـ cache  
                          </entry>
                      </row>
                      <row>
                          <entry><code>fileLocking</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                           تفعيل او إيقاف خاصية الـ fileLocking : تساعد فى تجنب تلف ملفات الـ cache 
و لكن لا تساعد عند العمل على multithread webservers او نظام ملفات NFS...
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControl</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            تقوم بتفعيل او ايقاف الـ read control : 
إن تم تشغيله, سيتم اضافة control key فى ملف الـ cache و هذا الـ key "مفتاح" 
سيتم مقارنته مع الأخر الذى سيتم حسابه بعد قرائة الملف.       
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControlType</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'crc32'</code></entry>
                          <entry>
                            نوع الـ read control (متوفر فقط إذا كانت read control مفعلة). 
القيم المتوفرة هى : 
"md5" الأفضل لكن الأبطء, "crc32" (اقل امانا لكن اسرع, الأختيار الأفضل), 
"strlen" لعمل اختبار طول فقط (الأسرع).
                        </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryLevel</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0</code></entry>
                          <entry>
                            Hashed directory structure level :     0 تعنى "no hashed directory 
                             structure", 1 تعنى "one level of directory", 2 تعنى "two levels"... 
                             هذا الـ option يمكن ان يرفع من سرعة اداء عملية الـ cache و ذلك فقط إن كنت تعمل مع 
الاف من ملفات الـ cache. ربما بعض القياسات ستساعدك فى تحديد افضل قيمة مناسبة لك. 
ربما 1 او 2 تعتبر بداية جيدة.
                          </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryUmask</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0700</code></entry>
                          <entry>
                              Umask للـ hashed directory structure
                        </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
        <title>Zend_Cache_Backend_Sqlite</title>
        <para>
            هذه الـ backend تقوم بحفظ الـ cache records فى قاعدة بيانات SQLite.
        </para>
        <para>
            الـ options المتوفرة:
        </para>
        <table>
            <title>الـ options المتوفرة لـ Zend_Cache_Backend_Sqlite</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                           <entry>الـ Option</entry>
                        <entry>الـ Data Type</entry>
                        <entry>الـ Default Value</entry>
                        <entry>الوصف</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDBCompletePath (mandatory)</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>null</code></entry>
                          <entry>
                              المسار الكامل (مع اسم الملف) التى توجد به قاعدة بيانات SQLite.
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.memcached">
        <title>Zend_Cache_Backend_Memcached</title>
        <para>
           هذه الـ backend تقوم بحفظ الـ cache records فى memcached server. 
<ulink url="http://www.danga.com/memcached/">memcached</ulink> 
عبارة عن نظام caching للبيانات فى الذاكرة و يتميز بكفائته العالية. 
لتستخدم هذا الـ backend انت تحتاج memcached daemon و 
<ulink url="http://pecl.php.net/package/memcache">الـ memcache PECL extension</ulink>.
        </para>
        <para>
        	احترس: مع هذا الـ backend الـ tags غير مدعومة الى الأن . 
(لأن "doNotTestCacheValidity=true")
        </para>
        <para>
             الـ options المتوفرة :
        </para>
        <table>
            <title> الـ options المتوفرة لـ Zend_Cache_Backend_Memcached</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>الـ Option</entry>
                        <entry>الـ Data Type</entry>
                        <entry>الـ Default Value</entry>
                        <entry>الوصف</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>servers</code></entry>
                          <entry><code>array</code></entry>
                          <entry><code>array(array('host' => 'localhost','port' => 11211, 'persistent' => true))</code></entry>
                          <entry>
                              An array of memcached servers ; each memcached server is described by an associative array :
                              'host' => (string) : اسم الـ memcached server, 
                              'port' => (int) : الـ port الخاص بالـ memcached server, 
                              'persistent' => (bool) : استخدام او عدم استخدام الـ persistant connections مع هذا الـ server.
                          </entry>
                      </row>
                      <row>
                          <entry><code>compression</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>flase</code></entry>
                          <entry>
                             اعطها القيمة true إن اردت عمل ضغط للبيانت on-the-fly (إن صح التعبير "على الطاير").
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.apc">
        <title>Zend_Cache_Backend_APC</title>
        <para>
            هذه الـ backend تقوم بحفظ الـ cache records فى ذاكرة مشتركة من خلال الـ extension 
المسمى 
<ulink url="http://pecl.php.net/package/APC">APC</ulink> (Alternative PHP Cache). 
(بالطبع ستحتاج هذه الـ extension لتستطيع استخدام هذه الـ backend)
        </para>
        <para>
        	احترس: مع هذا الـ backend الـ tags غير مدعومة الى الأن . 
(لأن "doNotTestCacheValidity=true")
        </para>
        <para>
            لا يوجد options لهذه الـ backend
        </para>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->