<sect1 id="zend.cache.introduction">
    <title>مقدمة</title>
    <para>
        <code>Zend_Cache</code> يوفر إمكانية عمل cache للبيانات.
    </para>
      <para>
          عملية الـ caching فى إطار عمل Zend يتم إدارتها من خلال الـ frontend فى حين ان سجلات الـ cache يتم حفظها 
           و استرجاعها عن طريق backend adapters مثل (<code>File</code>, <code>Sqlite</code>, <code>Memcache</code>...) 
          و يستخدم ايضا IDs و tags. بهذه الطريقة يكن من السهل حذف مجموعات محددة من السجلات بعد ذلك.
          على سبيل المثال ("حذف كل سجلات الـ cache المعرفة بـ tag معين")
          
      
    </para>
    
    <para>
        Core هو الـ module  (<code>Zend_Cache_Core</code>) و هو يمثل المرونة و الشمولية و قابلية تعديل الخصائص (configurable).
        حتى الأن يوجد cache frontends تمتد عن <code>Zend_Cache_Core</code> و التى ستخدم احتياجاتك.
        و هى : <code>Output</code>, <code>File</code>, <code>Function</code> and <code>Class</code>.
        
      
    </para>
    <example>
        <title>إنشاء frontend بواسطة <code>()Zend_Cache::factory</code></title>

        <para>
            <code>()Zend_Cache::factory</code> ينشئ الـ objects المتوافقة معا و التى 
            ستحتاجها لإتمام عملك. فى هذا المثال, سنستخدم frontend و هو <code>Core</code> 
            و سنستخدم ايضا backend  وهو <code>File</code>.
        
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200, // cache lifetime of 2 hours 
   'automaticSerialization' => true
);

$backendOptions = array(
    'cacheDir' => './tmp/' // Directory where to put the cache files
);

// getting a Zend_Cache_Core object
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?>]]></programlisting>
       </para>
       <para>
            
            الأن لدينا frontend و أيضا يمكننا عمل cache لأى نوع من البيانات (لأننا قمنا بتشغيل الـ serialization ) .
 على سبيل المثال , يمكننا عمل cache لبيانات ناتجة عن تنفيذ استعلام كبير على قاعدة بيانات .
 بعد عمل cache لهذه البيانات, لن نحتاج الى ان نتصل حتى بقاعدة البيانات فى المرات القادمة; كل ما علينا 
هو جلب هذه البيانات من الـ cache و استخدامها (سيتم عمل unserialization للبيانات ضمنيا ).
            <programlisting role="php"><![CDATA[<?php

// $cache initialized in previous example

// see if a cache already exists:
if(!$result = $cache->get('myresult')) {

    // cache miss; connect to the database
    
    $db = Zend_Db::factory( [...] );
    
    $result = $db->fetchAll('SELECT * FROM huge_table');
    
    $cache->save($result, 'myresult');
    
} else {

    // cache hit! shout so that we know
    echo "This one is from cache!\n\n";
    
}

print_r($result);

?>]]></programlisting>
       </para>
    </example>
    <example>
        <title>عمل cache للخرج بإستخدام الـ Output frontend الخاصة بـ <code>Zend_Cache</code></title>
        <para>
           سنقوم بتحديد الأماكن التى نريد عمل cache لخرجها و ذلك بإستخدامنا لبعض لبعض الأكواد الشرطية, 
سنضع المكان المحدد ما بين الـ method المسمى <code>()start</code> و الأخر المسمى <code>()end</code> .
( هذا يعيد هيكلة المثال الأول و هذه هى الفكرة الأساسية للـ caching ).
        </para><para>
           بالداخل ستقوم بإخراج البيانات كالمعتاد, كل الخرج سيكن قد تم عمل cache له عندما يتم الوصول الى <code>()end</code> .
عند تشغيل هذا الكود مرة اخرى, لن يتم تنفيذ الكود المحدد فى هذا المكان لكن سيتم جلب البيانات من الـ cache 
- و هذا طالما ان البيانات فى الـ cache مازالت قابلة للإستخدام .
            <programlisting role="php"><![CDATA[<?php

$frontendOptions = array(
   'lifeTime' => 30,                  // cache lifetime of half a minute
   'automaticSerialization' => false  // this is default anyway
);

$backendOptions = array('cacheDir' => './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// we pass a unique identifier to the start() method
if(!$cache->start('mypage')) {
    // output as usual:
    
    echo 'Hello world! ';
    echo 'This is cached ('.time().') ';
    
    $cache->end(); // the output is saved and sent to the browser
}

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
       </para>
       <para>
           لاحظ اننا نقوم بإخراج ناتج الدالة <code>()time</code> مرتين; و هذا نستخدمه هنا فقط للتوضيح.
جرب ان تشغل هذا مرة ثم قم بإعادة تشغيله عدة مرات متتالية, ستلاحظ ان الرقم الأول لا يتغير و 
لكن الرقم الثانى يتغير مع مرور الوقت, هذا لأن الرقم الأول تم اخراجه فى منطقة الـ cache المحددة فى الكود 
و بالتالى تم حفظه فى الـ cache على عكس بقية البيانات المخرجة.
بعد نصف دقيقة سيصبح الرقمين متساويين لأن فترة صلاحية البيانات فى الـ cache قد انتهت 
( لقد قمنا بوضع قيمة lifeTime الى 30 ثانية ). و بهذا سيتم تحديث قيمة البيانات المخزنة فى الـ cache 
من جديد. - جرب هذا بنفسك فى متصفحك لتفهم ما يحدث.
       </para>
    </example>
    <note><para>
        عند إستخدام Zend_Cache, ركز على إعطاء معرف مميز للـ cache (الذى تمرره الى
 <code>()start</code> و <code>()save</code> ) و يجب الا يتكرر فى عمليات cache اخرى. 
الوقوع فى هذا الخطأ سيسبب تداخل بين البيانات و اسوأ ما سيحدث هو إن هذه البيانات ستظهر فى اماكن ظهور الأخرى.
    </para></note>
</sect1>


<sect1 id="zend.cache.theory">
    <title>نظرية الـ caching </title>
    <para>
        هناك ثلاث مفاهيم رئيسية فى Zend_Cache. الأول هو المعرف المميز و هو عيارة عن string 
و الذى يستخدم لتعريف البيانات المسجلة فى الـ cache. 
الثانى هو التعليمة <code>'lifeTime'</code> كما رأيتها فى المثال السابق, هى تعرف الفترة الزمنية التى 
يتم اعتبار البيانات المحفوظة فى الـ cache و بهذا المعرف قابلة للإستخدام "طازجة" . 
المفهوم الثالث هو التنفيذ الشرطى للأكواد, حيث يتم اهمال جزء من الكود و لا يتم تنفيذه و هذا يزيد من كفائة الأداء (performance) .
الدالة الأساسية (<code>()Zend_Cache_Core::get</code>) تم تصميمها لتعيد false 
 عندما لا تجد البيانات المطلوبة فى الـ cache قابلة للإستخدام . 
هذا يسمح للمستخدم النهائى (انت المبرمج) من تحديد جزء من الكود الذى يريد عمل cache له داخل جملة 
<code>{ ... }()if</code> حيث ان الشرط هو هذه الدالة من Zend_Cache .
فى نهاية هذه البلوكات يجب ان تقوم بحفظ الناتج , بإستخدام 
(<code>()Zend_Cache_Core::save</code>).
    </para>
    <note><para>
        عملية التنفيذ الشرطى للأكواد لا تكن مهمة فى بعض الحالات ( مثل إستخدام الـ frontend المسمى 
<code>Function</code> ) حيث سيكون الجزء المنطقى من الكود معرف داخل الـ frontend نفسه.
    </para></note>
    <note><para>
        المصطلح 'Cache hit' و الذى رأيته فى المثال نستخدمه للتعبير عن انه تم إيجاد بيانت فى الـ cache تنتمى 
لهذا المعرف و هذه البيانات قابلة للإستخدام و "طازجة" (بمعنى اخر لم تنتهى فترة صلاحيتها). 
المصطلح 'cache miss' هو عكس ما سبق, فعندما يحدث cache miss يجب ان تقوم بإنتاج بياناتك من 
جديد (كما يحدث فى الأوضاع الطبيعية) ثم تقم بعمل cache لها . 
و عندما يحدث cache hit تقم الـ backend تلقائياً بجلب البيانات من الـ cache .

    </para></note>
    <sect2 id="zend.cache.factory">
        <title>الـ factory method فى <code>Zend_Cache</code></title>
        <para>
            طريقة جيدة لإنشاء مثال frontend قابل لإستخدام من <code>Zend_Cache</code> نستعرضها فى 
المثال التالى : 
            <programlisting role="php"><![CDATA[<?php
        
# We "load" the Zend_Cache factory 
require 'Zend/Cache.php'; 

# We choose a backend (for example 'File' or 'Sqlite'...)
$backendName = '[...]';

# We choose a frontend (for example 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# We set an array of options for the choosen frontend
$frontendOptions = array([...]);

# We set an array of options for the choosen backend
$backendOptions = array([...]);

# We make the good instance 
# (of course, the two last arguments are optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

?>]]></programlisting> 
        </para> 
        <para>
            فى الأمثلة التالية سنعتبر ان المتغير <code>cache$</code> يحتوى مثال من frontend صالح للإستخدام 
كما هو موضح فى المثال السابق, و انك تفهم كيفية تمرير parameters للـ backends التى تود إتسخدامها.
        </para>
        <note><para>
            دائما إستخدم <code>()Zend_Cache::factory</code> لتنشئ امثلة frontends . 
إنشاء امثلة من الـ frontends و الـ backends بنفسك مباشرة لن يعمل كما تتوقع.
        </para></note>
    </sect2>
    
    <sect2 id="zend.cache.tags">
        <title>إستخدام الـ tags</title>
        <para>
            ـ tags طرق لتقسيم البيانات فى الـ cache الى اقسام معرفة, عندما تقم بحفظ cache بإستخدام 
<code>()save</code> يمكنك ان تقم بتمرير array تحتوى على الـ tags التى تتوافق مع هذا الـ 
record (او البيانت المخزنة فى الـ cache ) . 
بالتالى ستستطيع حذف كل الـ cache records المنسوبة الى tag او مجموعة tags محددة.
        </para>
        <programlisting role="php"><![CDATA[<?php
             
$cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));
            
?>]]></programlisting>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>تنظيف الـ cache</title>
        <para>
            لحذف او تحديد معرف cache على انه غير قابل للإستخدام, يمكنك استخدام <code>()remove</code> 
 كما فى المثال التالى :
        </para>
        <programlisting role="php"><![CDATA[<?php 
             
$cache->remove('idToRemove');
            
?>]]></programlisting>            
        <para>
            لحذف او تحديد اكثر من معرف cache على انهم غير قابلين للإستخدام, يمكنك استخدام 
<code>()clean</code> , على سبيل المثال يمكنك حذف كل الـ cache records .
        </para>
        <programlisting role="php"><![CDATA[<?php 

// clean all records
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// clean only outdated
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
            
?>]]>   </programlisting>    
        <para>
            إن اردت حذف الـ cache records التى تنتمى الى tags محددة, مثلا 'tagA' و 'tagC' 
يمكنك استخدام :
        </para>
        <programlisting role="php"><![CDATA[<?php 
             
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tagA', 'tagC'));
            
?>]]>   </programlisting>
        <para>
            الـ cleaning modes المتوفرة هى : 
<code>CLEANING_MODE_ALL</code> تقوم بحذف كل الـ cache records الموجودة
 <br />
,  <code>CLEANING_MODE_OLD</code> تقوم بحذف الـ records القديمة او الغير 
 صالحة للإستخدام  <br />
,
 <code>CLEANING_MODE_MATCHING_TAG</code> تقوم بحذف كل الـ records التى تنتمى الى مجموعة tags محددة <br />
,<code>CLEANING_MODE_NOT_MATCHING_TAG</code> تقوم بحذف كل الـ records 
التى لا تنتمى الى مجموعة الـ tags الممررة. 

        </para>
    </sect2>
</sect1>

<sect1 id="zend.cache.frontends">
    <title>الـ frontends المتوفرة فى Zend_Cache</title>
    
    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>مقدمة</title>
            <para>
                <code>Zend_Cache_Core</code> هو frontend مميز لأنه جوهر الـ module . 
هو عبارة cache frontend عام و هناك classes أخرى ممتدة منه0
            </para>
            <note><para>
                كل الـ frontends ترث من <code>Zend_Cache_Core</code> و بهذا كل الـ methods 
و الـ options الخاصة به (سيتم توضيحها لاحقاً) متوفرة فى الـ frontends الأخرى , لذلك لن نقوم بشرحها هناك.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>الـ options المتوفرة لـ Zend_Cache_Core</title>
            <para>
                هذه الـ options يتم تمريرها الى الـ factory method كما كان موضحاً فى امثلة سابقة.
            </para>
            <table>
                <title>الـ options المتوفرة</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  تقوم بإقاف او تشغيل عملية الـ caching ( من الممكن ان تكن مفيدة عند عمل debuging للكود الواقع فى 
نطاق عمل عملية الـ caching ).              
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                فترة صلاحية الـ cache record (بالثوانى), إن كانت قيمتها تساوى null فسيكون الـ cache record 
صالح للإستخدام دائما.      
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                إن كانت قيمتها تساوى TRUE, سيتم تنشيط عملية الـ loging من خلال <code>Zend_Log</code> . 
(لكن سيبطئ من عمل النظام نسبياً)       
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Enable / disable write control (the cache is read 
                                just after writing to detect corrupt entries), enabling writeControl
                                will lightly slow the cache writing but not the cache reading (it 
                                can detect some corrupt cache files but it's not a perfect control)        
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Enable / disable automatic serialization, it can be used to save directly datas
                                which aren't strings (but it's slower)            
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                Disable / Tune the automatic cleaning process (garbage collector):
                                0 means no automatic cache cleaning, 1 means systematic cache cleaning
                                and x &gt; 1 means automatic random cleaning 1 times in x write operations.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.core.examples">
            <title>Examples</title>
            <para>
                An example is given in the manual at the very beginning.
            </para>
            <para>
                If you store only strings into cache (because with "automaticSerialization" option, it's possible
                to store some booleans), you can use a more compact construction like:
            </para>
            <programlisting role="php"><![CDATA[<?php  
             
// we assume you already have $cache

$id = 'myBigLoop'; // cache id of "what we want to cache"

if (!($data = $cache->get($id))) {
    // cache miss
    
    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 

// [...] do something with $data (echo it, pass it on etc.)
             
?>]]>       </programlisting> 
            <para>
                If you want to cache multiple blocks or data instances, the idea is the same:
            </para>
            <programlisting role="php"><![CDATA[<?php  
             
// make sure you use unique identifiers:
$id1 = 'foo';
$id2 = 'bar';

// block 1
if (!($data = $cache->get($id1))) {
    // cache missed
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }
    
    $cache->save($data);
    
} 
echo($data);

// this isn't affected by caching
echo('NEVER CACHED! ');

// block 2
if (!($data = $cache->get($id2))) {
    // cache missed
    
    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }
    
    $cache->save($data);
    
} 
echo($data);

?>]]>       </programlisting>                        
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontend.output.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Output</code> is an output-capturing frontend. It utilizes
                output buffering in PHP to capture everything between its <code>start()</code> and
                <code>end()</code> methods.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.output.options">
            <title>Available options</title>
            <para>
                This frontend doesn't have any specific options other than those of
                <code>Zend_Cache_Core</code>.
            </para>
        </sect3>
        
        <sect3 id="zend.cache.frontend.output.examples">
            <title>Examples</title>
            <para>
                An example is given in the manual at the very beginning. Here it is with minor changes:
            </para>
            <programlisting role="php"><![CDATA[<?php

// if it is a cache miss, output buffering is triggered
if(!$cache->start('mypage')):

// output everything as usual
echo 'Hello world! ';
echo 'This is cached ('.time().') ';

$cache->end(); // output buffering ends
endif;

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
            <para>
                Using this form it is fairly easy to set up output caching in your already working project
                with little or no code refactoring.
            </para>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontend.function.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Function</code> caches the results of function calls. It has
                a single main method named <code>call()</code> which takes a function name and parameters
                for the call in an array.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.function.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  if true, function calls will be cached by default                
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  function names which will always be cached               
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedFunctions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  function names which must never be cached               
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.function.examples">
            <title>Examples</title>
            <para>
                Using the <code>call()</code> function is the same as using
                <code>call_user_func_array()</code> in PHP:
            </para>
            <programlisting role="php"><![CDATA[<?php

$cache->call('veryExpensiveFunc', $params);

# $params is an array
# for example to call (with caching) veryExpensiveFunc(1, 'foo', 'bar'), you will use
# $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar'))

?>]]>       </programlisting>
            <para>
                <code>Zend_Cache_Frontend_Function</code> is smart enough to cache both the
                return value of the function and its internal output.
            </para>
            <note><para>
                You can pass any builtin or user defined function with the exception of
                <code>array()</code>, <code>echo()</code>, <code>empty()</code>, <code>eval()</code>,
                <code>exit()</code>, <code>isset()</code>, <code>list()</code>, <code>print()</code>
                and <code>unset()</code>. 
            </para></note>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontend.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontend.class.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_Class</code> is different from <code>Zend_Cache_Frontend_Function</code>
                because it allows caching of object and static method calls.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontend.class.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cachedEntity</code> (required)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  if set to a class name, we will cache an abstract class and will use
                                  only static calls; if set to an object, we will cache this object methods             
                              </entry>
                         </row>
                         <row>
                              <entry><code>cacheByDefault</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  if true, calls will be cached by default                
                              </entry>
                         </row>
                         <row>
                              <entry><code>cachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  method names which will always be cached               
                              </entry>
                         </row>
                         <row>
                              <entry><code>nonCachedMethods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  method names which must never be cached               
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.frontend.class.examples">
            <title>Examples</title>
            <para>
                For example, to cache static calls :
            </para>
            <programlisting role="php"><![CDATA[<?php

class test {
   
    # Static method
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => 'test' // The name of the class
);
// [...]

# The cached call
$res = $cache->foobar('1', '2');

?>]]>       </programlisting>
            <para>
                To cache classic method calls :
            </para>
            <programlisting role="php"><![CDATA[<?php

class test {
   
    private $_string = 'hello !';
      
    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";   
    }

}

// [...]
$frontendOptions = array(
    'cachedEntity' => new test() // An instance of the class
);
// [...]

# The cached call
$res = $cache->foobar2('1', '2');

?>]]>       </programlisting>
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> is a frontend driven by the 
                modification time of a "master file". It's really interesting for examples
                in configuration or templates issues.
            </para>
            <para> 
            	For instance, you have an XML configuration file which is parsed by a function 
            	which returns a "config object" (like with <code>Zend_Config</code>). With
            	<code>Zend_Cache_Frontend_File</code>, you can store the "config object" into
            	cache (to avoid the parsing of the XML config file at each time) but with a
            	sort of strong dependency on the "master file". So, if the XML config file
            	is modified, the cache is immediatly invalidated.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Available options</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>masterFile (mandatory)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  the complete path and name of the master file                 
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>   
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Examples</title>
            <para>
                Use of this frontend is the same than of <code>Zend_Cache_Core</code>. There
                is no need of a specific example - the only thing to do is to 
                define the <code>masterFile</code> when using the factory.
            </para>
        </sect3>
    </sect2>
    
    <sect2 id="zend.cache.frontends.page">
    	<title>Zend_Cache_Frontend_Page</title>
    	<sect3 id="zend.cache.frontends.page.introduction">
        	<title>Introduction</title>
        	<para>
	            <code>Zend_Cache_Frontend_Page</code> is like <code>Zend_Cache_Frontend_Output</code>
	            but designed for a complete page. It's impossible to use <code>Zend_Cache_Frontend_Page</code>
	            for caching only a single block.
	        </para>
	        <para>
	        	On the other hand, the "cache id" is calculated automatically with
	        	<code>$_SERVER['REQUEST_URI']</code> and (depending on options) 
	        	<code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>, <code>$_COOKIE</code>, <code>$_FILES</code>.
	        	More over, you have only one method to call (<code>start()</code>) because the
	        	<code>end()</code> call is fully automatic when the page is ended.
	        </para>
	        <para>
	        	For the moment, it's not implemented but we plan to add a HTTP conditional system
	        	to save bandwith (the system will send a HTTP 304 Not Modified if the cache is hit
	        	and if the browser has already the good version).
	        </para>
	        <note><para>
                Zend_Cache_Frontend_Page is really "alpha stuff" and is meant to be improved further down the road.
	        </para></note>
    	</sect3>
    	<sect3 id="zend.cache.frontends.page.options">
	        <title>Available options (for this frontend in Zend_Cache factory)</title>
	        <table>
	            <title>Available options</title>
	            <tgroup cols="4">
	                 <thead>
	                      <row>
	                        <entry>Option</entry>
	                        <entry>Data Type</entry>
	                        <entry>Default Value</entry>
	                        <entry>Description</entry>
	                    </row>
	                 </thead>
	                 <tbody>
	                 	 <row>
	                          <entry><code>httpConditional</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              use the httpConditional system (not implemented for the moment)                 
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>debugHeader</code></entry>
	                          <entry><code>boolean</code></entry>
	                          <entry><code>false</code></entry>
	                          <entry>
	                              if true, a debug text is added before each cached pages                 
	                          </entry>
	                     </row>
	                     <row>
	                     	  <entry><code>defaultOptions</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array(...see below...)</code></entry>
	                          <entry>
	                              an associative array of default options : 
	                              <itemizedlist>
	                                  <listitem><code>(boolean, true by default) cache</code> : cache is on if true</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithGetVariables</code> : if true, cache is still on even if there are some variables in <code>$_GET</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithPostVariables</code> : if true, cache is still on even if there are some variables in <code>$_POST</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithSessionVariables</code> : if true, cache is still on even if there are some variables in <code>$_SESSION</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithFilesVariables</code> : if true, cache is still on even if there are some variables in <code>$_FILES</code> array</listitem>
	                                  <listitem><code>(boolean, false by default) cacheWithCookieVariables</code> : if true, cache is still on even if there are some variables in <code>$_COOKIE</code> array</listitem>
									  <listitem><code>(boolean, true by default) makeIdWithGetVariables</code> : if true, the cache id will be dependent of the content of the <code>$_GET</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithPostVariables</code> : if true, the cache id will be dependent of the content of the <code>$_POST</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithSessionVariables</code> : if true, the cache id will be dependent of the content of the <code>$_SESSION</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithFilesVariables</code> : if true, the cache id will be dependent of the content of the <code>$_FILES</code> array</listitem>
	                                  <listitem><code>(boolean, true by default) makeIdWithCookieVariables</code> : if true, the cache id will be dependent of the content of the <code>$_COOKIE</code> array</listitem>	                              
	                              </itemizedlist>              
	                          </entry>
	                     </row>
	                     <row>
	                          <entry><code>regexps</code></entry>
	                          <entry><code>array</code></entry>
	                          <entry><code>array()</code></entry>
	                          <entry>
	                          	  an associative array to set options only for some REQUEST_URI, keys are (PCRE) regexps, values are 
	                          	  associative arrays with specific options to set if the regexp matchs on $_SERVER['REQUEST_URI']
                                  (see defaultOptions for the list of available options) ; if several regexps match the $_SERVER['REQUEST_URI'], 
                                  only the last one will be used       
	                          </entry>
	                     </row>
	                  </tbody>
	              </tgroup>
	          </table>
	    </sect3>   
    	<sect3 id="zend.cache.frontends.page.examples">
        	<title>Examples</title>
	        <para>
	            Use of Zend_Cache_Frontend_Page is really trivial :
	        </para>
            <programlisting role="php"><![CDATA[<?php
	           
// [...] // require, configuration and factory
	
$cache->start();
// if the cache is hit, the result is sent to the browser and the script stop here
	
// rest of the page ...
	
?>]]>       </programlisting>
	        <para>
	        	a more complex example which shows a way to get a centralized cache management in a bootstrap file
	        	(for using with Zend_Controller for example)
            </para>
            <programlisting role="php"><![CDATA[<?php

// [...] you should avoid to put too much lines before the cache section 
// [...] for example, for optimal performances, "require_once" or "Zend::loadClass" should be 
// [...] after the cache section        	

require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200,
   'debugHeader' => true, // for debuging 
   'regexps' => array(
       '^/$' => array('cache' => true),         // cache the whole IndexController         
       '^/index/' => array('cache' => true),    // cache the whole IndexController
       '^/article/' => array('cache' => false), // we don't cache the ArticleController...
       '^/article/view/' => array(              // ...but we cache the "view" action of 
           'cache' => true,                     // this ArticleController
           'cacheWithPostVariables' => true,    // and we cache even there are some variables in $_POST
           'makeIdWithPostVariables' => true,   // (but the cache will be dependent of the $_POST array)
       )
   )	  
);
$backendOptions = array(
    'cacheDir' => '/tmp/' 
);

// getting a Zend_Cache_Frontend_Page object
$cache = Zend_Cache::factory('Page', 'File', $frontendOptions, $backendOptions);

$cache->start();
// if the cache is hit, the result is sent to the browser and the script stop here

// [...] the end of the bootstrap file (these lines won't be executed if the cache is hit)
	        	
?>]]>       </programlisting>
    	</sect3>
	</sect2>   
</sect1>

<sect1 id="zend.cache.backends">
    <title>Zend_Cache backends</title>
    
    <sect2 id="zend.cache.backends.file">
        <title>Zend_Cache_Backend_File</title>
        <para>
            This backends stores cache records into files (in a choosen directory). 
        </para>
        <para>
            Available options are :
        </para>          
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDir</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'/tmp/'</code></entry>
                          <entry>
                              Directory where to store cache files    
                          </entry>
                      </row>
                      <row>
                          <entry><code>fileLocking</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Enable / disable fileLocking : Can avoid cache corruption under 
                            bad circumstances but it doesn't help on multithread webservers 
                            or on NFS filesystems...
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControl</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Enable / disable read control : if enabled, a control key is 
                            embeded in the cache file and this key is compared with the 
                            one calculated after the reading.        
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControlType</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'crc32'</code></entry>
                          <entry>
                            Type of read control (only if read control is enabled). Available values are :
                            'md5' (best but slowest), 'crc32' (lightly less safe but faster, better choice),
                            'strlen' for a length only test (fastest).
                        </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryLevel</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0</code></entry>
                          <entry>
                            Hashed directory structure level :     0 means "no hashed directory 
                             structure", 1 means "one level of directory", 2 means "two levels"... 
                             This option can speed up the cache only when you have many thousands of 
                             cache files. Only specific benchs can help you to choose the perfect 
                             value for you. Maybe, 1 or 2 is a good start.
                          </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryUmask</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0700</code></entry>
                          <entry>
                              Umask for the hashed directory structure
                        </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
        <title>Zend_Cache_Backend_Sqlite</title>
        <para>
            This backends stores cache records into a SQLite database.
        </para>
        <para>
            Available options are :
        </para>
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                           <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDBCompletePath (mandatory)</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>null</code></entry>
                          <entry>
                              The complete path (filename included) of the SQLite database
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.memcached">
        <title>Zend_Cache_Backend_Memcached</title>
        <para>
            This backends stores cache records into a memcached server. <ulink url="http://www.danga.com/memcached/">memcached</ulink>
            is a high-performance, distributed memory object caching system. To use this backend, 
            you need a memcached daemon and <ulink url="http://pecl.php.net/package/memcache">the memcache PECL extension</ulink>.
        </para>
        <para>
        	Be careful : with this backend, "tags" are not supported for the moment as 
        	the "doNotTestCacheValidity=true" argument.
        </para>
        <para>
            Available options are :
        </para>
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>servers</code></entry>
                          <entry><code>array</code></entry>
                          <entry><code>array(array('host' => 'localhost','port' => 11211, 'persistent' => true))</code></entry>
                          <entry>
                              An array of memcached servers ; each memcached server is described by an associative array :
                              'host' => (string) : the name of the memcached server, 
                              'port' => (int) : the port of the memcached server, 
                              'persistent' => (bool) : use or not persistent connections to this memcached server
                          </entry>
                      </row>
                      <row>
                          <entry><code>compression</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>flase</code></entry>
                          <entry>
                             true if you want to use on-the-fly compression
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.apc">
        <title>Zend_Cache_Backend_APC</title>
        <para>
            This backends stores cache records in shared memory through 
            the <ulink url="http://pecl.php.net/package/APC">APC</ulink> (Alternative PHP Cache) extension
            (which is of course need for using this backend).
        </para>
        <para>
        	Be careful : with this backend, "tags" are not supported for the moment as 
        	the "doNotTestCacheValidity=true" argument.
        </para>
        <para>
            There is no option for this backend.
        </para>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->