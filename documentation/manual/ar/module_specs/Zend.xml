<sect1 id="zend.introduction">
    <title>مقدمة</title>
    <para>
<<<<<<< .mine
    Zend هو الـ Class الرئيسى فى إطار عمل Zend. هذا الـ Class نبع من إلتزام إطار العمل 
    بمبدأ DRY و هو إختصار (Don't Repeat Yourself) اى بمعنى لا تكرر نفسك. 
    و هو يحتوى فقط على static methods, و هذه الـ methods تقوم بوظائف تحتاجها الكثير من 
    الـ Components فى إطار عمل Zend.
=======
    الـ Class Zend هو الـ Class الأساسي فى إطار عمل Zend. هذا الـ Class نبع من إلتزام إطار العمل 
    بمبدأ DRY (Don't Repeat Yourself) اى بمعنى لا تكرر نفسك. 
    و هو يحتوى فقط على static methods, و هذه الـ methods تقوم بوظائف تحتاجها الكثير من 
    الـ Components فى إطار عمل Zend.
>>>>>>> .r1147
    </para>
    
    <para>
     
    
    </para>
</sect1>

<sect1 id="zend.loadfile">
    <title>()Zend::loadFile</title>

    <para>
<<<<<<< .mine
    <code>()Zend::loadFile</code>
    يقوم بتحميل ملف PHP و الذى من الممكن أن يحتوى اى اكواد PHP. و هو يعتبر غلاف (wrapper) للدالة 
    <ulink url="http://php.net/include"><code>()include</code></ulink> فى لغة PHP. و 
    سيلقى <code>Zend_Exception</code> عند حدوث خطأ.
=======
    <code>()Zend::loadFile</code>
    يقوم بتحميل ملف PHP و الذى ربما يحتوى اى اكواد PHP. و هو يعتبر غلاف (wrapper) للدالة 
    <ulink url="http://php.net/include"><code>()include</code></ulink> فى لغة PHP. و 
    سيلقى <code>Zend_Exception</code> عند حدوث خطأ.
>>>>>>> .r1147
    </para>

    <programlisting role="php"><![CDATA[<?php

loadFile($filename, $dirs=null, $once=false)

?>]]></programlisting>

    <para>
    المتغير <code>filename$</code> يحدد اسم الملف الذى سيتم تحميله, و الذى يجب الا يحتوى على 
    اى معلومات عن المسار. يتم عمل فحص أمان على <code>filename$</code> . من الممكن ان يحتوى 
    المتغير <code>filename$</code> فقط على حروف, ارقام, شُرط "-", شُرط منخفضة "_" او نقاط (".").
    لا توجد اى تقيدات على المتغير <code>dirs$</code>.
    </para>

<<<<<<< .mine
    <para>
    المتغير <code>dirs$</code> يحدد اى المجلدات سيتم البحث فيها عن الملف. إذا اعطى القيمة 
    <code>NULL</code> فسيتم البحث فى الـ <code>include_path</code> فقط.
    و إذا كان يحمل قيمة نصية (string) او مصفوفة (Array), فهذا المجلد او هذه الجلدات سيتم 
    البحث فيها, ثم بعد ذلك فى الـ <code>include_path</code>.
=======
    <para>
    المتغير <code>$dirs</code> يحدد اى المجلدات سيتم البحث فيها عن الملف. إذا اعطى القيمة 
    <code>NULL</code> فسيتم البحث فى الـ <code>include_path</code> فقط.
    و إذا كان يحمل قيمة نصية (string) او مصفوفة (Array), فهذا المجلد او هذه الجلدات سيتم 
    البحث فيها, ثم بعد ذلك فى الـ <code>include_path</code>.
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
    المتغير <code>once$</code> من النوع bool و يحدد إما ان يتم إستخدام الدالة 
    <ulink url="http://php.net/include"><code>()include</code></ulink> او إستخدام الدالة 
    <ulink url="http://php.net/include_once"><code>()include_once</code></ulink> لتحميل 
    الملف.
=======
    المتغير <code>$once</code> من النوع bool و يحدد إما ان يتم إستخدام الدالة 
    <ulink url="http://php.net/include"><code>include()</code></ulink> او إستخدام الدالة 
    <ulink url="http://php.net/include_once"><code>include_once()</code></ulink> لتحميل 
    الملف.
>>>>>>> .r1147
    </para>
</sect1>

<sect1 id="zend.loadclass">
    <title>()Zend::loadClass</title>
    <para>
<<<<<<< .mine
    <code>()Zend::loadClass</code> يقوم بتحميل ملف PHP حيث اسمه يكن على هذا الشكل 
    "<code>className.php$</code>", ثم بعد ذلك يقم بالتحقق من وجود الـ Class الممر اسمه فى 
    <code>className$</code>.
   </para>
=======
    <code>Zend::loadClass()</code> يقوم بتحميل ملف PHP حيث اسمه يكن على هذا الشكل 
    "<code>$className.php</code>", ثم بعد ذلك يقم بالتحقق من وجود الـ Class الممر اسمه فى 
    <code>$className</code>.
   </para>
>>>>>>> .r1147

    <programlisting role="php"><![CDATA[<?php

loadClass($class, $dirs)

?>]]></programlisting>

    <para>
<<<<<<< .mine
    إذا لم يتم ايجاد الملف او ان الـ Class لم يكن موجود بعد التحميل, سيتم إلقاء <code>Zend_Exception</code>.
    يستخدم <code>()Zend::loadFile</code> للتحميل و المتغير <code>dirs$</code> يمرر مباشرة إليه.
  
=======
    إذا لم يتم ايجاد الملف او ان الـ Class لم يكن موجود بعد التحميل, سيتم إلقاء <code>Zend_Exception</code>.
    يستخدم <code>Zend::loadFile()</code> للتحميل و المتغير <code>$dirs</code> يمرر مباشرة إليه.
  
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
    إذا قمت بتمرير اسم Class يحتوى على شُرط منخفضة "_", و المتغير <code>dirs$</code> يحمل القيمة 
    <code>NULL</code> (القيمة الأساسية),
    فسيقوم <code>()Zend::loadClass</code> تلقائيا بإكتشاف قيمة <code>dirs$</code> من اسم الـ Class 
    عن طريق تبديل الشُرط المنخفضة "_" بفواصل مجلدات.
    على سبيل المثال, إذا كانت قيمة المتغير <code>class$</code> هى <code>Zend_Example_Class</code>, 
    فسيتم ترجمة هذا الى المسار <code>Zend/Example/Class.php</code>.
=======
    إذا قمت بتمرير اسم Class يحتوى على شُرط منخفضة "_", و المتغير <code>$dirs</code> يحمل القيمة 
    <code>NULL</code> (القيمة الأساسية),
    فسيقوم <code>Zend::loadClass()</code> تلقائيا بإكتشاف قيمة <code>$dirs</code> من اسم الـ Class 
    عن طريق تبديل الشُرط المنخفضة "_" بفواصل مجلدات.
    على سبيل المثال, إذا كانت قيمة المتغير <code>$class</code> هى <code>Zend_Example_Class</code>, 
    فسيتم ترجمة هذا الى المسار <code>Zend/Example/Class.php</code>.
>>>>>>> .r1147
    </para>
</sect1>

<sect1 id="zend.loadinterface">
    <title>()Zend::loadInterface</title>
    <para>
<<<<<<< .mine
    يعمل <code>()Zend::loadInterface</code> تماما مثل <code>()Zend::loadClass</code>, 
    إلا انه يقوم بتحميل Interface بدلا من تحميل Class.
    
=======
    يعمل <code>Zend::loadInterface()</code> تماما مثل <code>Zend::loadClass()</code>, إلا انه يقوم 
    بتحميل Interface بدلا من تحميل Class.
    
>>>>>>> .r1147
    </para>

    <programlisting role="php"><![CDATA[<?php

loadInterface($interface, $dirs)

?>]]></programlisting>

    <para>
<<<<<<< .mine
    لا يمكن إستخدام <code>()Zend::loadClass</code> فى تحميل الـ Interfaces لأن دالة الـ PHP 
    <ulink url="http://php.net/class_exists"><code>()class_exists</code></ulink> لا يمكنها 
    التأكد من وجود الـ Interfaces (من اصدار PHP 5.0.2). 
    إستخدم <code>()Zend::loadInterface</code> بدلاً منها.
    
=======
    لا يمكن إستخدام <code>Zend::loadClass()</code> فى تحميل الـ Interfaces لأن دالة الـ PHP 
    <ulink url="http://php.net/class_exists"><code>class_exists()</code></ulink> لا يمكنها 
    التأكد من وجود الـ Interfaces (من اصدار PHP 5.0.2). 
    إستخدم <code>Zend::loadInterface()</code> بدلاً منها.
    
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
     إذا قمت بتمرير اسم Interface يحتوى على شُرط منخفضة "_", و المتغير <code>dirs$</code> يحمل القيمة 
    <code>NULL</code> (القيمة الأساسية),
    فسيقوم <code>()Zend::loadInterface</code> تلقائيا بإكتشاف قيمة <code>dirs$</code> من اسم الـ Interface 
    عن طريق تبديل الشُرط المنخفضة "_" بفواصل مجلدات.
    على سبيل المثال, إذا كانت قيمة المتغير <code>interface$</code> هى <code>Zend_Example_Interface</code>, 
    فسيتم ترجمة هذا الى المسار <code>Zend/Example/Interface.php</code>.
    
=======
     إذا قمت بتمرير اسم Interface يحتوى على شُرط منخفضة "_", و المتغير <code>$dirs</code> يحمل القيمة 
    <code>NULL</code> (القيمة الأساسية),
    فسيقوم <code>Zend::loadInterface()</code> تلقائيا بإكتشاف قيمة <code>$dirs</code> من اسم الـ Interface 
    عن طريق تبديل الشُرط المنخفضة "_" بفواصل مجلدات.
    على سبيل المثال, إذا كانت قيمة المتغير <code>$interface</code> هى <code>Zend_Example_Interface</code>, 
    فسيتم ترجمة هذا الى المسار <code>Zend/Example/Interface.php</code>.
    
>>>>>>> .r1147
    </para>
</sect1>

<sect1 id="zend.isreadable">
    <title>()Zend::isReadable</title>

    <para>يرجع القيمة <code>TRUE</code> إذا كان الملف قابل للقرائة, و إذا كان عكس ذلك فسيرجع
          القيمة FALSE .</para>

    <programlisting role="php"><![CDATA[<?php

isReadable($filename)

?>]]></programlisting>

<<<<<<< .mine
    <para>
    المتغير <code>filename$</code> يحدد اسم الملف الذى سيتم التحقق منه, و الذى من الممكن 
    ان يحتوى على بيانات المسار.
    هذا الـ method علاف (wrapper) للدالة <ulink url="http://php.net/is_readable"><code>()is_readable</code></ulink> 
    فى لغة PHP. 
    دالة الـ PHP لا تقم بالبحث فى الـ <code>include_path</code> فى حين ان <code>()Zend::isReadable</code> تفعل ذلك.
    
=======
    <para>
    المتغير <code>$filename</code> يحدد اسم الملف الذى سيتم التحقق منه, و الذى من الممكن 
    ان يحتوى على بيانات المسار.
    هذا الـ method علاف (wrapper) للدالة <ulink url="http://php.net/is_readable"><code>is_readable()</code></ulink> 
    فى لغة PHP. 
    دالة الـ PHP لا تقم بالبحث فى الـ <code>include_path</code> فى حين ان <code>Zend::isReadable()</code> تفعل ذلك.
    
>>>>>>> .r1147
    </para>
</sect1>

<sect1 id="zend.dump">
    <title>()Zend::dump</title>

    <para>
<<<<<<< .mine
    يقوم <code>()Zend::dump</code> بطباعة او إرجاع معلومات عن expression
    (متغير, كائن ..الخ). هو غلاف (wrapper) لدالة الـ PHP 
    <ulink url="http://php.net/var_dump"><code>()var_dump</code></ulink>. 
    يقوم بأحاطة الخرج بوسم(X(HTML <code>&lt;pre&gt;</code> و إختياريا يقوم بإضافة 
    وصف للخرج يمرر إليه فى <code>label$</code>.
    
=======
    يقوم <code>Zend::dump()</code> بطباعة او إرجاع معلومات عن expression<footnote> 
    متغير, كائن ..الخ</footnote>. هو غلاف (wrapper) لدالة الـ PHP 
    <ulink url="http://php.net/var_dump"><code>var_dump()</code></ulink>. 
    يقوم بأحاطة الخرج بوسم (X)HTML <code>&lt;pre&gt;</code> و إختياريا يقوم بإخراج وصف يمرر إليه.
    
>>>>>>> .r1147
    </para>

    <programlisting role="php"><![CDATA[<?php

dump($var, $label=null, $echo=true)

?>]]></programlisting>

    <para>
<<<<<<< .mine
    المتغير <code>var$</code> يحدد الـ expression او المتغير الذى سيتم الحصول على المعلومات منه.
    
=======
    المتغير <code>$var</code> يحدد الـ expression او المتغير الذى سيتم الحصول على المعلومات منه.
    
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
    المتغير <code>label$</code> هو اى نص حرفى يراد ان يدمج مع خرج <code>()Zend::dump</code>.
    هذا مفيد عندما تقم بإستخراج معلومات اكثر من متغير على شاشة واحدة (فى نفس الصفحة).
    
=======
    المتغير <code>$label</code> هو اى نص حرفى يراد ان يدمج مع خرج <code>Zend::dump()</code>.
    هذا مفيد عندما تقم بإستخراج معلومات اكثر من متغير على شاشة واحدة (فى نفس الصفحة).
    
>>>>>>> .r1147
    </para>

<<<<<<< .mine
    <para>
    المتغير <code>echo$</code> من النوع bool و يحدد ما إذا كنت تريد طباعة خرج <code>()Zend::dump</code> 
    أم لا. إذا كانت قيمته <code>TRUE</code>, سيتم طباعة الخرج. و بغض النظر عن قيمة <code>echo$</code> 
    فالخرج دائما يتم ارجاعه (returned).

=======
    <para>
    المتغير <code>$echo</code> من النوع bool و يحدد ما إذا كنت تريد طباعة خرج <code>Zend::dump()</code> 
    أم لا. إذا كانت قيمته <code>TRUE</code>, سيتم طباعة الخرج. و بغض النظر عن قيمة <code>$echo</code> 
    فالخرج دائما يتم ارجاعه (returned).

>>>>>>> .r1147
    </para>
</sect1>


<sect1 id="zend.register">
    <title>()Zend::register</title>

    <para>
<<<<<<< .mine
    يسجل Object فى مسجل (registry) الـ Objects .
=======
    يسجل Object فى مسجل الـ Objects.
>>>>>>> .r1147
    </para>

    <programlisting role="php"><![CDATA[<?php

register($name, $object)

?>]]></programlisting>

    <para>
<<<<<<< .mine
    الـ registry هى ميكنة للتزويد بنسخ ثابتة (singleton instances) من الـ Objects فى نطاق عمل التطبيق.
    عند حفظ الـ Object فى الـ registry مرة واحدة, ثم إسترجاع الـ Object مرة ثانية من الـ registry عندما 
    نكن فى حاجة إليه, يعود إلينا نفس المثال (instance) دائما.
    
=======
    الـ registry هى ميكنة للتزويد بنسخ موحدة (singleton instances) من الـ Objects فى نطاق عمل التطبيق.
    عند حفظ الـ Object فى الـ registry مرة واحدة, ثم إسترجاع الـ Object مرة ثانية من الـ registry عندما 
    نكن فى حاجة إليه, يعود إلينا نفس المثال (instance) دائما.
    
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
    المتغير <code>name$</code> هو اى string يمكن إستخدامه لتسمية الـ Object فى المـ registry.
    هذا الأسم سيمرر إلى <code>()Zend::registry</code> لأستعادة الـ Object مرة اخرى.
    
=======
    المتغير <code>$name</code> هو اى string يمكن إستخدامه لتسمية الـ Object فى المخزن.
    هذا الأسم سيمرر إلى <code>Zend::registry()</code> لأستعادة الـ Object مرة اخرى.
    
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
    المتغير <code>name$</code> يجب ان يكن string, و فقط الـ Objects يمكن حفظها فى الـ registry, و لا يمكن حذف 
    Object من الـ registry, و المثال الواحد (instance) يمكن حفظه مرة واحدة فى الـ registry. 
    الفشل فى الإلتزام بهذه القواعد سيتسبب فى إلقاء <code>Zend_Exception</code> .

=======
    المتغير <code>$name</code> يجب ان يكن string, و فقط الـ Objects يمكن حفظها فى الـ registry, و لا يمكن حذف 
    Object من الـ registry, و المثال الواحد (instance) يمكن حفظه مرة واحدة فى الـ registry. 
    الفشل فى الإلتزام بهذه القواعد سيتسبب فى إلقاء <code>Zend_Exception</code> .

>>>>>>> .r1147
    </para>
</sect1>

<sect1 id="zend.registry">
    <title>()Zend::registry</title>

    <para>
<<<<<<< .mine
    يقوم بإرجاع Object من الـ registry او يقوم بإرجاع قائمة بالكائنات  
    الموجدة فى الـ registry.
    
=======
    يقوم بإرجاع Object من الـ registry او يقوم بإرجاع قائمة بالكائنات فى الـ registry.
    
>>>>>>> .r1147
    </para>

    <programlisting role="php"><![CDATA[<?php

registry($name=null)

?>]]></programlisting>

    <para>
<<<<<<< .mine
    إذا كان المتغير <code>name$</code> يحمل قيمة <code>NULL</code>, سيتم إرجاع Array حيث الـ key فيها هو 
    اسم الـ Objects فى الـ registry و الـ value هى اسماء الـ Classes المنشء منها الـ Objects.
    
=======
    إذا كان المتغير <code>$name</code> يحمل قيمة <code>NULL</code>, سيتم إرجاع Array حيث الـ key فيها هو 
    اسم الـ Objects فى الـ registry و الـ value هى اسماء الـ Classes المنشء منها الـ Objects.
    
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
    إذا كانت قيمة <code>name$</code> عبارة عن string, سيتم إرجاع مقبض الـ Object المشار إليه بهذا الإسم.
    إن فشل العثور على Object فى الـ registry بهذا الأسم <code>name$</code>, 
    سيتم إلقاء <code>Zend_Exception</code>.
    
=======
    إذا كانت قيمة <code>$name</code> عبارة عن string, سيتم إرجاع مقبض الـ Object المشار إليه بهذا الإسم.
    إن فشل العثور على Object فى الـ registry بهذا الأسم <code>$name</code>, 
    سيتم إلقاء <code>Zend_Exception</code>.
    
>>>>>>> .r1147
    </para>

    <para>
<<<<<<< .mine
    لتعرف سريعاً إذا ما كان الـ Object موجود فى الـ registry, استخدم <code> ()Zend::isRegistred</code>.

=======
    لتعرف سريعاً إذا ما كان الـ Object موجود فى الـ registry, استخدم <code> Zend::isRegistred()</code>.

>>>>>>> .r1147
    </para>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->