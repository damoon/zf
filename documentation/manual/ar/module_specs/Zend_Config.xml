<sect1 id="zend.config.introduction">
    <title>مقدمة</title>
    <para>
        تم تصميم <code>Zend_Config</code> لتسهل استخدام بيانات الـ configuration الخاصة بتطبيقات الويب , 
حيث توفر واجهة استخدام  تعتمد على اسم الـ property لقرائة المعلومات الخاصة بالـ configuration و ذلك 
من اكثر من وسيلة حفظ بيانات هرمية. 
حالياً توفر <code>Zend_Config</code> مجموعة من الـ class التى تساعد فى قرائة معلومات الـ configuration 
المحفوظة فى ملفات نصية و هى : 
        <link linkend="zend.config.classes.array"><code>Zend_Config_Array</code></link>,
        <link linkend="zend.config.classes.ini"><code>Zend_Config_Ini</code></link>, و
        <link linkend="zend.config.classes.xml"><code>Zend_Config_Xml</code></link>.
    </para>
    <para>
        تدعم <code>Zend_Config</code> نظام وراثة احادى و الذى يسمح للبيانات الخاصة بالـ configuration ان 
	تورث من قسم بيانات configorations الى اخر, إذاً يدعم <code>Zend_Config</code> النظام الشجرى 
	فى الوراثة و ذلك بدون قيد على طول الفروع, و كل فرع ابن يرث من اب واحد فقط.
    </para>
    <para>
        داخليا تقوم <code>Zend_Config</code> بتطبيق interfaces و هى Countable و Iteratore لتوفر وصول اسهل 
الى البيانات. يتم توفير البيانات لـ <code>Zend_Config</code> على هيئة associative array و التى من الممكن 
ان تكون متعددة الأبعاد.
class مساعد (مثل <code>Zend_Config_Ini</code>) هو من يوفر هذه الـ array لـ <code>Zend_Config</code> 
لكن هذا ليس اجباريا.
    </para>
    <note>
        تسمح <code>Zend_Config</code> بعمل تغييرات فى بيانات الـ configuration التى تم تحميلها الى الذاكرة , 
	و لكنها لا توفر امكانية حفظ هذه البيانات فى اى من وسائط حفظ البيانات , الأدوات التى تقوم بإنشاء و تعديل بيانات الـ 
configuration	 و حفظها فى وسائط حفظ بيانات هى خارج نطاق إطار عمل Zend , لكن يوجد العديد من الحلول مفتوحة 
	المصدر لإنشاء و تعديل بيانات الـ configuration و حفظها فى وسائط حفظ بيانات مختلفة و يمكنك الأستعانة بأى منها.
    </note>
    <example>
        <title>تحميل بيانات الـ Configuration من ملف INI</title>
        <para>
            فى المثال التالى سنقوم بتحميل بيانات الـ configuration من ملف INI و ذلك بإستخدام 
            <link linkend="zend.config.classes.ini"><code>Zend_Config_Ini</code></link>:
        </para>
        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Config.php';
require_once 'Zend/Config/Ini.php';
$config = new Zend_Config(Zend_Config_Ini::load('/path/to/config.ini', 'production'));
?>]]>   </programlisting>
        <para>
            الأن بيانات الـ configuration متوفرة و يمكن استخدامها من خلال الكائن المحفوظ فى <code>config$</code> , 
فلنفترض ان بيانات الـ configuration كانت تحتوى على معلومات الأتصال بقاعدة بيانات و هذه المعلومات كانت 
مسجلة فى ملف الـ INI بهذا الشكل :
        </para>
        <programlisting role="ini"><![CDATA[[production]
database.type     = pdo_mysql
database.host     = db.example.com
database.username = dbuser
database.password = secret
database.name     = dbname]]>
        </programlisting>
        <para>
            سيمكنك إنشاء إتصال مع قاعدة البيانات عن طريق :
        </para>
        <programlisting role="php"><![CDATA[<?php
$myApplicationObject->databaseConnect($config->database->type,
                                      $config->database->host,
                                      $config->database->username,
                                      $config->database->password,
                                      $config->database->name);
?>]]>   </programlisting>
        <para>
            كما رأيت فى المثال بالأعلى , يمكنك الوصول الى بيانات الـ configuration بإستخدام نفس طريقة قرائة قيمة 
حقل "preperty" من كائن "object" .
       </para>
    </example>
    <para>
        يمكنك إنشاء نسختك الخاصة من <code>Zend_Config</code> بسهولة لتضيف ميزات جديدة تحتاج إلبها, 
	فى المثال التالى قمنا بإنشاء نسختنا الجديدة عن طريق الوراثة من <code>Zend_Config</code> و إنشاء 
	method جديد بإسم <code>()dump</code> ليقوم بطباعة البيانات المحفوظة فى الكائن :
    </para>
    <programlisting role="php"><![CDATA[<?php
class MyConfig extends Zend_Config
{
    protected $_indent;

    public function dump()
    {
        $this->_indent = 0;
        echo "<pre>\n";
        $this->_dumpRecursor($this);
        echo "</pre>";
    }

    protected function _dumpRecursor($config)
    {
        foreach ($config as $key => $value) {
            echo str_repeat("    ", $this->_indent) . "$key =>";
            if ($value instanceof Zend_Config) {
                echo "\n";
                $this->_indent++;
                $this->_dumpRecursor($value);
                $this->_indent--;
            } else {
                echo " $value\n";
            }
        }
    }
}

$config = new MyConfig(Zend_Config_Ini::load('/path/to/config.ini', 'production'));

$config->dump();
?>]]></programlisting>
    <para>
        إذا استخدمنا البيانات من ملف الـ configuration السابق , سيطبع التالى :
    </para>
    <programlisting role="text"><![CDATA[<pre>
database =>
    type => pdo_mysql
    host => db.example.com
    username => dbuser
    password => secret
    name => dbname
</pre>]]>
    </programlisting>
</sect1>
<sect1 id="zend.config.classes.array">
    <title>Zend_Config_Array</title>
    <sect2 id="zend.config.classes.array.introduction">
        <title>مقدمة</title>
        توفر<code>Zend_Config_Array</code> للمطور  امكانية قرائة بيانات configuration محفوظة 
فى associative array متعددة الأبعاد , و من ثم استخدام هذه البيانات من خلال <code>Zend_Config</code>.
        <example>
            <title>بيانات الـ configuration المحفوظة فى array</title>
            <para>
                المثال التالى يوضح استخدام بسيط لـ <code>Zend_Config_Array</code> حيث سنقوم بتحميل بيانات 
configuration من array "مصفوفة" . قبل هذا نحتاج إلى إنشاء الـ array التى تحوى البيانات التى سيتم قرائتها :
            </para>
            <programlisting role="php"><![CDATA[<?php
// Production site configuration data
$config['production'] = array(
    'webhost' => 'www.example.com',
    'database' => array(
        'type'     => 'pdo_mysql',
        'host'     => 'db.example.com',
        'username' => 'dbuser',
        'password' => 'secret',
        'name'     => 'dbname'
    )
);

// Staging site configuration data inherits from production and
// overrides values as necessary
$config['staging'] = $config['production'];
$config['staging']['webhost'] = 'dev.example.com';
$config['staging']['database']['host'] = 'dev.example.com';
$config['staging']['database']['username'] = 'devuser';
$config['staging']['database']['password'] = 'devsecret';
?>]]>       </programlisting>
            <note>
                الـ array التى تحتوى على بيانات الـ configuration يجب ان تسمى <code>config$</code> فى ملف الـ php الذى سيتم تحميلها منه.
            </note>
            <para>
                فى المثال بالأعلى, تم وضع مثال لما اسميناه بالوراثة حيث ان القسم <code>production</code> تم حفظ قيمته 
	فى القسم <code>staging</code>, الأن اصبح الأمر سهلاً حيث سنقوم بتحميل البيانات عن طريق 
	<code>Zend_Config_Array</code> :
            </para>
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Config.php';
require_once 'Zend/Config/Array.php';

$config = new Zend_Config(Zend_Config_Array::load('/path/to/config.php', 'staging'));

echo $config->database->host; // prints "dev.example.com"
?>]]>       </programlisting>
        </example>
        <para>
        ملحوظة تستحق الذكر, بيانات الـ configuration محفوظة مباشرة فى مصفوفة PHP, بالتالى 
        كل قيمة بعد تحميلها ستحمل نفس نوع البيانات التى كانت عليه و هى فى <code>config$</code>
          
        </para>
        <programlisting role="php"><![CDATA[<?php
$config['staging']['debug']   = 'false'; // value has string type
$config['staging']['console'] = false; // value of boolean type
$config['staging']['timeout'] = 30; // value of integer type
?>]]>   </programlisting>
    </sect2>
</sect1>
<sect1 id="zend.config.classes.ini">
    <title>Zend_Config_Ini</title>
    <sect2 id="zend.config.classes.ini.introduction">
        <title>مقدمة</title>
        توفر <code>Zend_Config_Ini</code> للمطور امكانية قرائة بيانات الـ configuration التى قام بحفظها فى ملف 
INI , و من ثم سيتمكن من قرائتها عن طريق الـ properties الخاصة بالـ object الذى سينشئه من
 <code>Zend_Config</code>.
        <example>
            <title>بيانات الـ Configuration المحفوظة فى ملف INI</title>
            <para>
                هذا المثال يوضح مثال بسيط فى استخدام <code>Zend_Config_Ini</code> لتحميل بيانات configuration من 
ملف INI , لنفترض اننا نضع هذه البيانات فى ملف على المسار
                <code>path/to/config.ini/</code>:
            </para>
            <programlisting role="ini"><![CDATA[; Production site configuration data
[production]
webhost           = www.example.com
database.type     = pdo_mysql
database.host     = db.example.com
database.username = dbuser
database.password = secret
database.name     = dbname

; Staging site configuration data inherits from production and
; overrides values as necessary
[staging]
extends = production
database.host     = dev.example.com
database.username = devuser
database.password = devsecret]]>
            </programlisting>
            <note>
                لاحظ أن القواعد النحوية المتبعة فى كتابة محتويات ملف الـ INI هى نفسها التى تتوقعها دالة الـ PHP المسمى 
                <ulink url="http://php.net/parse_ini_file"><code>()parse_ini_file</code></ulink>
                و التى يستخدمها <code>Zend_Config_Ini</code>, إذا سمحت راجع الـ manual لتتعرف على السلوك الذى تتبعه 
<code>Zend_Config_Ini</code> فى عملها , مثل كيفية ترجمتها للقيم الخاصة مثل 
<code>true</code>,
 <code>false</code>,
 <code>yes</code>, 
<code>no</code> و   
 <code>null</code>.
            </note>
            <para>
                على حسب القواعد النحوية الخاصة بملفات الـ INI تم دعم امكانية الوراثة , و ذلك بأستخدام الكلمة المفتاحية 
<code>extends</code> , قيمة <code>extends</code> يجب ان تكون اسم القسم الذى سيتم الوراثة منه, 
و سيتم بعد ذلك تحميل البيانات من ملف الـ INI و ترجمتها على هذا الأساس :
            </para>
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Config.php';
require_once 'Zend/Config/Ini.php';

$config = new Zend_Config(Zend_Config_Ini::load('/path/to/config.ini', 'staging'));

echo $config->database->host; // prints "dev.example.com"
?>]]>       </programlisting>
        </example>
    </sect2>
</sect1>
<sect1 id="zend.config.classes.xml">
    <title>Zend_Config_Xml</title>
    <sect2 id="zend.config.classes.xml.introduction">
        <title>مقدمة</title>
        يوفر <code>Zend_Config_Xml</code> للمطور امكانية قرائة بيانات الـ configuration من ملف XML 
ذو بنية بسيطة , حيث سيكن فى استطاعته بعدها استخدام البيانات عن طريق قرائة قيم الـ properties فى الـ object 
الذى سينشئه من <code>Zend_Config</code> .
        <example>
            <title>بيانات الـ Configuration المحفوظة على هيئة XML</title>
            <para>
                هذا المثال يوضح مثال بسيط فى استخدام <code>Zend_Config_XML</code> لتحميل بيانات configuration 
من ملف XML , لنفترض اننا نضع هذه البيانات فى ملف على المسار
                <code>path/to/config.xml/</code>:
            </para>
            <programlisting role="xml"><![CDATA[<?xml version="1.0"?>
<config>
    <production>
        <webhost>www.example.com</webhost>
        <database>
            <type>pdo_mysql</type>
            <host>db.example.com</host>
            <username>dbuser</username>
            <password>secret</password>
            <name>dbname</name>
        </database>
    </production>
    <staging extends="production">
        <database>
            <host>dev.example.com</host>
            <username>devuser</username>
            <password>devsecret</password>
        </database>
    </staging>
</config>]]></programlisting>
            <para> 
               تم دعم الوراثة لتتوافق مع القواعد النحوية الخاصة بالـ XML عن طريق إستخدام الـ attribute المسمى 
<code>extends</code> , قيمة الـ attribute المسمى <code>extends</code> يجب ان تكون اسم القسم 
الذى سيتم الوراثة منه. الأن سنقوم بتحميل البيانات من ملف الـ XML :
            </para>
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Config.php';
require_once 'Zend/Config/Xml.php';

$config = new Zend_Config(Zend_Config_Xml::load('/path/to/config.xml', 'staging'));

echo $config->database->host; // prints "dev.example.com"
?>]]>       </programlisting>
            <note>
                البيانات التى يتم قرائتها عن طريق <code>Zend_Config_Xml</code> يتم اعتبارها دائما على انها من النوع string .
            </note>
        </example>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->