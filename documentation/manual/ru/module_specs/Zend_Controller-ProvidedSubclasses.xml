<sect1 id="zend.controller.providedsubclasses">
    <title>Готовые подклассы<!--Provided Subclasses--></title>

    <sect2 id="zend.controller.providedsubclasses.introduction">
        <title>Введение</title>

        <para>
            Zend Framework предоставляет некоторые альтернативы принятым по
            умолчанию классам, в которые входят объекты запросов, маршрутизаторы
            и объекты ответов. 
<!--
            Zend Framework provides several alternatives to the default classes
            provided, including alternate request objects, routers, and response
            objects.
-->
        </para>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.request.http">
        <title>Zend_Controller_Request_Http</title>

        <sect3 id="zend.controller.providedsubclasses.request.http.introduction">
            <title>Введение</title>

            <para>
                <code>Zend_Controller_Request_Http</code> предоставляет
                объект запроса для использования в среде HTTP.
                <code>Zend_Controller_Request_Http</code> является классом
                запроса, используемым <code>Zend_Controller_Dispatcher</code>
                по умолчанию.   
<!--
                <code>Zend_Controller_Request_Http</code> provides a request
                object for use in an HTTP environment.
                <code>Zend_Controller_Request_Http</code>
                is the default request class utilised by
                <code>Zend_Controller_Dispatcher</code>.
-->
            </para>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.request.http.dataaccess">
            <title>Доступ к данным запроса<!--Accessing Request Data--></title>

            <para>
                <code>Zend_Controller_Request_Http</code> инкапсулирует доступ
                к релевантным значениям, таким, как ключевое имя и значение
                для переменных маршрутизатора и все дополнительные параметры,
                полученные из URI. Посредством передачи к
                <code>Zend_Controller_Request_Http</code> он также предоставяет
                доступ к значениям, содержащимся в суперглобальных переменных
                как к открытым членам и управляет текущим базовым URL и URI
                запроса. Суперглобальные значения не могут быть установлены в
                объекте запроса, за исключением методов setParam/getParam
                для установки или извлечения пользовательских переменных. 
<!--
                <code>Zend_Controller_Request_Http</code> encapsulates access
                to relevant values such as the key name and value for the
                controller and action router variables, and all additional
                parameters parsed from the URI. By proxying to
                <code>Zend_Controller_Request_Http</code> it additionally allows
                access to values contained in the superglobals as public
                members and manages the current Base URL and Request URI.
                Superglobal values cannot be set on a request object, instead
                use the setParam/getParam methods to set or retrieve user 
                parameters.
-->
            </para>

            <note>
                <title>Суперглобальные данные<!--Superglobal data--></title>
                <para>
                    Когда обращаетесь к суперглобальным переменным через
                    <code>Zend_Controller_Request_Http</code> как к открытым
                    свойствам объекта, необходимо помнить, что имя свойства
                    (ключ суперглобального массива) проверяется на наличие в
                    суперглобальных массивах в определенном порядке: 1. GET,
                    2. POST, 3. COOKIE, 4. SERVER, 5. ENV.
<!--
                    When accessing superglobal data through
                    <code>Zend_Controller_Request_Http</code>
                    as public member properties, it is necessary to keep in
                    mind that the property name (superglobal array key) is
                    matched to a superglobal in a specific order of precedence:
                    1. GET, 2. POST, 3. COOKIE, 4. SERVER, 5. ENV.
-->
                </para>
            </note>

            <para>
                К определенным суперглобальным массивам можно также обращаться
                через открытые методы. Например, можно получить необработанное
                значение <code>$_POST['user']</code> посредством вызова метода
                <code>getPost('user')</code> в объекте запроса.
<!--
                Specific superglobals can be accessed using a public method as an
                alternative. For example, the raw value of <code>$_POST['user']</code>
                can be accessed by calling <code>getPost('user')</code> on the
                request object.
-->
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.request.http.baseurl">
            <title>Базовый URL и поддиректории<!--Base Url and subdirectories--></title>

            <para>
                <code>Zend_Controller_Request_Http</code> позволяет использовать
                Zend_Controller_RewriteRouter в поддиректориях.
                Zend_Controller_Request_Http будет пытаться автоматически 
                определить ваш базовый URL и установить его.
<!--
                <code>Zend_Controller_Request_Http</code> allows
                Zend_Controller_RewriteRouter to be used in subdirectories.
                Zend_Controller_Request_Http will attempt to automatically
                detect your base URL and set it accordingly.
-->
            </para>

            <para>
                Например, если вы храните файл загрузки <code>index.php</code> в
                поддиректории веб-сервера, которая называется
                <code>/projects/myapp/index.php</code>, то базовый URL
                (базовый адрес перезаписи) должен быть установлен в
                <code>/projects/myapp</code>. Эта стока будет исключаться из
                начала пути перед любыми вычислениями соответствий маршрутов.
                Это освобождает от необходимости ее указывания в начале каждого
                маршрута. Маршрут <code>'user/:username'</code> будет
                соответствовать URI вида
                <code>http://localhost/projects/myapp/user/martel</code> и
                <code>http://example.com/user/martel</code>.
<!--
                For example, if you keep your
                <code>index.php</code> in a webserver subdirectory named
                <code>/projects/myapp/index.php</code>, base URL (rewrite base)
                should be set to <code>/projects/myapp</code>. This string will
                then be stripped from the beginning of the path before
                calculating any route matches. This frees one from the necessity
                of prepending it to any of your routes. A route of
                <code>'user/:username'</code> will match URIs like
                <code>http://localhost/projects/myapp/user/martel</code> and
                <code>http://example.com/user/martel</code>.
-->
            </para>

            <note>
                <title>Определение URL чувствительно к регистру<!--URL detection is case sensitive--></title>
                <para>
                    Автоматическое определение базового URL является
                    чувствительно к регистру, поэтому убедитесь, что ваш URL
                    соответствует имени поддиректории в файловой системе (даже
                    на платформе Windows). Если не соответствует, то будет
                    вызываться действие <code>noRoute</code>. 
<!--
                    Automatic base URL detection is case sensitive, so make sure
                    your URL will match a subdirectory name in a filesystem
                    (even on Windows machines). If it doesn't you will get to
                    noRoute action.
-->
                </para>
            </note>

            <para>
                Если базовый URL определяется некорректно, вы можете заменить
                его своим базовым путем с помощью метода
                <code>setBaseUrl()</code>, который есть в классах
                <code>Zend_Http_Request</code>,
                <code>Zend_Controller_Request_Http</code> и
                <code>Zend_Controller_Front</code>. Легче всего установить его
                через  <code>Zend_Controller_Front</code>, который передаст его
                объекту запроса. Пример установки своего базового URL: 
<!--
                Should base URL be detected incorrectly you can override it
                with your own base path with the help of the
                <code>setBaseUrl()</code> method of either the
                <code>Zend_Http_Request</code> class, the
                <code>Zend_Controller_Request_Http</code> class, or the
                <code>Zend_Controller_Front</code> class. The easiest
                method is to set it in <code>Zend_Controller_Front</code>, 
                which will proxy it into the request object. Example usage to
                set a custom base URL:
-->
            </para>

            <programlisting role="php"><![CDATA[
$router     = new Zend_Controller_RewriteRouter();
$controller = Zend_Controller_Front::getInstance();
$controller->setControllerDirectory('./application/controllers')
           ->setRouter($router)
           ->setBaseUrl('/projects/myapp'); // set the base url!
$response   = $controller->dispatch();]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.rewriterouter">
        <title>Zend_Controller_RewriteRouter</title>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.introduction">
            <title>Введение</title>
            <para>
                <code>Zend_Controller_RewriteRouter</code> является новой
                версией маршрутизатора фреймворка. Маршрутизация является
                процессом принятия конечной точки URI (той части URI, которая
                идет после базового URL) и ее разложения на параметры
                для определения того, какой контроллер и какое действие этого
                контроллера должны получить запрос. Значения контроллера,
                действия и необязательных параметров упаковывается в объект
                <code>Zend_Controller_Request_Http</code>, который затем
                обрабатывается <code>Zend_Controller_Dispatcher</code>.
                Маршрутизация производится только один раз – когда вначале
                получен запрос и до того, как первый контроллер будет запущен.
<!--
                <code>Zend_Controller_RewriteRouter</code> is a new
                version of the framework
                router. Routing is the process of taking a URI endpoint (that 
                part of the URI which comes after the base URL) and
                decomposing it into parameters to determine which
                controller and action of that
                controller should receive the request. This value of the
                controller, action and other parameters is packaged into a
                <code>Zend_Controller_Request_Http</code> object which is
                then processed by <code>Zend_Controller_Dispatcher</code>.
                Routing occurs only once: when the request is initially
                received and before the first controller is dispatched.
-->
            </para>

            <para>
                <code>Zend_Controller_RewriteRouter</code> предназначен для
                того, чтобы обеспечить функциональность, подобную mod_rewrite,
                с применением чистого php. Он отчасти основан на маршрутизации
                в Ruby on Rails и не требует каких-либо предварительных знаний
                о перезаписи URL веб-сервером. Он спроектирован для работы с
                единственным правилом mod_rewrite, пример которого приведен
                ниже:
<!--
                <code>Zend_Controller_RewriteRouter</code> is designed to allow
                for mod_rewrite like functionality using pure php structures. It
                is very loosely based on Ruby on Rails routing and does not
                require any prior knowledge of webserver URL rewriting. It is
                designed to work with a single Apache mod_rewrite rule (one of):
-->
            </para>

            <programlisting role="php"><![CDATA[
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php]]></programlisting>

            <para>
            или:
            </para>

            <programlisting role="php"><![CDATA[
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 ]]></programlisting>
            
            <para>
                RewriteRouter может также использоваться с веб-сервером IIS,
                если
                <ulink url="http://www.isapirewrite.com">Isapi_Rewrite</ulink>
                был установлен как расширение Isapi со следующими правилами
                перезаписи: 
<!--
                The RewriteRouter can also be used with the IIS webserver if
                <ulink url="http://www.isapirewrite.com">Isapi_Rewrite</ulink>
                has been installed as an Isapi extension with the following
                rewrite rule:
-->
            </para>

            <programlisting role="php"><![CDATA[
RewriteRule ^[\w/\%]*(?:\.(?!(?:js|ico|gif|jpg|png|css)$)[\w\%]*$)? /index.php [I]]]></programlisting>

            <note>
                <title>IIS Isapi_Rewrite</title>
                <para>
                    Если используется IIS, то
                    <code>$_SERVER['REQUEST_URI']</code>
                    не будет существовать, либо будет установлен как пустая
                    строка. В этом случае
                    <code>Zend_Controller_Request_Http</code> попытается
                    использовать <code>$_SERVER['HTTP_X_REWRITE_URL']</code>,
                    значение которого устанавливается расширением Isapi_Rewrite.  
<!--
                    When using IIS, <code>$_SERVER['REQUEST_URI']</code>
                    will either not exist, or be set as an empty string. In
                    this case, <code>Zend_Controller_Request_Http</code> will
                    attempt to use the
                    <code>$_SERVER['HTTP_X_REWRITE_URL']</code>
                    value set by the Isapi_Rewrite extension.
-->
                </para>
            </note>

            <para>
               Если используется Lighttpd, то валидным будет следующее
               правило перезаписи:
<!--
               If using Lighttpd, the following rewrite rule is valid:
-->
            </para>

            <programlisting role="php"><![CDATA[
url.rewrite-once = ( ".*\.(js|ico|gif|jpg|png|css)$" => "$0", "" => "/index.php")]]></programlisting>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.usage">
            <title>Использование роутера<!--Using a router--></title>

            <para>
                Чтобы использовать RewriteRouter, нужно инстанцировать его,
                добавить маршруты и установить его в контроллере. Следующий код
                иллюстрирует эту процедуру:
<!--
                To properly use the RewriteRouter you have to instantiate it,
                add some user defined routes and inject it into the controller.
                The following code illustrates the procedure:
-->
            </para>

            <programlisting role="php"><![CDATA[
/* Создание маршрутизатора */

$router = new Zend_Controller_RewriteRouter();
$router->addRoute(
	'user',
	new Zend_Controller_Router_Route('user/:username', array('controller' => 'user', 'action' => 'info'))
);

/* Установка его в контроллере */

$ctrl = Zend_Controller_Front::getInstance();
$ctrl->setRouter($router);]]></programlisting>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.basic">
            <title>Основные маршруты<!--Basic Routes--></title>

            <para>
                Сущностью RewriteRouter является определение пользовательских
                маршрутов. Маршруты создаются вызовом метода
                <code>addRoute()</code> и передачей ему нового
                экземпляра <code>Zend_Controller_Router_Route</code>: 
<!--
                The heart of the RewriteRouter is the definition of user defined
                routes. Routes are created by calling the addRoute method of
                RewriteRouter and passing in a new instance of
                <code>Zend_Controller_Router_Route</code>:
-->
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute('user', new Zend_Controller_Router_Route('user/:username'));]]></programlisting>

            <para>
	              Первым параметром является имя маршрута. Сейчас он
                является избыточным, но в будущем будет использоваться в
                вспомогательном классе вида (view) для легкой генерации URL
                в ваших видах. Если нужно воспользоваться ранее
                сконфигурированным маршрутом, то можно получить его
                с помощью метода <code>getRoute</code>. Вторым параметром
                является экземпляр <code>Zend_Controller_Router_Route</code>.
<!--
                The first parameter is the name of the route. It is redundant at
                the moment of writing but will be used in the future in a URL
                view helper to allow for easy URL generation in your views.
                Should you need to make use of a previously configured named
                route, you can retrieve it with the getRoute method of the
                RewriteRouter. The second parameter is an instance of
                <code>Zend_Controller_Router_Route</code>.
-->
            </para>

            <para>
                Первым параметром для конструктора
                <code>Zend_Controller_Router_Route</code> является маршрут,
                который будет сопоставляться с URL – например, маршрут в примере
                выше будет соответствовать
                <code>http://example.com/user/martel</code>. Двоеточие в
                маршруте обозначает переменную URL. После успешной
                маршрутизации значения всех определенных переменных будут
                добавлены в Zend_Controller_Request. К ним можно будет получить
                доступ через методы Zend_Controller_Request::getParam или
                Zend_Controller_Action::_getParam. В нашем примере параметру под
                именем username будет присвоено значение 'martel'.
<!--
                The first parameter for the
                <code>Zend_Controller_Router_Route</code>
                constructor is a route that will be matched to a URL -
                for example, the above route will match
                <code>http://example.com/user/martel</code>. The colon in a
                route marks a URL variable. After the successful routing, values 
                of all defined variables will be injected to the
                Zend_Controller_Request.
                After that they will be accessible through a
                Zend_Controller_Request::getParam or 
                Zend_Controller_Action::_getParam methods. In our example a
                parameter named username will be set to a value of 'martel'.
-->
            </para>

            <note>
                <title>Порядок сопоставления<!--Reverse matching--></title>
                <para>
                    Маршруты сопоставляются в обратном порядке, поэтому
                    удостоверьтесь, что наиболее общие маршруты определены
                    первыми.
<!--
                    Routes are matched in reverse order so make sure your most
                    generic routes are defined first.
-->
                </para>
            </note>

            <note>
                <title>Использование символов<!--Character usage--></title>
                <para>
	                  Текущая реализация позволяет использовать любые символы,
	                  кроме прямой косой черты (/), в идентификаторе переменной,
                    но сильно рекомендуется использовать в них только символы,
                    допустимые для переменных в php. Есть вероятность, что в
                    будущем реализация изменится, и это может вызвать ошибки в
                    вашем коде.
<!--
                    For now the current implementation allows for use of any
                    characters except a slash (/) as a variable identifier but
                    it is strongly recommended that one uses only php variable
                    friendly characters. In future the implementation will
                    probably be altered and this may introduce bugs to your
                    code.
-->
                </para>
            </note>

            <para>
            	  Есть две специальные переменные, которые можно использовать в
            	  маршрутах — ':controller' и ':action'. Эти специальные
                переменные могут использоваться для получения контроллера и/или
                действия, выбранных в URL. Переменная ':action' всегда должна
                быть определена в маршруте или как параметр по умолчанию.
                Переменная 'controller' по умолчанию будет
                <code>IndexController</code>, если не была определена.
<!--
                There are two special variables which can be used in your routes
                - ':controller' and ':action'. These special variables will be
                used to find a controller and/or an action chosen in the URL.
                The ':action' variable must always be defined either in the
                route or as a default parameter. The ':controller' variable will
                default to the IndexController if it is not defined.
-->
            </para>

            <note>
                <title>Специальные переменные<!--Special variables--></title>
                <para>
                    Имена специальных переменных могут отличаться, если вы
                    измените значения по умолчанию в
                    <code>Zend_Controller_Request_Http</code> через методы
                    setControllerKey и setActionKey.
<!--
                    Names of these special variables may be different if you
                    choose to alter the defaults in 
                    <code>Zend_Controller_Request_Http</code> 
                    by the means of setControllerKey and setActionKey methods.
-->
                </para>
            </note>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'user', new Zend_Controller_Router_Route(':controller/:action')
);]]></programlisting>

            <para>
	              Если вы наберете в вашем броузере адрес
                'http://example.com/news/latest', то при сопоставлении с таким
                маршрутом <code>Zend_Controller_Dispatcher</code> вызовет метод
                latestAction в вашем классе контроллера NewsController.
<!--
                If you point your browser to 'http://example.com/news/latest'
                with this route defined the
                <code>Zend_Controller_Dispatcher</code> will invoke the
                latestAction method of your NewsController class.
-->
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.variable-defaults">
            <title>Значения по умолчанию<!--Variable defaults--></title>

            <para>
                Любая переменная в маршруте может иметь значение по умолчанию.
                Для его определения вы должны добавить второй параметр для
                конструктора <code>Zend_Controller_Router_Route</code>. Этот
                параметр является массивом с ключами, соответствующими именам
                переменных, и значениями, соответствующими желаемым значениям
                этих переменных по умолчанию.
<!--
                Every variable in the route can have a default. To provide it
                you have to add a second parameter to the
                <code>Zend_Controller_Router_Route</code> constructor. This
                parameter is an array with keys as variable names and
                values as desired defaults.
-->
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive', new Zend_Controller_Router_Route('archive/:year', array('year' => 2006))
);]]></programlisting>

            <para>
                Этот маршрут будет соответствовать таким URL, как
                'http://example.com/archive/2005' и
                'http://example.com/archive'. В последнем случае переменная
                ':year' будет иметь значение 2006. 
<!--
                What may not be clearly visible is that the above route will
                match URLs like 'http://example.com/archive/2005' and
                'http://example.com/archive'. In the latter case the variable
                year will have a value of 2006.
-->
            </para>

            <para>
                В примере выше результатом будет только добавление переменной
                ':year' в запрос. Маршрутизация не будет выполняться корректно
                до тех пор, пока не будут установлены параметры контроллера и
                действия. Для того, чтобы сделать этот код более полезным, вы
                должны указать конкретные контроллер и действие как значения по
                умолчанию.
<!--
                The above example will only result in injecting a year variable 
                to the request. No routing will take place since controller and 
                action parameters are not set. To make it more usable you have
                to provide a valid controller and a valid action as defaults.
--> 
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' => 2006, 'controller' => 'archive', 'action' => 'show')
);]]></programlisting>

            <para>
                Результатом будет вызов действия showAction в классе контроллера
                ArchiveController. 
<!--
      				  This route will then result in dispatching to showAction of
                ArchiveController.
-->
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.variable-requirements">
            <title>Требования к переменным<!--Variable requirements--></title>

            <para>
	              Можно добавить третий параметр в вызове конструктора
                <code>Zend_Controller_Router_Route</code>, в котором 
                устанавливаются требования к переменным. Они указываются в виде
                регулярных выражений.
<!--
                One can add a third parameter to the 
                <code>Zend_Controller_Router_Route</code>
                constructor where variable requirements can
                be set. These are defined as regular expressions:
-->
            </para>

            <programlisting role="php"><![CDATA[
$router->addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' => 2006), array('year' => '\d+'))
);]]></programlisting>

            <note>
                <title>Особенности маршрутизации<!--Routing behavior--></title>
                <para>
	                  В отличие от Ruby on Rails, ZF RewriteRouter будет
                    использовать значение по умолчанию, если нет соответствия
                    требованиям, определенным в третьем параметре. Таким
                    образом, в случае URL
                    <code>http://example.com/archive/test</code>
                    год будет равен 2006. Это поведение может быть изменено в
                    будущем, так как все еще было предметом обсуждения во время
                    написания этой документации.
<!--
                    Unlike Ruby on Rails, ZF RewriteRouter will match a route
                    and use a default when a third parameter variable
                    requirement is not met. So the URL of
                    'http://example.com/archive/test' will match the above route
                    and set the year to 2006. This functionality may be altered
                    in the future as it is being discussed at the moment of
                    writing of this documentation.
-->
                </para>
            </note>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.rewritebase">
            <title>Базовый URL и поддиректории<!--Base URL and subdirectories--></title>

            <para>
                В отличие от основного маршрутизатора Router,
                RewriteRouter может использоваться в поддиректориях.
                Существовавший ранее метод setRewriteBase() теперь не
                доступен. Вместо этого базовый URL автоматически
                определяется в Zend_Controller_Request_Http.     
<!--
                Unlike the original Router, the current RewriteRouter can be 
                used in subdirectories. The original RewriteRouter's
                setRewriteBase() method is no longer available however.
                Instead the base URL will be automatically detected by
                Zend_Controller_Request_Http.
-->
            </para>

            <para>
                Если базовый URL определяется некорректно, то вы можете
                переопределить его через метод setBaseUrl() объекта
                Zend_Controller_Request_Http (см.
                <xref linkend="zend.controller.providedsubclasses.request.http.baseurl" />).
<!--
                Should the base URL be detected incorrectly you can override it
                with your own base path with the help of
                Zend_Controller_Request_Http by calling the setBaseUrl() method
                (see <xref linkend="zend.controller.providedsubclasses.request.http.baseurl" />).
-->
            </para>

        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.default-routes">
            <title>Маршруты по умолчанию<!--Default routes--></title>

            <para>
                <code>Zend_Controller_RewriteRouter</code> изначально
                сконфигурирован с одним маршрутом по умолчанию для обеспечения
                совместимости с первой версией маршрутизатора. Он будет
                соответствовать URI вида <code>'controller/action'</code> и по
                умолчанию будет также соответствовать любым дополнительным
                параметрам, добавленным в конец URI. Он сконфигурирован как:
<!--
                Zend_Controller_RewriteRouter is preconfigured with one default
                route to provide compatibility with the first version of the 
                router. It will match URIs in the shape of
                <code>'controller/action'</code>  and will also match any
                additional parameters appended to the URI by default.
                It is configured as:
-->
            </para>

            <programlisting role="php"><![CDATA[
// Маршрут для совместимости с первой версией маршрутизатора
$compat = new Zend_Controller_Router_Route(':controller/:action/*', array('controller' => 'index', 'action' => 'index'));
$this->addRoute('default', $compat);]]></programlisting>

            <note>
                <title>Сопоставление URI<!--Matching URIs--></title>
                <para>
                    Zend_Controller_RewriteRouter сконфигурирован для обратной
                    совместимости. Он будет автоматически использовать маршрут
                    <code>controller/action</code> с дополнительными
                    параметрами. Дополнительные параметры не требуют добавления
                    новых маршрутов, если они не должны иметь значений по
                    умолчанию или требований к переменным. Эти дополнительные
                    параметры будут доступны через метод
                    Zend_Controller_Action::_getParam.
<!--
                    Zend_Controller_RewriteRouter is configured for backwards
                    compatibility. It will automatically match <code>controller/action</code>
                    URIs with additional parameters. The additional parameters do not
                    require the addition of new routes unless they must have default values
                    or variable requirements. These additional parameters will be accessible
                    from the Zend_Controller_Action::_getParam method.
-->
                </para>
            </note>

            <para>
                Если вы не хотите использовать маршрут по умолчанию, то можете
                удалить его, используя метод <code>removeDefaultRoutes()</code>:
<!--
                If you do not want the default route in your routing schema, you
                may remove it using <code>removeDefaultRoutes()</code>:
-->
            </para>

            <programlisting role="php"><![CDATA[
// Удаление маршрута по умолчанию
$router->removeDefaultRoutes();]]></programlisting>

        </sect3>    

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.static-routes">
            <title>Статические маршруты<!--Static Routes--></title>

            <para>
                В примерах выше все импользуемые маршруты были динамическими –
                маршруты, которые содержат паттерны для сопоставления с URI.
                Тем не менее, определенные маршруты могут быть
                неизменными, и применение к ним методов регулярных выражений
                будет совершенно излишним. Решением данной ситуации будет
                использование статических маршрутов:
                
<!--
                The examples above all use dynamic routes - routes that contain
                patterns to match against. Sometimes, however, a particular
                route is set in stone, and firing up the regular expression
                engine would be overkill. The answer to this situation is to use
                static routes:
-->
            </para>

            <programlisting role="php"><![CDATA[
$loginRoute = new Zend_Controller_Router_StaticRoute('login', array('controller' => 'login', 'action' => 'form'));
$router->addRoute('login', $static);
]]></programlisting>
        </sect3>

        <sect3 id="zend.controller.providedsubclasses.rewriterouter.add-config">
            <title>Использование Zend_Config вместе с RewriteRouter<!--Using Zend_Config with the RewriteRouter--></title>

            <para>
                Иногда было бы более удобным обновлять конфигурационные данные
                для новых маршрутов, чем изменять код. Это возможно через метод
                <code>addConfig()</code>. По существу, вы создаете конфигурацию,
                совместимую с Zend_Config, считываете ее в своем коде и
                передаете RewriteRouter.
<!--
                Sometimes its more convenient to update a configuration file
                with new routes than to change the code. This is possible via
                the <code>addConfig()</code> method. Basically, you create a
                Zend_Config-compatible configuration, and in your code read it
                in and pass it to the RewriteRouter:
-->
            </para>

            <programlisting role="php"><![CDATA[
/**
 * Пример INI:
 * routes.archive.route = "archive/:year/*"
 * routes.archive.defaults.controller = archive
 * routes.archive.defaults.action = show
 * routes.archive.defaults.year = 2000
 * routes.archive.reqs.year = "\d+"
 * 
 * routes.news.type = "Zend_Controller_Router_StaticRoute"
 * routes.news.route = "news"
 * routes.news.defaults.controller = "news"
 * routes.news.defaults.action = "list"
 */
$config = new Zend_Config_Ini($file);
$router = new Zend_Controller_RewriteRouter();
$router->addConfig($config, 'routes');
]]></programlisting>

            <para>
                В примере выше мы говорим маршрутизатору, чтобы он использовал
                раздел 'routes' в файле INI для определения своих маршрутов.
                Ключ первого уровня в этом разделе используется для имени
                маршрута, в примере выше определяются маршруты 'archive' и
                'news'. Каждый маршрут требует, как минимум, запись 'route',
                одну или более записей 'defaults', необязательно может быть одна
                или более записей 'reqs' (сокращение от 'required'). Все это
                соответствет трем аргументам, предоставляемым объекту
                <code>Zend_Controller_Router_Route_Interface</code>.
                Опция 'type' может использоваться для определения класса,    
                используемого для данного маршрута, по умолчанию используется
                класс <code>Zend_Controller_Router_Route</code>. В примере выше
                для маршрута 'news' должен использоваться класс
                <code>Zend_Controller_Router_StaticRoute</code>.    
                
<!--
                In the above example, we tell the router to use the 'routes'
                section of the INI file to use for its routes. Each first-level
                key under that section will be used to define a route name; the
                above example defines the routes 'archive' and 'news'. Each
                route then requires, minimally a 'route' entry and one or more
                'defaults' entries; optionally one or more 'reqs' (short for
                'required') may be provided. All told, these correspond to the
                three arguments provided to a <code>Zend_Controller_Router_Route_Interface</code> 
                object. An option key, 'type', can be used to specify the route
                class type to use for that particular route; by default, it uses
                <code>Zend_Controller_Router_Route</code>. In the example above,
                the 'news' route is defined to use
                <code>Zend_Controller_Router_StaticRoute</code>.
-->
            </para>
        </sect3>
    
        <sect3 id="zend.controller.providedsubclasses.rewriterouter.modules">
            <title>Использование RewriteRouter с модульными компонентами MVC<!--Using RewriteRouter with modular MVC components--></title>

            <para>
                Также доступна версия RewriteRouter с учетом использования
                модулей. Она работает в точности так же, как 
                Zend_Controller_RewriteRouter, но имеет путь
                ':module/:controller/:action/*' для маршрута, используемого по
                умолчанию.   
<!--
                A module aware version of the RewriteRouter is also available,
                Zend_Controller_ModuleRewriteRouter. It works in precisely the
                same fashion as Zend_Controller_RewriteRouter, but has for the
                default route the path ':module/:controller/:action/*'.
-->
            </para>

            <para>
                За более подробной информацией см.
                <xref linkend="zend.controller.modular">документацию по модульной структуре директорий</xref>.
<!--
                See the <xref linkend="zend.controller.modular">Conventional
                Modular directory structure documentation</xref> for more
                information.
--> 
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.response.http">
        <title>Zend_Controller_Response_Http</title>

        <para>
            <code>Zend_Controller_Response_Http</code> является объектом ответа,
            пригодным к использованию в среде HTTP. Он содержит методы для
            установки, получения и удаления заголовков, а также метод
            <code>__toString()</code>, который отправляет все заголовки
            одновременно до того, как будет возвращено содержимое ответа. 
<!--
            <code>Zend_Controller_Response_Http</code> is a response object
            suitable for use in an HTTP environment. It contains methods for
            setting, retrieving, and clearing headers, and the
            <code>__toString()</code> method sends all headers at once before
            returning the response content.
-->
        </para>

        <para>
            <code>setHeader()</code> принимает два аргумента – тип заголовка и
            значение заголовка. Если передан третий необязательный параметр и он
            имеет значение <code>true</code>, то производится принудительная
            замена значения заголовка с тем же типом, если он уже был
            зарегистрирован.
<!--
            <code>setHeader()</code> takes two arguments, a header type and the
            header value. A third, optional parameter, if passed and true, will
            force the new header to replace any other headers registered with
            that type.
-->
        </para>
    </sect2>

    <sect2 id="zend.controller.providedsubclasses.response.cli">
        <title>Zend_Controller_Response_Cli</title>

        <para>
            <code>Zend_Controller_Response_Cli</code> является объектом ответа,
            подходящим для использования в среде CLI. Он не имеет методов для
            управления заголовками и просто возвращает все содержимое ответа при
            вызове метода <code>__toString()</code>. 
<!--
            <code>Zend_Controller_Response_Cli</code> is a response object
            suitable for use in an CLI environment. It has no methods for
            handling headers, and simply returns all body content when
            <code>__toString()</code> is invoked.
-->
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
