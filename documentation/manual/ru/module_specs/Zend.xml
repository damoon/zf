<sect1 id="zend.introduction">
    <title>Введение</title>
    <para>
    Класс Zend - основной класс Zend Framework. Он исходит из следования фреймворком принципу
    DRY (Don't Repeat Yourself - не повторяйся). Класс содержит только статические методы, и эти методы
    содержат необходимый для большинства компонент функционал.
    </para>
</sect1>

<sect1 id="zend.loadfile">
    <title>Zend::loadFile()</title>

    <para>
    <code>Zend::loadFile()</code> загружает PHP-файл, который может содержать любой PHP код. Это
    обертка для PHP функции <ulink url="http://php.net/include"><code>include()</code></ulink>,
    генерирующая исключение <code>Zend_Exception</code> в случае ошибки.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
loadFile($filename, $dirs=null, $once=false)

?>]]></programlisting>

    <para>Аргумент <code>$filename</code> задает имя файла для загрузки, он не должен содержать путь к файлу.
    Для <code>$filename</code> выполняется проверка на безопасность.
    <code>$filename</code> должен содержать только алфавитно-цифровые символы, тире ("-"), знак
    подчеркивания ("_") или точку ("."). На аргумент <code>$dirs</code> эти ограничения не
    распространяются.
    </para>

    <para>Аргумент <code>$dirs</code> задает директории для поиска файла. Если равен
    <code>NULL</code>, то поиск будет производиться только в <code>include_path</code>.
    Если является строкой или массивом, поиск будет производиться в директории (или директориях, соответственно),
    затем в include_path.
    </para>

    <para>
    Аргумент булевого типа <code>$once</code> определяет, какую PHP функцию использовать для загрузки 
    файлов - <ulink url="http://php.net/include"><code>include()</code></ulink> или <ulink
    url="http://php.net/include_once"><code>include_once()</code></ulink>.
    </para>
</sect1>

<sect1 id="zend.loadclass">
    <title>Zend::loadClass()</title>
    <para>
    <code>Zend::loadClass()</code> загружает PHP-файл, имя которого сформировано как
    "<code>$className.php</code>", затем проверяет наличие класса <code>$className</code>.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
loadClass($class, $dirs)

?>]]></programlisting>

    <para>
    Если файл не найден или класс не существует, генерируется исключение <code>Zend_Exception</code>.
    Для загрузки используется функция <code>Zend::loadFile()</code>, ей непосредственно передается
    аргумент <code>$dirs</code>.
    </para>

    <para>
    Если вы запросили класс со знаками подчеркивания ("_") в имени и <code>$dirs</code> равен
    <code>NULL</code> (значение по умолчанию), то <code>Zend::loadClass()</code> будет автоматически находить
    <code>$dirs</code> из имени класса посредством замены знаков подчеркивания на разделители директорий.
    Например, если имя класса - <code>Zend_Example_Class</code>, то оно будет преобразовано в путь
    <code>Zend/Example/Class.php</code>.
    </para>
</sect1>

<sect1 id="zend.loadinterface">
    <title>Zend::loadInterface()</title>
    <para>
    <code>Zend::loadInterface()</code> работает так же, как и <code>Zend::loadClass()</code>, за исключением 
    того, что она загружает интерфейсы.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
loadInterface($interface, $dirs)

?>]]></programlisting>

    <para>
    Метод <code>Zend::loadClass()</code> не может использоваться для загрузки интерфейсов из-за того,
    что PHP функция <ulink url="http://php.net/class_exists"><code>class_exists()</code></ulink> не может
    проверять наличие интерфейсов (начиная с PHP 5.0.2). Вместо этого используйте
    <code>Zend::loadInterface()</code>.
    </para>

    <para>
    Если вы запросили интерфейс со знаками подчеркивания в имени и <code>$dirs</code> равен <code>NULL</code>
    (значение по умолчанию), <code>Zend::loadInterface()</code> будет автоматически находить
    <code>$dirs</code> из имени интерфейса  посредством замены знаков подчеркивания на разделители
    директорий. Например, если имя интерфейса - <code>Zend_Example_Interface</code>, то оно будет преобразовано
    в путь <code>Zend/Example/Interface.php</code>.
    </para>
</sect1>

<sect1 id="zend.isreadable">
    <title>Zend::isReadable()</title>

    <para>Возвращает <code>TRUE</code>, если файл доступен для чтения, иначе <code>FALSE</code>.</para>

    <programlisting role="php"><![CDATA[<?php
	
isReadable($filename)

?>]]></programlisting>

    <para>Аргумент <code>$filename</code> задает имя файла для проверки, он может содержать путь к нему.
    Метод является оберткой для PHP функции
    <ulink url="http://php.net/is_readable"><code>is_readable()</code></ulink>. PHP функция не ищет в
    <code>include_path</code>, в то время как <code>Zend::isReadable()</code> делает это.
    </para>
</sect1>

<sect1 id="zend.dump">
    <title>Zend::dump()</title>

    <para>
    <code>Zend::dump()</code> выводит и/или возвращает информацию о выражении. Это обертка для PHP функции
    <ulink url="http://php.net/var_dump"><code>var_dump()</code></ulink>. Метод окружает выходные данные
    (X)HTML тэгами <code>&lt;pre&gt;</code> и присоединяет метку, если установлен соответствующий
    необязательный параметр.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
dump($var, $label=null, $echo=true)

?>]]></programlisting>

    <para>
    Аргумент <code>$var</code> задает выражение или переменную, для которой должна быть получена 
    информация.
    </para>

    <para>
    <code>$label</code> - произвольный текст, который будет присоединен в начале выходных данных
    <code>Zend::dump()</code>. Это полезно, когда делается дамп многих переменных на одном экране.
    </para>

    <para>Аргумент булевого типа <code>$echo</code> указывает, отображать ли выходные данные
    <code>Zend::dump()</code> или нет.  Если <code>TRUE</code>, выходные данные будут отображены. Выходные
    данные всегда возвращаются методом, независимо от значения <code>$echo</code>.
    </para>
</sect1>


<sect1 id="zend.register">
    <title>Zend::register()</title>

    <para>
    Регистрирует объект в хранилище объектов.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
register($name, $object)

?>]]></programlisting>

    <para>
    Реестр является механизмом для предоставления экземпляров-синглетонов объектов в среде приложения. Посредством
    единичного сохранения объекта в реестре и последующего извлечениия объекта из реестра всякий раз, когда
    это потребуется, всегда возвращается один и тот же экземпляр объекта.
    </para>

    <para>
    <code>$name</code> - произвольная строка для наименования объекта в хранилище. Это имя передается
    <code>Zend::registry()</code> для получения того же объекта.
    </para>

    <para>
    Аргумент <code>$name</code> дожен быть строкой, в реестре могут храниться только объекты, объект не может
    удаляться из реестра, и экземпляр может быть сохранен в реестре только один раз. Нарушение этих правил
    вызывает исключение <code>Zend_Exception</code>.
    </para>
</sect1>

<sect1 id="zend.registry">
    <title>Zend::registry()</title>

    <para>
    Возвращает объект в реестре или список всех объектов в реестре.
    </para>

    <programlisting role="php"><![CDATA[<?php
	
registry($name=null)

?>]]></programlisting>

    <para>
    Если значение аргумента <code>$name</code> равно <code>NULL</code>, будет возвращен массив, в котором
    ключами являются имена объектов в реестре, а значениями - имена классов, к которым принадлежат данные объекты.
    </para>

    <para>
    Если <code>$name</code> является строкой, будет возвращен дескриптор объекта, которому присвоено данное имя.
    Если объект с именем <code>$name</code> не существует в реестре, будет сгенерировано исключение
    <code>Zend_Exception</code>.
    </para>

    <para>
    Для быстрого определения, представлен ли объект в реестре, используйте <code>Zend::isRegistered()</code>.
    </para>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->