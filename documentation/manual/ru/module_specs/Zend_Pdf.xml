<sect1 id="zend.pdf.introduction">
    <!-- @todo review and revise upon completion of refactoring -->
    <title>Введение</title>
    <para>
    Модуль Zend_Pdf является механизмом для работы с PDF (Portable Document
    Format -- переносимый формат документов), который написан целиком на PHP 5.
    Он может загружать существующие документы, создавать новые, модифицировать
    и сохранять модифицированные документы. Таким образом, он может помочь любым
    основанным на PHP приложениям динамически подготавливать докуметы на PDF
    посредством изменения существующего шаблона или генерировать документ с нуля.
    
    Модуль Zend_Pdf поддерживает следующие возможности:
<!--
    Zend_Pdf module is a PDF (Portable Document Format) manipulation engine written entirely in PHP 5.
    It can load existing documents, create new, modify and save modified documents.
    Thus it can help any PHP-driven application dynamically prepare documents in a PDF by modifying existing template
    or generating document from a scratch.

    Zend_Pdf module supports the following features:
-->
    <itemizedlist>
        <listitem>
            <para>
            Создание нового документа или загрузка существующего
            <!-- Create new document or load existing one. -->
            <footnote>
                <para>
                Документы PDF версии V1.4 (Acrobat 5) сейчас поддерживаются для загрузки. 
                <!-- PDF V1.4 (Acrobat 5) documents are supported for loading now. -->
                </para>
            </footnote>
            </para>
        </listitem>
        <listitem>
            <para>
            Извлечение определенной версии документа
            <!-- Retrieving specified revision of the document. -->
            </para>
        </listitem>
        <listitem>
            <para>
            Управление страницами в документе. Изменение порядка страниц, добавление
            новых страниц, удаление страниц из документа.
            <!-- 
            Manipulate pages within document. Changing page order, adding new pages, removing pages
            from a document.
            -->
            </para>
        </listitem>
        <listitem>
            <para>
            Рисование различных примитивов (линий, прямоугольников, многоугольников,
            окружностей, эллипсов и секторов)
            <!-- 
            Different drawing primitives (lines, rectangles, polygons, circles, ellipses and sectors).
            -->
            </para>
        </listitem>
        <listitem>
            <para>
            Рисование текста с использованием одного из 14 стандартных шрифтов.
            <!-- 
            Text drawing by using one of 14 standard fonts.
            -->
            </para>
        </listitem>
        <listitem>
            <para>
            Повороты
            <!--
            Rotations.
            -->
            </para>
        </listitem>
        <listitem>
            <para>
            Рисование изображений
            <!--
            Image drawing.
            -->
            <footnote>
                <para>
                Поддерживаются изображения JPG, PNG [выше 8bit+Alpha] и TIFF.    
                <!-- 
                JPG, PNG [Up to 8bit+Alpha] and TIFF images are supported.
                -->
                </para>
            </footnote>
            </para>
        </listitem>
        <listitem>
            <para>
            Поэтапное обновление файла PDF 
            <!-- 
            Incremental PDF file update.
            -->
            </para>
        </listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="zend.pdf.create">
    <title>Создание и загрузка документов PDF<!--Creating and loading PDF documents.--></title>
    <para>
    Класс <code>Zend_Pdf</code> представляет документ PDF и обеспечивает
    функциональность для работы на уровне документа.
<!--
    <code>Zend_Pdf</code> class represents PDF document itself and provides document level
    functionality.
-->
    </para>

    <para>
    Для того, чтобы создать новый документ, нужно создать новый объект <code>Zend_Pdf</code>.    
<!-- 
    To create new document new <code>Zend_Pdf</code> object should be created.
-->
    </para>

    <para>
    Класс <code>Zend_Pdf</code> также предоставляет два статических метода для
    загрузки существующих документов PDF. Это методы <code>Zend_Pdf::load()</code>
    и <code>Zend_Pdf::parse()</code>. Оба метода возвращают объект <code>Zend_Pdf</code>
    в качестве результата или генерируют исключение в случае ошибки. 
<!-- 
    <code>Zend_Pdf</code> class also provides two static methods to load existing PDF.
    These are <code>Zend_Pdf::load()</code> and <code>Zend_Pdf::parse()</code> methods.
    Both of them return Zend_Pdf object as a result or throw an exception if error occurs.
-->
    </para>

    <example>
        <title>
        Создание нового или загрузка существующего документа PDF 
        <!-- Create new or load existing PDF document.-->
        </title>
        <programlisting role="php"><![CDATA[<?php
...
// Создание нового документа PDF
$pdf1 = new Zend_Pdf();

// Загрузка документа PDF из файла
$pdf2 = Zend_Pdf::load($fileName);

// Загрузка документа PDF из строки
$pdf3 = Zend_Pdf::parse($pdfString);
...
?>]]></programlisting>
    </example>

    <para>
    Формат файла PDF поддерживает постепенное обновление документа. Таким образом,
    каждый раз, когда документ обновляется, создается новая версия документа.
<!-- 
    PDF file format supports incremental document update. Thus each time when document
    is updated, then new revision of the document is created.
    Zend_Pdf module supports retrieving of specified revision.
-->
    </para>
    <para>
    Версия может быть указана в качестве второго параметра для методов
    <code>Zend_Pdf::load()</code> и <code>Zend_Pdf::parse()</code> или получается
    методом <code>Zend_Pdf::rollback()</code>.
<!--
     Revision can be specified as a second parameter for <code>Zend_Pdf::load()</code> and
    <code>Zend_Pdf::parse()</code> methods or requested by <code>Zend_Pdf::rollback()</code>
-->
        <footnote>
            <para>
            Метод <code>Zend_Pdf::rollback()</code> должен вызываться до того,
            как будут производиться любые изменения[накладываемые на документ].
<!-- 
            <code>Zend_Pdf::rollback()</code> method must be invoked before any changes, applied to the document.
            Otherwise behavior is undefined.
-->
            </para>
        </footnote>
    call.
    </para>

    <example>
        <title>Извлечение определенной версии документа PDF<!--Requesting specified revision of the PDF document.--></title>
        <programlisting role="php"><![CDATA[<?php
...
// Загрузка предыдущей версии документа PDF
$pdf1 = Zend_Pdf::load($fileName, 1);

// Загрузка предыдущей версии документа PDF
$pdf2 = Zend_Pdf::parse($pdfString, 1);

// Загрузка первой версии документа
$pdf3 = Zend_Pdf::load($fileName);
$revisions = $pdf3->revisions();
$pdf3->rollback($revisions - 1);
...
?>]]></programlisting>
    </example>


</sect1>


<sect1 id="zend.pdf.save">
    <title>Сохранение изменений в документе PDF<!-- Save changes to the PDF document. --></title>
    <para>
    Есть два метода, с помощью которых производится сохранение изменений в документе
    PDF. Это методы <code>Zend_Pdf::save()</code> и <code>Zend_Pdf::render()</code>. 
    
<!-- 
    There are two methods, which provide saving changes to the PDF document. These are <code>Zend_Pdf::save()</code> and
    <code>Zend_Pdf::render()</code> methods.
-->
    </para>

    <para>
    Метод <code>Zend_Pdf::save($filename, $updateOnly = false)</code> сохраняет
    документ в файл. Если <code>$updateOnly</code> равен <code>true</code>, то
    к файлу PDF будет только добавлен новый сегмент, иначе файл будет перезаписан.
<!-- 
    <code>Zend_Pdf::save($filename, $updateOnly = false)</code> method saves document to a file. If $updateOnly is true,
    then only new PDF file segment is appended to a file. Otherwise file is overwritten.
-->
    </para>

    <para>
    <code>Zend_Pdf::render($filename, $updateOnly = false)</code> возвращает
    документ PDF в виде строки. Если <code>$updateOnly</code> равен <code>true</code>,
    то будет возвращен только новый сегмент файла PDF.
<!-- 
    <code>Zend_Pdf::render($filename, $updateOnly = false)</code> returns PDF document as a string. If $updateOnly is true,
    then only new PDF file segment is returned.
-->
    </para>

    <example>
        <title>Сохранение документа PDF<!-- Save PDF document. --></title>
        <programlisting role="php"><![CDATA[<?php
...
// Загрузка документа PDF
$pdf = Zend_Pdf::load($fileName);
...
// Обновление документа
$pdf->save($fileName, true);
// Сохранение документа в новом файле
$pdf->save($newFileName, true);

// Возвращение документа в виде строки
$pdfString = $pdf->render();

...
?>]]></programlisting>
    </example>

</sect1>

<sect1 id="zend.pdf.pages">
    <title>Страницы документа<!-- Document pages. --></title>
    <para>
    Абстракция страницы документа PDF представлена классом <code>Zend_Pdf_Page</code>.
<!-- 
    PDF document page abstraction is represented by <code>Zend_Pdf_Page</code> class.
-->
    </para>

    <para>
    Страницы PDF либо загружаются из существующего документа PDF, либо создаются.  
<!-- 
    PDF pages either are loaded from existing PDF, or created.
-->
    </para>

    <para>
    Новая страница может быть получена посредством создания нового объекта
    <code>Zend_Pdf_Page</code> или вызова метода <code>Zend_Pdf::newPage()</code>,
    который возвращает объект <code>Zend_Pdf_Page</code>. Их различие в том, что
    метод <code>Zend_Pdf::newPage()</code> создает страницу, уже прикрепленную
    к документу. В отличие от неприкрепленой, она не может использоваться
    с несколькими документами PDF, но имеет несколько лучшую производительность.
<!-- 
    New page can be obtained by creating new <code>Zend_Pdf_Page</code> object or calling
    <code>Zend_Pdf::newPage()</code> method, which returns <code>Zend_Pdf_Page</code> object.
    The difference is that <code>Zend_Pdf::newPage()</code> method creates a page, already attached to
    the document. In difference from unattached pages it can't be used with several PDF documents,
    but has a little bit better performance.
-->
    <footnote>
        <para>
        Имеется ограничение версии V1.0 модуля Zend_Pdf. Она будет устранена в
        будущих версиях. Но неприкрепленные страницы всегда дают лучший (более
        оптимальный) результат при совместном использовании в нескольких документах.
<!-- 
        It's a limitation of V1.0 version of Zend_Pdf module. It will be eliminated in future versions.
        But unattached pages will always give better (more optimal) result for sharing pages between documents.
-->
        </para>
    </footnote>
    . Какой подход использовать -- решать вам.
<!-- 
    . It's your choice, which approach should be used.
-->
    </para>

    <para>
    Метод <code>Zend_Pdf::newPage()</code> и конструктор <code>Zend_Pdf_Page</code>
    принимают одинаковый набор параметров. Это либо размер страницы ($x, $y) в
    пойнтах (1pt = 1/72 inch), либо предопределенная константа, которая
    трактуется как тип страницы:
     
<!-- 
    <code>Zend_Pdf::newPage()</code> method and <code>Zend_Pdf_Page</code> constructor take the same
    set of parameters. It either the size of page ($x, $y) in a points (1/72 inch), or predefined constant,
    which is treated as a page type:
-->
        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Const::PAGESIZE_A4</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::PAGESIZE_A4_LANDSCAPE</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::PAGESIZE_LETTER</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::PAGESIZE_LETTER_LANDSCAPE</para>
            </listitem>
        </itemizedlist>
    </para>

    <para>
    Страницы документа хранятся в открытом члене <code>$pages</code> класса
    <code>Zend_Pdf</code>. Это массив объектов <code>Zend_Pdf_Page</code>.
    Он полностью описывает набор и порядок страниц документа и с ним можно
    работать, как с обычным массивом:
<!-- 
    Document pages are stored in <code>$pages</code> public member of <code>Zend_Pdf</code> class.
    It's an array of <code>Zend_Pdf_Page</code> objects. It completely defines set and order of document pages
    and can be manipulated as a common array:
-->
    </para>

    <example>
        <title>Управление страницами документа PDF<!-- PDF document pages management. --></title>
        <programlisting role="php"><![CDATA[<?php
...
// Изменение порядка страниц на противоположный
$pdf->pages = array_reverse($pdf->pages);
...
// Добавление новой страницы
$pdf->pages[] = new Zend_Pad_Page(Zend_Pdf_Const::PAGESIZE_A4);
// Добавление новой страницы
$pdf->pages[] = $pdf->newPage(Zend_Pdf_Const::PAGESIZE_A4);

// Удаление определенной страницы
unset($pdf->pages[$id]);

...
?>]]></programlisting>
    </example>

</sect1>

<sect1 id="zend.pdf.drawing">
    <title>Рисование<!-- Drawing. --></title>

    <sect2 id="zend.pdf.drawing.geometry">
        <title>Геометрия<!-- Geometry.--></title>
        <para>
        PDF использует ту же самую геометрию, что и PostScript. Она начинается с
        нижнего левого угла страницы и по умолчанию измеряется в пойнтах (1/72 дюйма). 
<!-- 
        PDF uses the same geometry as PostScript. It starts from bottom-left corner of page
        and by default is measured in points (1/72 of an inch).
-->
        </para>
        <para>
        Размер страницы может быть получен из объекта страницы:
<!-- 
        Page size can be retrieved from a page object:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
$width  = $pdfPage->getWidth();
$height = $pdfPage->getHeight();]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.color">
        <title>Цвета<!-- Colors. --></title>
        <para>
        PDF имеет мощные возможности для представления цветов. Модуль Zend_Pdf
        поддерживает шкалу серого цвета, цветовые пространства RGB и CMYK.
        Они могут использоваться в любом месте, где требуется объект
        <code>Zend_Pdf_Color</code>. Классы <code>Zend_Pdf_Color_GrayScale</code>,
        <code>Zend_Pdf_Color_RGB</code> и <code>Zend_Pdf_Color_CMYK</code>
        предоставляют этот функционал:
<!-- 
        PDF has a powerful capabilities for colors representation. Zend_Pdf module supports Gray Scale,
        RGB and CMYK color spaces. Any of them can be used in any place, where <code>Zend_Pdf_Color</code>
        object is required. <code>Zend_Pdf_Color_GrayScale</code>, <code>Zend_Pdf_Color_RGB</code> and
        <code>Zend_Pdf_Color_CMYK</code> classes provide this functionality:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
// $grayLevel (число с плавающей точкой)
// 0.0 (черный) - 1.0 (белый)
$color1 = new Zend_Pdf_Color_GrayScale($grayLevel);

// $r, $g, $b (числа с плавающей точкой)
// 0.0 (минимальная интенсивность) - 1.0 (максимальная интенсивность)
$color2 = new Zend_Pdf_Color_RGB($r, $g, $b);

// $c, $m, $y, $k (числа с плавающей точкой)
// 0.0 (минимальная интенсивность) - 1.0 (максимальная интенсивность)
$color3 = new Zend_Pdf_Color_CMYK($c, $m, $y, $k);]]>
            </programlisting>
        </para>
    </sect2>


    <sect2 id="zend.pdf.drawing.shape-drawing">
        <title>Рисование фигур<!-- Shape Drawing. --></title>
        <para>
        Все операции прорисовки могут быть выполнены в контексте страницы PDF.
<!-- 
        All drawing operations can be done in a context of PDF page.
-->
        </para>
        <para>
        Класс <code>Zend_Pdf_Page</code> предоставляет набор примитивов для рисования:
<!-- 
        <code>Zend_Pdf_Page</code> class provides a set of drawing primitives:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Рисует линию от x1,y1 до x2,y2.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function drawLine($x1, $y1, $x2, $y2);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Рисует прямоугольник.
 *
 * Fill types:
 * Zend_Pdf_Const::SHAPEDRAW_FILLNSTROKE - заполнить прямоугольник и заштриховать (значение по умолчанию)
 * Zend_Pdf_Const::SHAPEDRAW_STROKE      - заштриховать прямоугольник
 * Zend_Pdf_Const::SHAPEDRAW_FILL        - заполнить прямоугольник
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param integer $fillType
 */
public function drawRectangle($x1, $y1, $x2, $y2, $fillType = Zend_Pdf_Const::SHAPEDRAW_FILLNSTROKE);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Риcует многоугольник.
 *
 * Если $fillType (тип заполнения) равен Zend_Pdf_Const::SHAPEDRAW_FILLNSTROKE
 * или Zend_Pdf_Const::SHAPEDRAW_FILL, то многоугольник будет автоматически замкнут.
 * См. более подробное описание этих методов в документации PDF
 * (section 4.4.2 Path painting Operators, Filling)
 *
 * @param array $x  - массив чисел с плавающей точкой (X-координаты вершин)
 * @param array $y  - массив чисел с плавающей точкой (Y-координаты вершин)
 * @param integer $fillType
 * @param integer $fillMethod
 */
public function drawPolygon($x, $y,
                            $fillType = Zend_Pdf_Const::SHAPEDRAW_FILLNSTROKE,
                            $fillMethod = Zend_Pdf_Const::FILLMETHOD_NONZEROWINDING);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Рисует окружность, центр которой находится в точке с координатами x и y,
 * с радиусом radius.
 *
 * Углы задаются в радианах.
 *
 * Сигнатуры метода:
 * drawCircle($x, $y, $radius);
 * drawCircle($x, $y, $radius, $fillType);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle, $fillType);
 *
 *
 * Это не настоящая окружность, так как PDF поддерживает только кубические кривые Безье.
 * Но в очень хорошем приближении.
 * Она отличается от реальной окружности максимум на 0.00026 доли радиуса
 * (на углах PI/8, 3*PI/8, 5*PI/8, 7*PI/8, 9*PI/8, 11*PI/8, 13*PI/8 и 15*PI/8).
 * На углах 0, PI/4, PI/2, 3*PI/4, PI, 5*PI/4, 3*PI/2 и 7*PI/4 это точная касательная к окружности.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param mixed $param4
 * @param mixed $param5
 * @param mixed $param6
 */
public function  drawCircle($x, $y, $radius, $param4 = null, $param5 = null, $param6 = null);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Рисует эллипс внутри заданного прямоугольника.
 *
 * Сигнатуры метода:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $fillType);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle, $fillType);
 *
 * Углы задаются в радианах.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param mixed $param5
 * @param mixed $param6
 * @param mixed $param7
 */
public function drawEllipse($x1, $y1, $x2, $y2, $param5 = null, $param6 = null, $param7 = null);]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.text-drawing">
        <title>Написание текста<!-- Text Drawing.--></title>
        <para>
        Операции по написанию текста также существуют в контексте страницы PDF. 
<!-- 
        Text drawing operations are also exist in a context of PDF page:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Выводит строку текста в заданной позиции.
 *
 * @param string $text
 * @param float $x
 * @param float $y
 * @throws Zend_Pdf_Exception
 */
public function drawText($text, $x, $y );]]>
            </programlisting>
        </para>
        <para>
        Для написания текста используются текущий шрифт и его текущий размер. См.
        подробное описание ниже.
<!-- 
        Current font and current font size are used for text drawing operations. See detailed description below.
-->
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.using-fonts">
        <title>Применение шрифтов<!-- Using fonts. --></title>
        <para>
        Метод <code>Zend_Pdf_Page::drawText()</code> использует текущий шрифт,
        который может быть установлен методом <code>Zend_Pdf_Page::setFont()</code>: 
<!-- 
        <code>Zend_Pdf_Page::drawText()</code> method uses current font, which can be assigned
        by <code>Zend_Pdf_Page::setFont()</code> method:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Устанавливает текущий шрифт.
 *
 * @param Zend_Pdf_Font $font
 * @param float $fontSize
 */
public function setFont(Zend_Pdf_Font $font, $fontSize);]]>
            </programlisting>
        </para>
        <para>
        PDF поддерживает Type1, TrueType, Type3 и составные шрифты. Он предоставляет еще
        14 стандартных шрифтов Type1. На данный момент модуль <code>Zend_Pdf</code>
        предусматривает только эти стандартные шрифты. Они могут быть получены
        с помощью класса <code>Zend_Pdf_Font_Standard</code>. Конкретный шрифт
        указывается в качестве аргумента конструктора.
<!-- 
        PDF supports Type1, TrueType, Type3 and composite fonts. There are also 14 standard Type1 fonts
        provided by PDF. Zend_Pdf module provides only these standard fonts now. They can be obtained by using
        <code>Zend_Pdf_Font_Standard</code> class. Concrete font is specified as a constructor argument:
-->
        </para>
        <example>
            <title><!-- Create standard font.--></title>
            <programlisting role="php"><![CDATA[<?php
...
// Создание нового шрифта
$font = new Zend_Pdf_Font_Standard(Zend_Pdf_Const::FONT_HELVETICA);

// Применение шрифта
$pdfPage->setFont($font, 36);
...
?>]]>
            </programlisting>
        </example>
        <para>
        Константы для 14 стандартных шрифтов определены с помощью
        класса <code>Zend_Pdf_Const</code>:
<!-- 
        Font constants for 14 standard fonts are defined within <code>Zend_Pdf_Const</code> class:
-->
        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Const::FONT_TIMES_ROMAN</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_TIMES_BOLD</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_TIMES_ITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_TIMES_BOLDITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_HELVETICA</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_HELVETICA_BOLD</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_HELVETICA_ITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_HELVETICA_BOLDITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_COURIER</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_COURIER_BOLD</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_COURIER_ITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_COURIER_BOLDITALIC</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_SYMBOL</para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FONT_ZAPFDINGBATS</para>
            </listitem>
        </itemizedlist>
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.image-drawing">
        <title>Рисование изображений<!-- Image Drawing. --></title>
        <para>
        Класс предоставляет метод <code>drawImage()</code> для рисования изображений.
<!-- 
        <code>Zend_Pdf_Page</code> class provides drawImage() method to draw image:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Рисует изображение в заданной позиции на странице.
 *
 * @param Zend_Pdf_Image $image
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function drawImage(Zend_Pdf_Image $image, $x1, $y1, $x2, $y2);]]>
            </programlisting>
        </para>
        <para>
        Объекты изображения представляются потомками класса <code>Zend_Pdf_Image</code>.
<!-- 
        Image objects are represented by descendants of <code>Zend_Pdf_Image</code> class.
-->
        </para>
        <para>
        Сейчас поддерживаются изображения JPG, PNG и TIFF.
<!-- 
        JPG, PNG and TIFF images are supported now:
-->
        </para>
        <example>
            <title>Рисование изображений<!-- Image drawing.--></title>
            <programlisting role="php"><![CDATA[<?php
...
//Создаем объект изображения непосредственно
$image = new Zend_Pdf_Image_JPEG('my_image.jpg');
$image = new Zend_Pdf_Image_TIFF('my_image.tiff');
$image = new Zend_Pdf_Image_PNG('my_image.png');

//либо используем Zend_Pdf_ImageFactory для загрузки соответствующего типа
$image = Zend_Pdf_ImageFactory::factory('my_image.jpg');

$pdfPage->drawImage($image, 100, 100, 400, 300);
...
?>]]>
            </programlisting>
        </example>

        <para>
            <emphasis>Важно! Класс <code>Zend_Pdf_Image_JPEG</code> требует
            сконфигурированного расширения GD.</emphasis>
            <emphasis>Важно! Класс <code>Zend_Pdf_Image_PNG</code> требует
            расширения ZLIB, сконфигурированного для работы с изображениями с Альфа-каналом.</emphasis>
<!-- 
            <emphasis>Important! Zend_Pdf_Image_JPEG class requires PHP GD extension to be configured.</emphasis>
            <emphasis>Important! Zend_Pdf_Image_PNG class requires ZLIB extension to be configured to work with Alpha channel images.</emphasis>
-->
        </para>
        <para>
            См. документацию PHP за более подробной информацией 
            (<ulink url="http://www.php.net/manual/en/ref.image.php">http://www.php.net/manual/en/ref.image.php</ulink>).
            (<ulink url="http://www.php.net/manual/en/ref.zlib.php">http://www.php.net/manual/en/ref.zlib.php</ulink>).
<!-- 
            Refer to the PHP documentation for detailed information
            (<ulink url="http://www.php.net/manual/en/ref.image.php">http://www.php.net/manual/en/ref.image.php</ulink>).
            (<ulink url="http://www.php.net/manual/en/ref.zlib.php">http://www.php.net/manual/en/ref.zlib.php</ulink>).
-->
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.line-drawing-style">
        <title>Стили рисования линий<!-- Line drawing style.--></title>
        <para>
        Стили рисования линий определяются толщиной линии, цветом линии и шаблоном
        пунктира. Все эти параметры могут быть определены методами класса
        <code>Zend_Pdf_Page</code>.
<!-- 
        Line drawing style is defined by line width, line color and line dashing pattern.
        All of this parameters can be assigned by <code>Zend_Pdf_Page</code>
        class methods:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/** Установка цвета линии. */
public function setLineColor(Zend_Pdf_Color $color);

/** Установка толщины линии. */
public function setLineWidth(float $width);

/**
 * Установка шаблона пунктира.
 *
 * $pattern (шаблон) является массивом чисел с плавающей точкой:
 * array(on_length, off_length, on_length, off_length, ...)
 * $phase (фаза) является сдвигом от начала линии.
 *
 * @param array $pattern
 * @param array $phase
 */
public function setLineDashingPattern($pattern, $phase = 0);]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.fill-style">
        <title>Стиль заполнения<!-- Fill style.--></title>
        <para>
        Методы <code>Zend_Pdf_Page::drawRectangle()</code>, <code>Zend_Pdf_Page::drawPoligon()</code>,
        <code>Zend_Pdf_Page::drawCircle()</code> и <code>Zend_Pdf_Page::drawEllipse()</code>
        принимают аргумент <code>$fillType</code> как необязательный параметр.
        Это может быть: 
<!-- 
        <code>Zend_Pdf_Page::drawRectangle()</code>, <code>Zend_Pdf_Page::drawPoligon()</code>,
        <code>Zend_Pdf_Page::drawCircle()</code> and <code>Zend_Pdf_Page::drawEllipse()</code> methods take
        <code>$fillType</code> argument as an optional parameter. It can be:
-->
        </para>

        <itemizedlist>
            <listitem>
                <para>
                Zend_Pdf_Const::SHAPEDRAW_STROKE - штрихует фигуру <!-- stroke shape -->
                </para>
            </listitem>
            <listitem>
                <para>
                Zend_Pdf_Const::SHAPEDRAW_FILL - заполняет фигуру <!-- only fill shape-->
                </para>
            </listitem>
            <listitem>
                <para>
                Zend_Pdf_Const::SHAPEDRAW_FILLNSTROKE - заполняет и штрихует (поведение по умолчанию)
                <!-- fill and stroke (default behavior)-->
                </para>
            </listitem>
        </itemizedlist>

        <para>
        Метод <code>Zend_Pdf_Page::drawPoligon()</code> принимает дополнительный
        параметр <code>$fillMethod</code>:
<!-- 
        <code>Zend_Pdf_Page::drawPoligon()</code> methods also takes an additional parameter
        <code>$fillMethod</code>:
-->
        </para>
        <itemizedlist>
            <listitem>
                <para>
                Zend_Pdf_Const::FILLMETHOD_NONZEROWINDING (поведение по умолчанию)
                <!-- (default behavior)-->
                </para>
                <para>
                <citetitle>Справка по PDF</citetitle> описывает это правило
                следующим образом:
                <blockquote>
                Правило ненулевого количества витков определяет, находится ли
                данная точка внутри траектории путем мысленного
                проведения луча из этой точки в бесконечность в любом направлении
                и последующего определения мест, где участок траектории пересекает луч.
                Начиная отсчет с нуля, правило добавляет 1 каждый раз, когда
                участок траектории пересекает луч слева направо и отнимает 1
                каждый раз, когда участок траектории пересекает участок справа налево.
                Если после подсчета всех пересечений результатом будет 0, то точка
                находится вне траектории, иначе -- внутри траектории. 
                
                Примечание: Метод не указывает, что делать, если участок траектории
                совпадает или является касательной к выбранному лучу. Поскольку
                направление луча является произвольным, правило просто выбирает
                луч, который не создает таких пересечений. Для простых выпуклых
                траекторий правило ненулевого количества витков определяет
                внутреннюю и внешнюю части так, как это интуитивно предполагается.
                Более интересными случаями являются те, которые включают в себя
                сложные или самопересекающиеся траектории, как, например,
                на Рис. 4.10 (в справке по PDF).
                
                Для траектории, представляющую собой пятиконечную звезду,
                состоящую из пяти соединенных отрезков, правило считает внутренней
                частью всю площадь, окруженную звездой, включая пятиугольник в
                центре. Для траектории, состоящей из двух концентрических
                окружностей, площадь, окруженная обеими окружностями,
                считается внутренней в том случае, если обе окружности нарисованы
                в одном и том же направлении. Если окружности нарисованы в противоположных
                направлениях, то, согласно правилу, только фигура в виде
                баранки между ними будет внутренней частью, "дырка"
                будет внешней частью.
            </blockquote>
<!-- 
                <citetitle>PDF reference</citetitle> describes this rule as follows:
                <blockquote>
The nonzero winding number rule determines whether a given point is inside a
path by conceptually drawing a ray from that point to infinity in any direction
and then examining the places where a segment of the path crosses the ray. Starting
with a count of 0, the rule adds 1 each time a path segment crosses the ray
from left to right and subtracts 1 each time a segment crosses from right to left.
After counting all the crossings, if the result is 0 then the point is outside the path;
otherwise it is inside.

Note: The method just described does not specify what to do if a path segment coincides
with or is tangent to the chosen ray. Since the direction of the ray is arbitrary,
the rule simply chooses a ray that does not encounter such problem intersections.
For simple convex paths, the nonzero winding number rule defines the inside
and outside as one would intuitively expect. The more interesting cases are those
involving complex or self-intersecting paths like the ones shown in Figure 4.10
(in a PDF Reference).

For a path consisting of a five-pointed star, drawn with five connected straight
line segments intersecting each other, the rule considers the inside to be the entire
area enclosed by the star, including the pentagon in the center. For a path composed
of two concentric circles, the areas enclosed by both circles are considered
to be inside, provided that both are drawn in the same direction. If the circles are
drawn in opposite directions, only the "doughnut" shape between them is inside,
according to the rule; the "doughnut hole" is outside.
            </blockquote>
-->
            </para>
            </listitem>
            <listitem>
                <para>Zend_Pdf_Const::FILLMETHOD_EVENODD</para>
                <para>
                <citetitle>Справка по PDF</citetitle> описывает это правило
                следующим образом:
                <blockquote>
                Альтернативой правилу ненулевого количества витков является правило
                чета-нечета. Это правило определяет нахождение точки
                проведением луча из этой точки в любом направлении и простым подсчетом
                количества пересечений частей траектории с этим лучом, независимо от
                направления пересечения. Если число нечетное, то точка находится
                во внутренней части; если четное, то точка находится снаружи. Это
                правило дает такой же результат, как и правило ненулевого
                количества витков для траекторий с простыми фигурами, но дает
                разные результаты в случае более сложных фигур.
                
                Рис. 4.11 (в справке по PDF) показывает результаты применения
                правила чета-нечета к сложным фигурам. В случае пятиконечной
                звезды правило считает точки треугольников находящимися
                внутри траектории, но не пятиугольник в центре. Для двух
                концентрических окружностей только фигура в виде баранки будет
                считаться внутренней частью, независимо от направлений, в которых
                нарисованы окружности.
                </blockquote>
<!-- 
                <citetitle>PDF reference</citetitle> describes this rule as follows:
                <blockquote>
An alternative to the nonzero winding number rule is the even-odd rule. This rule
determines the "insideness" of a point by drawing a ray from that point in any
direction and simply counting the number of path segments that cross the ray,
regardless of direction. If this number is odd, the point is inside; if even, the point
is outside. This yields the same results as the nonzero winding number rule for
paths with simple shapes, but produces different results for more complex
shapes.

Figure 4.11 (in a PDF Reference) shows the effects of applying the even-odd rule
to complex paths. For the five-pointed star, the rule considers the triangular
points to be inside the path, but not the pentagon in the center. For the two
concentric circles, only the "doughnut" shape between the two circles is considered inside,
regardless of the directions in which the circles are drawn.
                </blockquote>
-->
            </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.pdf.drawing.rotations">
        <title>Поворот<!-- Rotations. --></title>
        <para>
        Страница PDF может быть повернута перед применением любых операций рисования.
        Это может быть сделано методом <code>Zend_Pdf_Page::rotate()</code>: 
<!-- 
        PDF page can be rotated before applying any draw operation.
        It can be done by <code>Zend_Pdf_Page::rotate()</code> method:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Поворачивает страницу вокруг точки ($x, $y) на заданный угол (в радианах).
 *
 * @param float $angle
 */
public function rotate($x, $y, $angle);]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.save-restore">
        <title>Сохранение/восстановление графического состояния<!-- Save/restore graphics state.--></title>
        <para>
        В любое время графическое состояние страницы (текущий шрифт, размер шрифта,
        цвет линии, цвет заполнения, стиль линии, поворот страницы, область ограничения) может
        быть сохранено и после восстановлено. Операция сохранения сохраняет данные
        в стек графического состояния, операция восстановления извлекает данные из стека.
<!-- 
        At any time page graphics state (current font, font size, line color, fill color,
        line style, page rotation, clip area) can be saved and then restored. Save operation puts
        data to a graphics state stack, restore operation retrieves it from there.
-->
        </para>
        <para>
        Методы в классе <code>Zend_Pdf_Page</code> для этих операций:
<!-- 
        There are to methods in <code>Zend_Pdf_Page</code> class for these operations:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Сохраняет графическое состояние данной страницы.
 * Выполняет снимок используемых на данный момент стилей, положений, ... и всех
 * поворотов/преобразований/масштабирований которые были применены.
 * This takes a snapshot of the currently applied style, position, clipping area and
 * any rotation/translation/scaling that has been applied.
 */
public function saveGS();

/**
 * Восстанавливает графическое состояние, которое было сохранено последним
 * вызовом saveGS().
 */
public function restoreGS();]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.clipping">
        <title>Ограничение области рисования<!-- Clipping draw area. --></title>
        <para>
        PDF и модуль Zend_Pdf поддерживают ограничение области рисования.
        Ограничение определяет область страницы, затрагиваемой
        операциями рисования. Вначале эта область представляет собой всю
        страницу.
<!-- 
        PDF and Zend_Pdf module support clipping of draw area.
        Current clip area limits the regions of the page affected by painting operators. It's a whole page initially.
-->
        </para>
        <para>
        Класс <code>Zend_Pdf_Page</code> предоставляет набор методов для операций ограничения.
<!-- 
        <code>Zend_Pdf_Page</code> class provides a set of methods for clipping operations.
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Делит текущую площадь ограничения с помощью прямоугольника.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function clipRectangle($x1, $y1, $x2, $y2);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Делит текущую площадь ограничения с помощью многоугольника.
 *
 * @param array $x  - массив чисел с плавающей точкой (X-координаты верхушек)
 * @param array $y  - массив чисел с плавающей точкой (Y-координаты верхушек)
 * @param integer $fillMethod
 */
public function clipPolygon($x, $y, $fillMethod = Zend_Pdf_Const::FILLMETHOD_NONZEROWINDING);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Делит текущую площадь ограничения с помощью окружности.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param float $startAngle
 * @param float $endAngle
 */
public function clipCircle($x, $y, $radius, $startAngle = null, $endAngle = null);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Делит текущую площадь ограничения с помощью эллипса.
 *
 * Сигнатуры метода:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 *
 * @todo обрабатывать случаи, когда $x2-$x1 == 0 или $y2-$y1 == 0
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param float $startAngle
 * @param float $endAngle
 */
public function clipEllipse($x1, $y1, $x2, $y2, $startAngle = null, $endAngle = null);]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.pdf.drawing.styles">
        <title>Стили<!-- Styles. --></title>
        <para>
        Класс <code>Zend_Pdf_Style</code> предоставляет набор функциональных
        возможностей для работы со стилями. 
<!-- 
        <code>Zend_Pdf_Style</code> class provides styles functionality.
-->
        </para>
        <para>
        Стили могут использоваться для сохранения набора параметров графического
        состояния и применять их к странице PDF одной операцией:
<!-- 
        Styles can be used to store a set of graphic state parameters and apply it to a PDF page by one operation:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Установить стиль для будущих операций рисования на данной странице
 *
 * @param Zend_Pdf_Style $style
 */
public function setStyle(Zend_Pdf_Style $style);

/**
 * Возвращает стили, используемые на странице
 *
 * @return Zend_Pdf_Style|null
 */
public function getStyle();]]>
            </programlisting>
        </para>

        <para>
        Класс <code>Zend_Pdf_Style</code> предоставляет набор методов для установки
        или получения различных параметров графического состояния:
<!-- 
        <code>Zend_Pdf_Style</code> class provides a set of methods to set or get different graphics state parameters:
-->
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Устанавливает цвет линии.
 *
 * @param Zend_Pdf_Color $color
 */
public function setLineColor(Zend_Pdf_Color $color);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Возвращает цвет линии.
 *
 * @return Zend_Pdf_Color|null
 */
public function getLineColor();]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Устанавливает толщину линии.
 *
 * @param float $width
 */
public function setLineWidth($width);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Возвращает толщину линии.
 *
 * @return float
 */
public function getLineWidth();]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Устанавливает шаблон пунктира.
 *
 * @param array $pattern
 * @param float $phase
 */
public function setLineDashingPattern($pattern, $phase = 0);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Возвращает шаблон пунктира.
 *
 * @return array
 */
public function getLineDashingPattern();]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Возвращает фазу пунктира.
 *
 * @return float
 */
public function getLineDashingPhase();]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Устанавливает цвет заполнения.
 *
 * @param Zend_Pdf_Color $color
 */
public function setFillColor(Zend_Pdf_Color $color);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Возвращает цвет заполнения.
 *
 * @return Zend_Pdf_Color|null
 */
public function getFillColor();]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Устанавливает текущий шрифт.
 *
 * @param Zend_Pdf_Font $font
 * @param float $fontSize
 */
public function setFont(Zend_Pdf_Font $font, $fontSize);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Изменяет текущий размер шрифта
 *
 * @param float $fontSize
 */
public function setFontSize($fontSize);]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Возвращает текущий шрифт.
 *
 * @return Zend_Pdf_Font $font
 */
public function getFont();]]>
            </programlisting>
        </para>
        <para>
            <programlisting role="php"><![CDATA[
/**
 * Возвращает текущий размер шрифта.
 *
 * @return float $fontSize
 */
public function getFontSize();]]>
            </programlisting>
        </para>
    </sect2>

</sect1>

<sect1 id="zend.pdf.usage">
    <title>Пример использования модуля Zend_Pdf <!-- Zend_Pdf module usage example.--></title>
    <para>
    Этот раздел дает пример использования модуля.
<!-- 
    This section provides an example of module usage.
-->
    </para>

    <para>
    Этот пример может быть найден в файле <filename>demos/Zend/Pdf/demo.php</filename>.
<!-- 
    This example can be found in a <filename>demos/Zend/Pdf/demo.php</filename> file.
-->
    </para>
    <para>
    Там же есть файл <filename>test.pdf</filename>, который может использоваться
    с этим примером для тестирования.
<!-- 
    There are also <filename>test.pdf</filename> file, which can be used with this demo
    for test purposes.
-->
    </para>

    <example>
        <title>Демонстрация использования модуля Zend_Pdf<!-- Zend_Pdf module usage demo.--></title>
        <programlisting role="php"><![CDATA[<?php
/**
 * @package Zend_Pdf
 * @subpackage demo
 */

/** Zend_Pdf */
require_once 'Zend/Pdf.php';

if (!isset($argv[1])) {
    echo "USAGE: php demo.php <pdf_file> [<output_pdf_file>]\n";
    exit;
}

if (file_exists($argv[1])) {
    $pdf = Zend_Pdf::load($argv[1]);
} else {
    $pdf = new Zend_Pdf();
}

//------------------------------------------------------------------------------------
// Изменить порядок страниц на обратный
$pdf->pages = array_reverse($pdf->pages);

// Создание нового стиля
$style = new Zend_Pdf_Style();
$style->setFillColor(new Zend_Pdf_Color_RGB(0, 0, 0.9));
$style->setLineColor(new Zend_Pdf_Color_GrayScale(0.2));
$style->setLineWidth(3);
$style->setLineDashingPattern(array(3, 2, 3, 4), 1.6);
$style->setFont(new Zend_Pdf_Font_Standard(Zend_Pdf_Const::FONT_HELVETICA_BOLD), 32);

// Создание нового объекта изображения
$stampImage = Zend_Pdf_ImageFactory::factory(dirname(__FILE__) . '/stamp.jpg');

// Обозначение страницы как измененной
foreach ($pdf->pages as $page){
    $page->saveGS();
    $page->setStyle($style);
    $page->rotate(0, 0, M_PI_2/3);

    $page->saveGS();
    $page->clipCircle(550, -10, 50);
    $page->drawImage($stampImage, 500, -60, 600, 40);
    $page->restoreGS();

    $page->drawText('Modified by Zend Framework!', 150, 0);
    $page->restoreGS();
}

// Добавление новой страницы, сгенерированной объектом Zend_Pdf
// (страница прикреплена к определенному документу)  
$pdf->pages[] = ($page1 = $pdf->newPage('A4'));

// Добавление новой страницы, сгенерированной объектом Zend_Pdf_Page
// (страница не прикреплена к документу)
$pdf->pages[] = ($page2 = new Zend_Pdf_Page(Zend_Pdf_Const::PAGESIZE_LETTER_LANDSCAPE));

// Создание нового шрифта
$font = new Zend_Pdf_Font_Standard(Zend_Pdf_Const::FONT_HELVETICA);

// Применение шрифта и написание текста
$page1->setFont($font, 36);
$page1->drawText('Helvetica 36 text string', 60, 500);

// Использование объекта шрифта для других страниц
$page2->setFont($font, 24);
$page2->drawText('Helvetica 24 text string', 60, 500);

// Использование другого шрифта
$page2->setFont(new Zend_Pdf_Font_Standard(Zend_Pdf_Const::FONT_TIMES_ROMAN), 32);
$page2->drawText('Times-Roman 32 text string', 60, 450);

// Рисование прямоугольника
$page2->setFillColor(new Zend_Pdf_Color_GrayScale(0.8));
$page2->setLineColor(new Zend_Pdf_Color_GrayScale(0.2));
$page2->setLineDashingPattern(array(3, 2, 3, 4), 1.6);
$page2->drawRectangle(60, 400, 400, 350);

// Рисование круга
$page2->setLineDashingPattern(Zend_Pdf_Const::LINEDASHING_SOLID);
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 0, 0));
$page2->drawCircle(85, 375, 25);

// Рисование секторов
$page2->drawCircle(200, 375, 25, 2*M_PI/3, -M_PI/6);
$page2->setFillColor(new Zend_Pdf_Color_CMYK(1, 0, 0, 0));
$page2->drawCircle(200, 375, 25, M_PI/6, 2*M_PI/3);
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 1, 0));
$page2->drawCircle(200, 375, 25, -M_PI/6, M_PI/6);

// Рисование элипса
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 0, 0));
$page2->drawEllipse(250, 400, 400, 350);
$page2->setFillColor(new Zend_Pdf_Color_CMYK(1, 0, 0, 0));
$page2->drawEllipse(250, 400, 400, 350, M_PI/6, 2*M_PI/3);
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 1, 0));
$page2->drawEllipse(250, 400, 400, 350, -M_PI/6, M_PI/6);

// Рисование и заполнение многоугольника
$page2->setFillColor(new Zend_Pdf_Color_RGB(1, 0, 1));
$x = array();
$y = array();
for ($count = 0; $count < 8; $count++) {
    $x[] = 140 + 25*cos(3*M_PI_4*$count);
    $y[] = 375 + 25*sin(3*M_PI_4*$count);
}
$page2->drawPolygon($x, $y,
                    Zend_Pdf_Const::SHAPEDRAW_FILLNSTROKE,
                    Zend_Pdf_Const::FILLMETHOD_EVENODD);

// Рисование линии
$page2->setLineWidth(0.5);
$page2->drawLine(60, 375, 400, 375);
//------------------------------------------------------------------------------------

if (isset($argv[2])) {
    $pdf->save($argv[2]);
} else {
    $pdf->save($argv[1], true /* update */);
}
]]></programlisting>
    </example>

</sect1>


<!--
vim:se ts=4 sw=4 et:
-->
