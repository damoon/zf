<sect1 id="zend.db.table.row">

    <title>Zend_Db_Table_Row</title>

    <sect2 id="zend.db.table.row.introduction">

        <title>Введение<!--Introduction--></title>

        <para>
            Zend_Db_Table_Row является классом, содержащим отдельную строку
            объекта Zend_Db_Table. Когда вы производите запрос через класс
            таблицы, то результат возвращается в виде набора объектов
            Zend_Db_Table_Row. Вы также можете использовать этот объект для
            создания новых строк и их добавления в таблицу БД.
<!--
            Zend_Db_Table_Row is a class that contains an individual row
            of a Zend_Db_Table object.  When you run a query against a
            Table class, the result is returned in a set of Zend_Db_Table_Row
            objects.  You can also use this object to create new rows and
            add them to the database table.
-->
        </para>

        <para>
            Zend_Db_Table_Row является реализацией паттерна
            <ulink url="http://www.martinfowler.com/eaaCatalog/rowDataGateway.html">Row Data Gateway</ulink>.
<!--
            Zend_Db_Table_Row is an implementation of the
            <ulink url="http://www.martinfowler.com/eaaCatalog/rowDataGateway.html">Row Data Gateway</ulink>
            pattern.
-->
        </para>

    </sect2>

    <sect2 id="zend.db.table.row.read">

        <title>Извлечение строки<!--Fetching a Row--></title>

        <para>
            Zend_Db_Table_Abstract включает в себя методы <code>find()</code> и
            <code>fetchAll()</code>, которые возвращают объект типа
            Zend_Db_Table_Rowset, и метод <code>fetchRow()</code>, который
            возвращает объект типа Zend_Db_Table_Row.
<!--
            Zend_Db_Table_Abstract provides methods <code>find()</code> and
            <code>fetchAll()</code>, which each return an object of type
            Zend_Db_Table_Rowset, and the method <code>fetchRow()</code>,
            which returns an object of type Zend_Db_Table_Row.
-->
        </para>

        <example id="zend.db.table.row.read.example">
            <title>Пример извлечения строки<!--Example of fetching a row--></title>
            <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$row = $bugs->fetchRow('bug_id = 1');

?>]]></programlisting>
            </example>

        <para>
            Объект Zend_Db_Table_Rowset содержит коллекцию объектов
            Zend_Db_Table_Row. См. <xref linkend="zend.db.table.rowset" />.
<!--
            A Zend_Db_Table_Rowset object contains a collection of
            Zend_Db_Table_Row objects.
            See <xref linkend="zend.db.table.rowset" />.
-->
        </para>

        <example id="zend.db.table.row.read.example-rowset">
            <title>Пример получения строки из набора строк<!--Example of reading a row in a rowset--></title>
            <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$rowset = $bugs->fetchAll("bug_status = 'NEW'");
$row = $rowset->current();

?>]]></programlisting>
            </example>

        <sect3 id="zend.db.table.row.read.get">
            <title>Чтение значения столбца из строки<!--Reading column values from a row--></title>

            <para>
                Zend_Db_Table_Row_Abstract предоставляет методы доступа, поэтому
                можно ссылаться на столбцы в строке как на свойства объекта.
<!--
                Zend_Db_Table_Row_Abstract provides accessor methods so
                you can reference columns in the row as object properties.
-->
            </para>

            <example id="zend.db.table.row.read.get.example">
                <title>Пример чтения столбца в строке<!--Example of reading a column in a row--></title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$row = $bugs->fetchRow('bug_id = 1');

// Вывод значения столбца bug_description
echo $row->bug_description;

?>]]></programlisting>
            </example>

            <note>
                <para>
                    Более ранние версии Zend_Db_Table_Row сопоставляли
                    аксессоры столбцов с именами столбцов в БД с
                    использованием преобразования строк, называемого
                    <emphasis>инфлекцией</emphasis>.
<!--
                    Earlier versions of Zend_Db_Table_Row mapped these column
                    accessors to the database column names using a string
                    transformation called <emphasis>inflection</emphasis>.
-->
                </para>
                <para>
                    Теперь Zend_Db_Table_Row не реализует инфлекцию. Написание
                    аксессоров столбцов должно в точности соответствовать именам
                    столбцов, так, как они представлены в БД.
<!--
                    Current usage of Zend_Db_Table_Row does not implement
                    inflection.  The column accessor you use must match the
                    spelling of the column name as it appears in your database.
-->
                </para>
            </note>

        </sect3>

        <sect3 id="zend.db.table.row.read.to-array">
            <title>Получение данных строки в виде массива<!--Retrieving Row Data as an Array--></title>

            <para>
                Вы можете получить доступ к данным строки, используя метод
                <code>toArray()</code> объекта Row. Метод возвращает
                ассоциативный массив имен столбцов и их значений.
<!--
                You can access the row's data as an array using the
                <code>toArray()</code> method of the Row object.
                This returns an associative array of the colum names
                to the column values.
-->
            </para>

            <example id="zend.db.table.row.read.to-array.example">
                <title>Пример использования метода toArray()<!--Example of using the toArray() method--></title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$row = $bugs->fetchRow('bug_id = 1');

// Получение ассоциативного массива столбцов и их значений из объекта Row
$rowArray = $row->toArray();

// Теперь используется как обычный массив
foreach ($rowArray as $column => $value) {
    echo "Column: $column\n";
    echo "Value:  $value\n";
}

?>]]></programlisting>
            </example>

            <para>
                Массив, возвращаемый методом <code>toArray()</code> не может
                использоваться для обновления данных в БД. Мы можете изменять
                значения в этом массиве так же, как и в любом другом массиве, но
                не можете напрямую сохранять измененные значения этого массива в
                БД.
<!--
                The array returned from <code>toArray()</code> is not updateable.
                You can modify values in the array as you can with any array, but
                you cannot save changes to this array to the database directly.
-->
            </para>

        </sect3>

        <sect3 id="zend.db.table.row.read.relationships">
            <title>Извлечение данных из связанных таблиц<!--Fetching data from related tables--></title>

            <para>
                Класс Zend_Db_Table_Row_Abstract предоставляет методы для
                извлечения строк и наборов строк из связанных таблиц.
                Cм. <xref linkend="zend.db.table.relationships" /> для более
                подробной информации о связях между таблицами.
<!--
                The Zend_Db_Table_Row_Abstract class provides methods
                for fetching rows and rowsets from related tables.
                See <xref linkend="zend.db.table.relationships" />
                for more information on table relationships.
-->
            </para>
        </sect3>

    </sect2>

    <sect2 id="zend.db.table.row.write">

        <title>Редактирование строк в БД<!--Writing rows to the database--></title>

        <sect3 id="zend.db.table.row.write.set">
            <title>Изменение значений столбцов в строке<!--Changing column values in a row--></title>

            <para>
                Используя аксессоры столбцов, вы можете устанавливать значения
                отдельных столбцов по аналогии с чтением, т.е. так же, как если
                бы они были свойствами объекта.
<!--
                You can set individual columns using column accessors,
                similarly to reading columns as object properties.
-->
            </para>

            <para>
                Это изменяет значение столбца строки в вашем приложении, но
                эти изменение еще не фиксируется в БД. Вы можете выполнить
                фиксацию через метод <code>save()</code>.
<!--
                This changes the column value of the row as it exists
                in your application, but it does not commit the change
                to the database yet.  You can do that with the
                <code>save()</code> method.
-->
            </para>

            <example id="zend.db.table.row.write.set.example">
                <title>Пример изменения значения столбца в строке<!--Example of changing a column in a row--></title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$row = $bugs->fetchRow('bug_id = 1');

// Изменение значения одного или более столбцов
$row->bug_status = 'FIXED';

// Обновление строки в БД с использованием новых значений
$row->save();

?>]]></programlisting>
            </example>

            <note>
                <para>
                    В настоящее время Zend_Db_Table_Row_Abstract бросает
                    исключение, если вы пытаетесь установить значение столбца
                    первичного ключа. Это поведение планируется изменить в
                    версии 1.0. Класс Row должен позволять устанавливать
                    значения столбцов первичного ключа для поддержки
                    последовательностей и естетственных первичных ключей.
<!--
                    Currently Zend_Db_Table_Row_Abstract throws an exception
                    if you try to set the value of the primary key column(s)
                    in the row.  This is intended to change in Zend Framework
                    1.0.  The Row class should permit the primary key columns
                    to be set, to support sequences and natural primary keys.
-->
                </para>
            </note>

        </sect3>

        <sect3 id="zend.db.table.row.write.insert">
            <title>Добавление новой строки<!--Inserting a new row--></title>

            <para>
                Вы можете создавать новые строки для определенной таблицы с
                помощью метода <code>fetchNew()</code> класса таблицы.
<!--
                You can create a new row for a given table with the
                <code>fetchNew()</code> method of the table class.
-->
            </para>

            <example id="zend.db.table.write.insert.example">
                <title>Пример создания новой строки таблицы<!--Example of creating a new row for a table--></title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$newRow = $bugs->fetchNew();

// Установка значений столбцов
$newRow->bug_description = '...description...';
$newRow->bug_status = 'NEW';

// Добавление новой строки в БД
$newRow->save();

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.row.write.set-from-array">
            <title>Изменение значений в нескольких столбцах<!--Changing values in multiple columns--></title>

            <para>
                Zend_Db_Table_Row_Abstract предоставляет метод
                <code>setFromArray()</code> для того, чтобы можно было
                устанавливать значения нескольких столбцов одновременно,
                определив ассоциативный массив имен столбцов и их значений.
                Этот метод может быть удобным как при создании новых строк, так
                и при обновлении существующих.
<!--
                Zend_Db_Table_Row_Abstract provides the 
                <code>setFromArray()</code> method to enable you to set several
                columns at once, specified in an associative array
                mapping column names to values.
                You may find this method convenient for setting values
                both for new rows and for rows you need to update.
-->
            </para>

            <example id="zend.db.table.write.set-from-array.example">
                <title>Пример использования метода setFromArray() для установки
                значений в новой строке<!--Example of using setFromArray() to set values in a new Row--></title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$newRow = $bugs->fetchNew();

// Данные помещаются в ассоциативный массив
$data = array(
    'bug_description' => '...description...',
    'bug_status'      => 'NEW'
);

// Одновременная установка значений всех столбцов
$newRow->setFromArray($data);

// Добавление новой строки в БД
$newRow->save();

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.row.write.delete">
            <title>Удаление строки<!--Deleting a row--></title>

            <para>
                Вы можете вызывать метод <code>delete()</code> объекта Row. Этот
                метод удаляет из таблицы строки, соответствующие первичному
                ключу в объекте Row.
<!--
                You can call the <code>delete()</code> method on a Row
                object.  This deletes rows in the database matching the
                primary key in the Row object.
-->
            </para>

            <example id="zend.db.table.row.write.delete.example">
                <title>Пример удаления строки<!--Example of deleting a row--></title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$row = $bugs->fetchRow('bug_id = 1');

// Удаление строки
$row->delete();

?>]]></programlisting>
            </example>

            <para>
                Вы не должны вызывать <code>save()</code> для фиксации удаления,
                оно сразу же выполняется в БД.
<!--
                You do not have to call <code>save()</code> to apply
                the delete; it is executed against the database immediately.
-->
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.row.serialize">

        <title>Сериализация и десериализация строк<!--Serializing and unserializing rows--></title>

        <para>
            Часто бывает удобным сохранять содержимое строки БД для последующего
            использования. <emphasis>Сериализацией</emphasis> называется
            действие по преобразованию объекта в форму, удобную для хранения в
            автономном хранилище (например, в файле). Объекты типа
            Zend_Db_Table_Row_Abstract доступны для сериализации.
<!--
            It is often convenient to save the contents of a database row
            to be used later.  <emphasis>Serialization</emphasis> is the
            name for the operation to convert an object into a form that is
            easy to save in offline storage (for example, a file).
            Objects of type Zend_Db_Table_Row_Abstract are serializable.
-->
        </para>

        <sect3 id="zend.db.table.row.serialize.serializing">
            <title>Сериализация строки<!--Serializing a Row--></title>

            <para>
                Просто используйте функцию PHP <code>serialize()</code> для
                получения строки, содержащей представление объекта Row в виде
                последовательности байт.
<!--
                Simply use PHP's <code>serialize()</code> function to
                create a string containing a byte-stream representation
                of the Row object argument.
-->
            </para>

            <example id="zend.db.table.row.serialize.serializing.example">
                <title>Пример сериализации строки<!--Example of serializing a row--></title>
                <programlisting role="php"><![CDATA[<?php

$bugs = new Bugs();
$row = $bugs->fetchRow('bug_id = 1');

// Преобразование объекта в сериализированную форму
$serializedRow = serialize($row);

// Теперь вы можете записать $serializedRow в файл и т.д.

?>]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.table.row.serialize.unserializing">
            <title>Десериализация данных строки<!--Unserializing Row Data--></title>

            <para>
                Используйте функцию <code>unserialize()</code> для
                восстановления из строки, содержащей представление объекта в
                виде последовательности байт. 
<!--
                Use PHP's <code>unserialize()</code> function to
                restore a string containing a byte-stream representation
                of an object.  The function returns the original object.
-->
            </para>

            <para>
                Внимание: объект Row возвращается
                <emphasis>без соединения</emphasis>. Вы можете читать объект Row
                и его свойства, но вы не можете изменять значения в строке или
                выполнять другие методы, требующие соединения с БД (например,
                запросы к связанным таблицам).
<!--
                Note that the Row object returned is in a
                <emphasis>disconnected</emphasis> state.
                You can read the Row object and its properties, but you
                cannot change values in the Row or execute other methods
                that require a database connection (for example, queries
                against related tables).
-->
            </para>

            <example id="zend.db.table.row.serialize.unserializing.example">
                <title>Пример десериализации сериализованной строки<!--Example of unserializing a serialized row--></title>
                <programlisting role="php"><![CDATA[<?php

$rowClone = unserialize($serializedRow);

// Теперь вы можете использовать свойства объекта, но только для чтения
echo $rowClone->bug_description;

?>]]></programlisting>
            </example>

            <note>
                <title>Почему объекты строки десериализируются в состояние без соединения?<!--Why do Rows unserialize in a disconnected state?--></title>
                <para>
                    Сериализированный объект является строкой, которая доступна
                    для чтения всем, кто ею обладает.
                    Это создает угрозу безопасности, которая состоит в 
                    том, что в сериализированной строке сохраняются такие
                    параметры, как логин и пароль для соединения с БД, в
                    незашифрованном виде.
                    Для вас может быть нежелательным сохранять такие данные в
                    незащищенном текстовом файле или отправлять его через e-mail
                    или любой другой носитель, который может быть прочитан
                    потенциальным атакующим.
                    Тот, кто прочитает сериализированный объект, не должен иметь
                    возможности использовать его в получении
                    несанкционированного доступа к БД.
<!--
                    A serialized object is a string that is readable to
                    anyone who possesses it.
                    It could be a security risk to store parameters such
                    as database account and password in plain, unencrypted
                    text in the serialized string.
                    You would not want to store such data to a text file that
                    is not protected, or send it in an email or other medium
                    that is easily read by potential attackers.
                    The reader of the serialized object should not be able
                    to use it to gain access to your database without
                    knowing valid credentials.
-->
                </para>
            </note>

        </sect3>

        <sect3 id="zend.db.table.row.serialize.set-table">
            <title>Восстановление соединения для строк<!--Reactivating a Row as Live Data--></title>

            <para>
                Вы можете восстановить соединение для строки, используя метод
                <code>setTable()</code>. Аргументом этого метода является объект
                типа Zend_Db_Table_Abstract, который создается вами. Создание
                объекта таблицы требует действующего соединения с БД, поэтому
                при переустановке таблицы объект строки получает доступ к БД.
                После этого вы можете изменять значения в объекте строки и
                сохранять изменения в БД.
<!--
                You can reactivate a disconnected Row, using the
                <code>setTable()</code> method.  The argument to this
                method is a valid object of type Zend_Db_Table_Abstract,
                which you create.  Creating a Table object requires a
                live connection to the database, so by reassociating
                the Table with the Row, the Row gains access to 
                the database.  Subsequently, you can change values in
                the Row object and save the changes to the database.
-->
            </para>

            <example id="zend.db.table.row.serialize.set-table.example">
                <title>Пример восстановления соединения для строки<!--Example of reactivating a row--></title>
                <programlisting role="php"><![CDATA[<?php

$rowClone = unserialize($serializedRow);

$bugs = new Bugs();

// Привязка строки к таблице с действующим соединением БД
$rowClone->setTable($bugs);

// Теперь вы можете производить изменения в строке и сохранять их
$rowClone->bug_status = 'FIXED';
$rowClone->save();

?>]]></programlisting>
            </example>

        </sect3>

    </sect2>

    <sect2 id="zend.db.table.row.extending">

        <title>Расширение класса строки<!--Extending the Row class--></title>

        <sect3 id="zend.db.table.row.extending.overriding">
            <title>Определение собственной логики для добавления, обновления и
            удаления в Zend_Db_Table_Row<!--Defining Custom Logic for Insert, Update, and Delete in Zend_Db_Table_Row--></title>

            <para>
                <emphasis>Текст в процессе написания.</emphasis>
<!--
                <emphasis>To be written.</emphasis>
-->
            </para>

        </sect3>

        <sect3 id="zend.db.table.row.extending.inflection">
            <title>Определение инфлекции в Zend_Db_Table_Row<!--Define Inflection in Zend_Db_Table_Row--></title>

            <para>
                Некоторые разработчики предпочитают, чтобы имя класса таблицы
                сопоставлялось с именем таблицы в СУРБД с использованием
                трансформации, называемой <emphasis>инфлекцией</emphasis>.
<!--
                Some people prefer that the table class name match a table
                name in the RDBMS by using a string transformation called
                <emphasis>inflection</emphasis>.
-->
            </para>

            <para>
                Классы Zend_Db по умолчанию не производят
                <emphasis>инфлекцию</emphasis>. Причины такого решения приведены
                в <xref linkend="zend.db.table.extending.inflection" />.
<!--
                Zend_Db classes do not implement inflection by default.
                See <xref linkend="zend.db.table.extending.inflection" />
                for a description of this design policy.
-->
            </para>

            <para>
                Если вы предпочитаете использовать инфлекцию, то должны сами
                реализовать преобразование, переопределив метод
                <code>_transformColumn()</code> в своем классе строки и
                использовать этот класс при произведении запросов через ваш
                класс таблицы.
<!--
                If you prefer to use inflection, then you must implement
                the transformation yourself, by overriding the
                <code>_transformColumn()</code> method in a custom Row class,
                and using that custom Row class when you perform queries
                against your Table class.
-->
            </para>

            <example id="zend.db.table.row.extending.inflection.example">
                <title>Пример определения инфлекционного преобразования<!--Example of defining an inflection transformation--></title>

                <para>
                    <emphasis>В процессе написания.</emphasis>
<!--
                    <emphasis>To be written.</emphasis>
-->
                </para>

            </example>

        </sect3>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
