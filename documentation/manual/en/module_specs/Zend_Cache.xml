<sect1 id="zend.cache.introduction">
    <title>Introduction</title>
    <para>
        <code>Zend_Cache</code> provides a generic way to cache some datas.
    </para>
    <para>
        Cache records are stored through a backend (<code>File</code>, <code>Sqlite</code>...) with a flexible
        system of "ids" and "tags". Then, for example, it's easy to delete a specified part of cached 
        datas ("all cache records marked with a given tag"...).
    </para>
    <para>
    	The core of the module is really generic and flexible. Yet, for specific needs, you can use a
    	frontend (<code>Output</code>, <code>Function</code>...) to get a more appropriate way of running.
    </para>
    <example>
        <title>A first example with Zend_Cache core</title>
        <para>
            In this first example, we will use directly the core of Zend_Cache with the 
            <code>File</code> backend.
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
	'lifeTime' => 7200 // cache lifetime of 2 hours
);

$backendOptions = array(
    'cacheDir' => '/tmp/' // Directory where to put the cache files (make sure to add a trailing slash)
);

// We make a Zend_Cache_Core object
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

$id = 'foo'; // cache id of "what we want to cache"

if (!($cache->test($id))) {
	// cache missed
	
	// require_once ... for perfs reasons, all "require_once" have to be loaded ONLY if the cache is missed
	// require_once ...
	
	// we build "what we want to cache"
	// for example
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	} 
	
	// We save the result into the cache
    $cache->save($data);

} else {
	// cache hit
	
	$data = $cache->get($id);

}

// do something with $data :)
// [...]
?>]]>       </programlisting>
       </para>
    </example>
    <note>
        With Zend_Cache_Core, you have to manage the "cache identifier" by yourself.  
    </note>
</sect1>

<sect1 id="zend.cache.factory">
    <title>Zend_Cache factory</title>
    <para>
    	There is only one way to build a <code>Zend_Cache_*</code> object. In all cases 
    	(backends and/or frontends), you have to use the <code>Zend_Cache</code> factory.
    	Do not use frontends constructors directly, it won't work correctly !  
    </para>
    <para>
    	The good way to build an usable instance of <code>Zend_Cache_*</code> is given
    	in the following example :
    	<programlisting role="php"><![CDATA[<?php
    	
# We "load" the Zend_Cache factory 
require 'Zend/Cache.php'; 

# We choose a backend (for example 'File' or 'Sqlite'...)
$backendName = '[...]';

# We choose a frontend (for example 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# We set an array of options for the choosen frontend
$frontendOptions = array([...]);

# We set an array of options for the choosen backend
$backendOptions = array([...]);

# We make the good instance 
# (of course, the two last arguments are optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

[...]

?>]]>   </programlisting> 
    </para> 
    <para>
    	In next lines of this documentation, we will assume that the <code>$cache</code>
    	variable is set as shown in the previous example.    	
    </para> 
</sect1>

<sect1 id="zend.cache.core">
    <title>Zend_Cache_Core</title>
    <sect2 id="zend.cache.core.introduction">
    	<title>Introduction</title>
    	<para>
    		<code>Zend_Cache_Core</code> is a special frontend because it's actually the core
    		of the module. All frontends inherit from this class. So most of methods and options
    		described below are also available for other frontends.
    	</para>
    </sect2>
    <sect2 id="zend.cache.core.options">
    	<title>Available options (for this frontend in Zend_Cache factory)</title>
	    <table>
    		<title>Available options</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Option</entry>
				        <entry>Data Type</entry>
				        <entry>Default Value</entry>
				        <entry>Description</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>caching</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
      						enable / disable caching (can be very usefull for the debug of 
      						cached scripts)	        	
      					</entry>
      				</row>
      				<row>
      					<entry><code>lifeTime</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>3600</code></entry>
      					<entry>
        					cache lifetime (in seconds), if set to <code>null</code>, the 
        					cache is valid forever.       
      					</entry>
      				</row>
      				<row>
      					<entry><code>logging</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>false</code></entry>
      					<entry>
        					if set to true, logging through <code>Zend_Log</code> is activated 
        					(but the system is slower) 	    
      					</entry>
      				</row>
      				<row>
      					<entry><code>writeControl</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Enable / disable write control (the cache is read 
        					just after writing to detect corrupt entries), enabling writeControl
        					will lightly slow the cache writing but not the cache reading (it 
        					can detect some corrupt cache files but it's not a perfect control)	    
      					</entry>
      				</row>
      				<row>
      					<entry><code>automaticSerialization</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>false</code></entry>
      					<entry>
        					Enable / disable automatic serialization, it can be used to save directly datas
	        				which aren't strings (but it's slower)		    
      					</entry>
      				</row>
      				<row>
      					<entry><code>automaticCleaningFactor</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0</code></entry>
      					<entry>
        					Disable / Tune the automatic cleaning process (garbage collector) :
        					0 means no automatic cache cleaning, 1 means systematic cache cleaning
        					and x (integer) &gt; 1 means automatic cleaning randomly 1 times on x cache write.
      					</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    </sect2>
    <sect2 id="zend.cache.core.examples">
    	<title>Examples</title>
    	<para>
    		A first example is given in the tutorial at the very beginning.
    	</para>
    	<para>
    		If you store only strings into cache (because with "automaticSerialization" option, it's possible to store
			some booleans), you can use a more compact construction like :
     	    <programlisting role="php"><![CDATA[<?php  
     	    
// [...] // require, configuration and factory

$id = 'foo'; // cache id of "what we want to cache"

if (!($data = $cache->get($id))) {
	// cache missed
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	}
	
    $cache->save($data);
    
} 

// [...] do something with $data (for example "echo $data;")
     	    
?>]]>       </programlisting> 
        </para>  
        <para>
        	If you want to cache multiple blocks or datas, the idea is the same :
     	    <programlisting role="php"><![CDATA[<?php  
     	    
// [...] // require, configuration and factory

$id1 = 'foo'; // cache id of block1
$id2 = 'bar'; // cache id of block2

// BLOCK1
if (!($data = $cache->get($id1))) {
	// cache missed
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . $i;
	}
	
    $cache->save($data);
    
} 
echo($data);

// NEVER CACHED BLOCK
echo('NEVER CACHED !');

// BLOCK2
if (!($data = $cache->get($id2))) {
	// cache missed
	
	$data = '';
	for ($i=0;$i<10000;$i++) {
		$data = $data . '!';
	}
	
    $cache->save($data);
    
} 
echo($data);


?>]]>       </programlisting>         	
        </para>   	 	
    </sect2>   
    <sect2 id="zend.cache.core.idandtags">
    	<title>Cache ID and tags</title>
    	<para>
    		A "cache id" is an unique key which identifies a given cache record. In some frontends
    		(Core, Output...), you have to deal with "cache ids" by yourself. So, for example,
    		be carefull to use an unique id for a given page or block.
    	</para>
    	<para>
    		"tags" are a way to categorize cache records. When you save a cache with the <code>save()</code>
    		method, you can set an array of tags to apply for this record. Then, you will be 
    		able to clean all cache records tagged with a given tag... It's a really powerful
    		way to manage cache records by groups.
    	</para>
    	<para>
    		Here is the complete syntax of the <code>save()</code> method :
    		<programlisting role="php"><![CDATA[<?php
     	    
    /**
     * Save some data in a cache 
     * 
     * @param mixed $data data to put in cache (can be another type than string if automaticSerialization is on)
     * @param cache $id cache id (if not set, the last cache id will be used)
     * @param array $tags cache tags
     * @return boolean true if no problem
     */
    public function save($data, $id = null, $tags = array()) {}
    		
?>]]>       </programlisting>    	 
			So for example, you can use :
			<programlisting role="php"><![CDATA[<?php
			
// [...]
$cache->save('data to store', 'uniqueID', array('tag1', 'tag4', 'tag5'));
// [...]	
			
?>]]>       </programlisting> 						   	
    	</para>
    </sect2>
    <sect2 id="zend.cache.core.clean">
    	<title>clean the cache</title>
    	<para>
    		To remove/invalidate in particular cache id, you can use the <code>remove()</code>
    		method :
     	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->remove('idToRemove');
// [...]
    		
?>]]>       </programlisting>    		
    	</para>
    	<para>
    		To remove/invalidate several cache ids in one operation, you can use the <code>clean()</code>
    		method. For example to remove all cache records :
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);
// [...]
    		
?>]]>       </programlisting>     		
			If you want to remove only outdated cache records :
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
// [...]
    		
?>]]>       </programlisting>    
			If you want to remove cache entries matching the tags 'tag1' and 'tag3' :
      	    <programlisting role="php"><![CDATA[<?php 
     	    
// [...]
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tag1', 'tag3'));
// [...]
    		
?>]]>       </programlisting>
			[...]	
    	</para>
    </sect2>
</sect1>
<sect1 id="zend.cache.output">
    <title>Zend_Cache_Output</title>
    <para>
    	TO BE WRITTEN
    </para>
</sect1>    
<sect1 id="zend.cache.page">
    <title>Zend_Cache_Page</title>
    <para>
    	TO BE WRITTEN
    </para>
</sect1>  
<sect1 id="zend.cache.file">
    <title>Zend_Cache_File</title>
    <para>
    	TO BE WRITTEN
    </para>
</sect1> 
<sect1 id="zend.cache.function">
    <title>Zend_Cache_Function</title>
    <para>
    	TO BE WRITTEN
    </para>
</sect1> 
<sect1 id="zend.cache.class">
    <title>Zend_Cache_Class</title>
    <para>
    	TO BE WRITTEN
    </para>
</sect1> 
<sect1 id="zend.cache.backends">
    <title>Available backends for Zend_Cache</title>
    <sect2 id="zend.cache.backends.file">
    	<title>Zend_Cache_Backend_File</title>
    	<para>
    		This backends stores cache records into files (in a choosen directory). 
    	</para>
    	<para>
    		Available options are :
    	</para>  		
	    <table>
    		<title>Available options</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Option</entry>
				        <entry>Data Type</entry>
				        <entry>Default Value</entry>
				        <entry>Description</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>cacheDir</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>'/tmp/'</code></entry>
      					<entry>
      						Directory where to store cache files
      						(make sure to add a trailing slash)  	
      					</entry>
      				</row>
      				<row>
      					<entry><code>fileLocking</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Enable / disable fileLocking : Can avoid cache corruption under 
        					bad circumstances but it doesn't help on multithread webservers 
        					or on NFS filesystems...
      					</entry>
      				</row>
      				<row>
      					<entry><code>readControl</code></entry>
      					<entry><code>boolean</code></entry>
      					<entry><code>true</code></entry>
      					<entry>
        					Enable / disable read control : if enabled, a control key is 
        					embeded in the cache file and this key is compared with the 
        					one calculated after the reading.	    
      					</entry>
      				</row>
      				<row>
      					<entry><code>readControlType</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>'crc32'</code></entry>
      					<entry>
        					Type of read control (only if read control is enabled). Available values are :
        					'md5' (best but slowest), 'crc32' (lightly less safe but faster, better choice),
        					'strlen' for a length only test (fastest).
        				</entry>
      				</row>
      				<row>
      					<entry><code>hashedDirectoryLevel</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0</code></entry>
      					<entry>
        					Hashed directory structure level : 	0 means "no hashed directory 
     						structure", 1 means "one level of directory", 2 means "two levels"... 
     						This option can speed up the cache only when you have many thousands of 
     						cache files. Only specific benchs can help you to choose the perfect 
     						value for you. Maybe, 1 or 2 is a good start.
      					</entry>
      				</row>
      				<row>
      					<entry><code>hashedDirectoryUmask</code></entry>
      					<entry><code>int</code></entry>
      					<entry><code>0700</code></entry>
      					<entry>
      						Umask for the hashed directory structure
        				</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
    	<title>Zend_Cache_Backend_Sqlite</title>
    	<para>
    		This backends stores cache records into a SQLite database.
    	</para>
    	<para>
    		Available options are :
    	</para>
    	<table>
    		<title>Available options</title>
    		<tgroup cols="4">
     			<thead>
      				<row>
       					<entry>Option</entry>
				        <entry>Data Type</entry>
				        <entry>Default Value</entry>
				        <entry>Description</entry>
				    </row>
     			</thead>
     			<tbody>
      				<row>
      					<entry><code>cacheDBCompletePath (mandatory)</code></entry>
      					<entry><code>string</code></entry>
      					<entry><code>null</code></entry>
      					<entry>
      						The complete path (filename included) of the SQLite database
      					</entry>
      				</row>
      			</tbody>
      		</tgroup>
      	</table>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->