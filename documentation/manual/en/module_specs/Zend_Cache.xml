<sect1 id="zend.cache.introduction">
    <title>Introduction</title>
    <para>
        <code>Zend_Cache</code> provides a generic way to cache any data.
    </para>
    <para>
      Caching in Zend Framework is operated by frontends while cache records are stored through backend adapters
      (<code>File</code>, <code>Sqlite</code>, <code>Memcache</code>...) through a flexible
      system of IDs and tags. Using those, it is easy to delete specific types of records afterwards
      (for example: "delete all cache records marked with a given tag").
    </para>
    <para>
        The core of the module (<code>Zend_Cache_Core</code>) is generic, flexible and configurable.
        Yet, for your specific needs there are cache frontends that extend <code>Zend_Cache_Core</code>
        for convinience: <code>Output</code>, <code>File</code>, <code>Function</code> and <code>Class</code>.
    </para>
    <example>
        <title>Getting a frontend with <code>Zend_Cache::factory()</code></title>
        <para>
            <code>Zend_Cache::factory()</code> instantiates correct objects and ties them together.
            In this first example, we will use <code>Core</code> frontend together with <code>File</code>
            backend.
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' => 7200, // cache lifetime of 2 hours 
   'automaticSerialization' => true
);

$backendOptions = array(
    'cacheDir' => './tmp/' // Directory where to put the cache files
);

// getting a Zend_Cache_Core object
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?>]]></programlisting>
       </para>
       <para>
            Now that we have a frontend, we can cache any type of data (we turned on serialization). For
            example, we can cache a result from a very expensive database query. After it is cached, there
            is no need to even connect to the database; records are fetched from cache and unserialized.
            <programlisting role="php"><![CDATA[<?php

// $cache initialized in previous example

// see if a cache already exists:
if(!$result = $cache->get('myresult')) {

    // cache miss; connect to the database
    
    $db = Zend_Db::factory( [...] );
    
    $result = $db->fetchAll('SELECT * FROM huge_table');
    
    $cache->save($result, 'myresult');
    
} else {

    // cache hit! shout so that we know
    echo "This one is from cache!\n\n";
    
}

print_r($result);

?>]]></programlisting>
       </para>
    </example>
    <example>
        <title>Caching output with <code>Zend_Cache</code> output frontend</title>
        <para>
            We 'mark up' sections in which we want to cache output by adding some conditional logic,
            encapsulating the section within <code>start()</code> and <code>end()</code> methods (this
            resembles the first example and is the core strategy for caching).
        </para><para>
            Inside, output your data as usual - all output will be cached when execution hits the <code>end()</code>
            method. On the next run, the whole section will be skipped in favor of fetching data from cache 
            (as long as the cache record is valid).
            <programlisting role="php"><![CDATA[<?php

$frontendOptions = array(
   'lifeTime' => 30,                  // cache lifetime of half a minute
   'automaticSerialization' => false  // this is default anyway
);

$backendOptions = array('cacheDir' => './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// we pass a unique identifier to the start() method
if(!$cache->start('mypage')) {
    // output as usual:
    
    echo 'Hello world! ';
    echo 'This is cached ('.time().') ';
    
    $cache->end(); // the output is saved and sent to the browser
}

echo 'This is never cached ('.time().').';

?>]]>       </programlisting>
       </para>
       <para>
           Notice that we output the result of <code>time()</code> twice; this is something dynamic
           for demonstration purposes. Try running this and then refreshing several times; you will notice
           that the first number doesn't change while second changes as time passes. That is because the first
           number was output in the cached section and is saved among other output.
           After half a minute (we've set lifetime to 30 seconds) the
           numbers should match again because the cache record expired -- only to be cached again. You
           should try this in your brower or console.
       </para>
    </example>
    <note><para>
        When using Zend_Cache, pay attention to the important cache identifier (passed to <code>save()</code>
        and <code>start()</code>). It must be unique for every resource you cache, otherwise unrelated
        cache records may wipe each other or, even worse, be displayed in place of the other.
    </para></note>
</sect1>


<sect1 id="zend.cache.theory">
    <title>The theory of caching</title>
    <para>
        There are three key concepts in Zend_Cache. One is the unique indentifier (a string) that is used
        to identify cache records. The second one is the <code>'lifeTime'</code> directive as seen in the
        examples; it defines for how long the cached resource is considered 'fresh'. The third key concept
        is conditional execution so that parts of your code can be skipped entirely, boosting performance.
        The main frontend function (eg. <code>Zend_Cache_Core::get()</code>) is always designed to return
        false for a cache miss if that makes sense for the nature of a frontend. That enables end-users to
        wrap parts of the code they would like to cache (and skip) in <code>if(){ ... }</code> statements where
        the condition is a Zend_Cache method itself. On the end if these blocks you must save what you've
        generated, however (eg. <code>Zend_Cache_Core::save()</code>).
    </para>
    <note><para>
        The conditional execution design of your generating code is not necessary in some frontends
        (<code>Function</code>, for an example) when the whole logic is implemented inside the frontend.
    </para></note>
    <note><para>
        'Cache hit' is a term for a condition when a cache record is found, is valid and is 'fresh' (in other
        words hasn't expired yet). 'Cache miss' is everything else. When a cache miss happens, you must
        generate your data (as you would normally do) and have it cached. When you have a cache hit, on the
        other hand, the backend automatically fetches the record from cache transparently.
    </para></note>
    <sect2 id="zend.cache.factory">
        <title>The <code>Zend_Cache</code> factory method</title>
        <para>
            A good way to build a usable instance of a <code>Zend_Cache</code> Frontend is given
            in the following example :
            <programlisting role="php"><![CDATA[<?php
        
# We "load" the Zend_Cache factory 
require 'Zend/Cache.php'; 

# We choose a backend (for example 'File' or 'Sqlite'...)
$backendName = '[...]';

# We choose a frontend (for example 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

# We set an array of options for the choosen frontend
$frontendOptions = array([...]);

# We set an array of options for the choosen backend
$backendOptions = array([...]);

# We make the good instance 
# (of course, the two last arguments are optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);

?>]]></programlisting> 
        </para> 
        <para>
            In the following examples we will assume that the <code>$cache</code> variable holds a
            valid, instantiated frontend as already shown.
        </para>
        <note><para>
            Always use <code>Zend_Cache::factory()</code> to get frontend instances. Instantiating
            frontends and backends yourself will not work as expected.
        </para></note>
    </sect2>
    
    <sect2 id="zend.cache.tags">
        <title>Tagging records</title>
        <para>
            Tags are a way to categorize cache records. When you save a cache with the <code>save()</code>
            method, you can set an array of tags to apply for this record. Then you will be 
            able to clean all cache records tagged with a given tag (or tags):
        <programlisting role="php"><![CDATA[<?php
             
$cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));
            
?>]]></programlisting></para>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>Cleaning the cache</title>
        <para>
            To remove/invalidate in particular cache id, you can use the <code>remove()</code>
            method :
             <programlisting role="php"><![CDATA[<?php 
             
$cache->remove('idToRemove');
            
?>]]></programlisting>            
        </para>
        <para>
            To remove/invalidate several cache ids in one operation, you can use the <code>clean()</code>
            method. For example to remove all cache records :
              <programlisting role="php"><![CDATA[<?php 

// clean all records
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// clean only outdated
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
            
?>]]>       </programlisting>    
            If you want to remove cache entries matching the tags 'tagA' and 'tagC':
              <programlisting role="php"><![CDATA[<?php 
             
$cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('tagA', 'tagC'));
            
?>]]>       </programlisting>
        </para>
        <para>
            Available cleaning modes are: <code>CLEANING_MODE_ALL</code>, <code>CLEANING_MODE_OLD</code>,
            <code>CLEANING_MODE_MATCHING_TAG</code> and <code>CLEANING_MODE_NOT_MATCHING_TAG</code>. The
            latter are, as their names suggest, combined with an array of tags in cleaning operations.
        </para>
    </sect2>
</sect1>

<sect1 id="zend.cache.frontends">
    <title>Zend_Cache frontends</title>
    
    <sect2 id="zend.cache.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.core.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Core</code> is a special frontend because it is the core
                of the module. It is a generic cache frontend and is extended by other classes.
            </para>
            <note><para>
                All frontends inherit from <code>Zend_Cache_Core</code> so that its methods and options
                (described below) would also be available in other frontends, therefore they won't be
                documented there.
            </para></note>
        </sect3>
        <sect3 id="zend.cache.core.options">
            <title>Available options</title>
            <para>
                These options are passed to the factory method as demonstrated in previous examples.
            </para>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  enable / disable caching (can be very usefull for the debug of 
                                  cached scripts)                
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifeTime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                cache lifetime (in seconds), if set to <code>null</code>, the 
                                cache is valid forever.       
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                if set to true, logging through <code>Zend_Log</code> is activated 
                                (but the system is slower)         
                              </entry>
                          </row>
                          <row>
                              <entry><code>writeControl</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Enable / disable write control (the cache is read 
                                just after writing to detect corrupt entries), enabling writeControl
                                will lightly slow the cache writing but not the cache reading (it 
                                can detect some corrupt cache files but it's not a perfect control)        
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticSerialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Enable / disable automatic serialization, it can be used to save directly datas
                                which aren't strings (but it's slower)            
                              </entry>
                          </row>
                          <row>
                              <entry><code>automaticCleaningFactor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>0</code></entry>
                              <entry>
                                Disable / Tune the automatic cleaning process (garbage collector):
                                0 means no automatic cache cleaning, 1 means systematic cache cleaning
                                and x &gt; 1 means automatic random cleaning 1 times in x write operations.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        
        <sect3 id="zend.cache.core.examples">
            <title>Examples</title>
            <para>
                A first example is given in the tutorial at the very beginning.
            </para>
            <para>
                If you store only strings into cache (because with "automaticSerialization" option, it's possible
                to store some booleans), you can use a more compact construction like:
                 <programlisting role="php"><![CDATA[<?php  
                 
    // [...] // require, configuration and factory
    
    $id = 'foo'; // cache id of "what we want to cache"
    
    if (!($data = $cache->get($id))) {
        // cache missed
        
        $data = '';
        for ($i=0;$i<10000;$i++) {
            $data = $data . $i;
        }
        
        $cache->save($data);
        
    } 
    
    // [...] do something with $data (for example "echo $data;")
                 
    ?>]]>       </programlisting> 
            </para>  
            <para>
                If you want to cache multiple blocks or datas, the idea is the same :
                 <programlisting role="php"><![CDATA[<?php  
                 
    // [...] // require, configuration and factory
    
    $id1 = 'foo'; // cache id of block1
    $id2 = 'bar'; // cache id of block2
    
    // BLOCK1
    if (!($data = $cache->get($id1))) {
        // cache missed
        
        $data = '';
        for ($i=0;$i<10000;$i++) {
            $data = $data . $i;
        }
        
        $cache->save($data);
        
    } 
    echo($data);
    
    // NEVER CACHED BLOCK
    echo('NEVER CACHED !');
    
    // BLOCK2
    if (!($data = $cache->get($id2))) {
        // cache missed
        
        $data = '';
        for ($i=0;$i<10000;$i++) {
            $data = $data . '!';
        }
        
        $cache->save($data);
        
    } 
    echo($data);
    
    
    ?>]]>       </programlisting>             
            </para>            
        </sect3>   
    </sect2>
    
    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Introduction</title>
            <para>
                <code>Zend_Cache_Frontend_File</code> is a frontend driven by the 
                modification time of a "master file". It's really interesting for examples
                in configuration or templates issues.
            </para>
            <para> 
            	For instance, you have an XML configuration file which is parsed by a function 
            	which returns a "config object" (like with <code>Zend_Config</code>). With
            	<code>Zend_Cache_Frontend_File</code>, you can store the "config object" into
            	cache (to avoid the parsing of the XML config file at each time) but with a
            	sort of strong dependency on the "master file". So, if the XML config file
            	is modified, the cache is immediatly invalidated.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Available options (for this frontend in Zend_Cache factory)</title>
            <table>
                <title>Available options</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Data Type</entry>
                            <entry>Default Value</entry>
                            <entry>Description</entry>
                        </row>
                     </thead>
                     <tbody>
                     	<row>
    				        <entry>[...]</entry>
    				        <entry>[...]</entry>
    				        <entry>[...]</entry>
    				        <entry>See Zend_Cache_Core for inherited options</entry>
    				     </row>
                         <row>
                              <entry><code>masterFile (mandatory)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  the complete path and name of the master file                 
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>   
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Examples</title>
            <para>
                The use of this frontend is the same than <code>Zend_Cache_Core</code>. There
                is no need of a specific example. The only thing to do is to 
                define the <code>masterFile</code> backend option when using the factory.
            </para>
        </sect3>
    </sect2>
</sect1>

<sect1 id="zend.cache.backends">
    <title>Zend_Cache backends</title>
    
    <sect2 id="zend.cache.backends.file">
        <title>Zend_Cache_Backend_File</title>
        <para>
            This backends stores cache records into files (in a choosen directory). 
        </para>
        <para>
            Available options are :
        </para>          
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDir</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'/tmp/'</code></entry>
                          <entry>
                              Directory where to store cache files    
                          </entry>
                      </row>
                      <row>
                          <entry><code>fileLocking</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Enable / disable fileLocking : Can avoid cache corruption under 
                            bad circumstances but it doesn't help on multithread webservers 
                            or on NFS filesystems...
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControl</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>true</code></entry>
                          <entry>
                            Enable / disable read control : if enabled, a control key is 
                            embeded in the cache file and this key is compared with the 
                            one calculated after the reading.        
                          </entry>
                      </row>
                      <row>
                          <entry><code>readControlType</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>'crc32'</code></entry>
                          <entry>
                            Type of read control (only if read control is enabled). Available values are :
                            'md5' (best but slowest), 'crc32' (lightly less safe but faster, better choice),
                            'strlen' for a length only test (fastest).
                        </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryLevel</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0</code></entry>
                          <entry>
                            Hashed directory structure level :     0 means "no hashed directory 
                             structure", 1 means "one level of directory", 2 means "two levels"... 
                             This option can speed up the cache only when you have many thousands of 
                             cache files. Only specific benchs can help you to choose the perfect 
                             value for you. Maybe, 1 or 2 is a good start.
                          </entry>
                      </row>
                      <row>
                          <entry><code>hashedDirectoryUmask</code></entry>
                          <entry><code>int</code></entry>
                          <entry><code>0700</code></entry>
                          <entry>
                              Umask for the hashed directory structure
                        </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.sqlite">
        <title>Zend_Cache_Backend_Sqlite</title>
        <para>
            This backends stores cache records into a SQLite database.
        </para>
        <para>
            Available options are :
        </para>
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                           <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>cacheDBCompletePath (mandatory)</code></entry>
                          <entry><code>string</code></entry>
                          <entry><code>null</code></entry>
                          <entry>
                              The complete path (filename included) of the SQLite database
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
    <sect2 id="zend.cache.backends.memcached">
        <title>Zend_Cache_Backend_Memcached</title>
        <para>
            This backends stores cache records into a memcached server. <ulink url="http://www.danga.com/memcached/">memcached</ulink>
            is a high-performance, distributed memory object caching system. To use this backend, 
            you need a memcached daemon and <ulink url="http://pecl.php.net/package/memcache">the memcache PECL extension</ulink>.
        </para>
        <para>
        	Be careful : with this backend, "tags" are not supported for the moment as 
        	the "doNotTestCacheValidity=true" argument.
        </para>
        <para>
            Available options are :
        </para>
        <table>
            <title>Available options</title>
            <tgroup cols="4">
                 <thead>
                      <row>
                        <entry>Option</entry>
                        <entry>Data Type</entry>
                        <entry>Default Value</entry>
                        <entry>Description</entry>
                    </row>
                 </thead>
                 <tbody>
                      <row>
                          <entry><code>servers</code></entry>
                          <entry><code>array</code></entry>
                          <entry><code>array(array('host' => 'localhost','port' => 11211, 'persistent' => true))</code></entry>
                          <entry>
                              An array of memcached servers ; each memcached server is described by an associative array :
                              'host' => (string) : the name of the memcached server, 
                              'port' => (int) : the port of the memcached server, 
                              'persistent' => (bool) : use or not persistent connections to this memcached server
                          </entry>
                      </row>
                      <row>
                          <entry><code>compression</code></entry>
                          <entry><code>boolean</code></entry>
                          <entry><code>flase</code></entry>
                          <entry>
                             true if you want to use on-the-fly compression
                          </entry>
                      </row>
                  </tbody>
              </tgroup>
          </table>
    </sect2>
</sect1> 
  
<!--
vim:se ts=4 sw=4 et:
-->