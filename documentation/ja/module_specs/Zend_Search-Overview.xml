<sect1 id="zend.search.overview">
    <title>概要</title>

    <sect2 id="zend.search.introduction">
        <title>導入</title>
        <para>
            Zend_Search_Lucene は、完全に PHP 5
            で書かれている汎用的なテキスト検索エンジンです。
            インデックスをファイルシステム上に保存するためデータベースサーバを必要とせず、
            たいていの PHP ウェブサイト上で動作させることができます。
            Zend_Search_Lucene は、以下の機能をサポートしています。
            
            <itemizedlist>
                <listitem>
                    <para>重要度による検索 - 最もマッチした結果が最初に返されます</para>
                </listitem>
                <listitem>
                    <para>
                       さまざまな強力な検索方式: フレーズ検索、ワイルドカード検索、
                       あいまい検索、範囲指定検索などなど
                        <footnote>
                           <para>
                             現在サポートしているのは、単語検索および複数単語検索のみです。
                           </para>
                        </footnote>
                    </para>
                </listitem>
                <listitem>
                    <para>指定したフィールド (例: タイトル、作者、内容) による検索</para>
                </listitem>
            </itemizedlist>
        
            Zend_Search_Lucene は Apache Lucene プロジェクトから派生したものです。
            Lucene についての詳細は
            <ulink url="http://lucene.apache.org/java/docs/"/> を参照ください。
        </para>
    </sect2>
    
	<sect2 id="zend.search.index-creation.documents-and-fields">
		<title>Document および Field オブジェクト</title>
            <para>
                Zend_Search_Lucene は、ドキュメント単位でインデックスを作成します。
                ドキュメントは名前つきのフィールドから構成され、
                検索対象のコンテンツがフィールドの中に含まれます。
            </para>
        
            <para>
                ドキュメントを表すのが Zend_Search_Lucene_Document
                オブジェクトです。このオブジェクトの中には、フィールドを表す
                Zend_Search_Lucene_Field オブジェクトが含まれます。
            </para>
        
            <para>
                あらゆる種類の情報がインデックス化される可能性があることに注意しましょう。
                アプリケーション固有の情報やメタデータをドキュメントのフィールドに格納し、
                検索結果のドキュメントとして後で取得することができます。
            </para>
        
            <para>
                インデクサを制御するのは、あなたが作成するアプリケーションの役割です。
                ということは、あなたのアプリケーションからアクセス可能な、
                あらゆる内容のデータがインデックス化される可能性があるということです。
                例えばファイルシステム、データベース、HTML フォームなどが考えられます。
            </para>            
            
            <para>
                <code>Zend_Search_Lucene_Field</code> クラスには、
                さまざまな性質のフィールドを作成するための静的メソッドが定義されています。
            </para>
        
            <programlisting role="php"><![CDATA[<?php
$doc = new Zend_Search_Lucene_Document();

// フィールドはトークン化されませんが、インデックス化されて保存されます。
// 保存されたフィールドは、インデックスから取得することができます。
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype', 
                                                 'autogenerated'));

// フィールドはトークン化もインデックス化も行われませんが、インデックスに保存されます。
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created', 
                                                   time()));

// バイナリ文字列フィールドはトークン化もインデックス化も行われません。
// しかしインデックスには保存されます。
$doc->addField(Zend_Search_Lucene_Field::Binary('icon', 
                                                $iconData));

// フィールドがトークン化・インデックス化されてインデックスに保存されます。
$doc->addField(Zend_Search_Lucene_Field::Text('annotation', 
                                              'Document annotation text'));

// フィールドはトークン化されてインデックス化されますが、インデックスには保存されません。
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', 
                                                  'My document content'));

?>]]></programlisting>
        
            <para>
                フィールドの名前は自由につけることができます。
                検索の際にデフォルトで使用されるフィールド名は "contents" です。
                ドキュメントの主要なデータを、この名前のフィールドに設定することをお勧めします。
            </para>
	</sect2>
	
	<sect2 id="zend.search.index-creation.understanding-field-types">
		<title>フィールド型について理解する</title>
        <itemizedlist>
            <listitem>
                <para>
                    <code>Keyword</code> フィールドは、保存されインデックス化されます。
                    つまり、検索した際に元の内容がそのまま返されるということです。
                    トークン化は行われません (いくつかの単語に分割されることはありません)。
                    列挙方のデータベースフィールドは、通常は Zend_Search_Lucene の
                    Keyword フィールドにうまく収まることでしょう。
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnIndexed</code> フィールドは検索対象になりませんが、
                    検索結果としては返されます。このフィールドに設定する値としては、
                    データベースのタイムスタンプ、主キー、ファイルシステムのパス
                    およびその他の外部識別子などがあります。
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Binary</code> フィールドは、トークン化もインデックス化も行われません。
                    しかし、検索結果として取得できるように保存されます。
                    画像アイコンのようなバイナリデータをバイナリ文字列として
                    エンコードしたものなどに対して使用します。
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Text</code> フィールドは、保存されインデックス化され、
                    そしてトークン化されます。検索項目として使用し、
                    かつ検索結果としても取得したいような項目、
                    例えばタイトルなどを保存するのに適しています。
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnStored</code> フィールドはトークン化されインデックス化されます。
                    しかしインデックスには保存されません。大量のテキストなどに適しています。
                    データを保存してしまうとディスク上のインデックスのサイズが大きくなってしまうので、
                    検索はしたいが結果としてそれを表示する必要がない場合などは、
                    このフィールドを使用しましょう。Zend_Search_Lucene インデックスを
                    リレーショナルデータベースと組み合わせて使用する場合などには
                    UnStored フィールドが実用的に使用できるでしょう。
                    大きなデータフィールドの内容の検索用に UnStored フィールドに保存し、
                    結果をデータベースから取得するために、もうひとつ別の ID フィールドを使用します。
    		   </para>

                <table>
                    <title>Zend_Search_Lucene_Field の型</title>
                    <tgroup cols="4">
                        <thead>
                            <row>
                                <entry>フィールド型</entry>
                                <entry>保存</entry>
                                <entry>インデックス化</entry>
                                <entry>トークン化</entry>
                                <entry>バイナリ</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Keyword</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>UnIndexed</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>Binary</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                                <entry>Yes</entry>
                            </row>
                            <row>
                                <entry>Text</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>UnStored</entry>
                                <entry>No</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                            </row>                        
                        </tbody>
                    </tgroup>
                </table>
    	   </listitem>
	   </itemizedlist>
	</sect2>    
</sect1>

<!--
vim:se ts=4 sw=4 et:
-->
