<sect1 id="zend.search.introduction">
    <!-- @todo review and revise upon completion of refactoring -->
    <title>Introduction</title>
    <para>
  ZSearch est un moteur de recherche textuel écrit entièrrement en PHP5.
  L'index est stocké dans le système de fichiers et ne requiert pas de base
de données, il peut ajouter des capacités de recherche à n'importe
quel site web utilisant PHP.
  ZSearch supportes les fonctionnalités suivante:
    <itemizedlist>
        <listitem>
            <para>Recherche triées - les meilleurs résultats sont retourné en premier</para>
        </listitem>
        <listitem>
            <para>
	    Plusieurs type de recherche: recherche de phrase, recherche avec joker,
	    recherche par proximité, recherche par intervalle et plus.
                <footnote>
                   <para>
                     Seul les recheres par mots ou groupes de mots sont supporté pour le moment.
                   </para>
                </footnote>
            </para>
        </listitem>
        <listitem>
            <para>Recherche par champs particulier (e.x., titre, auteur, contenus)</para>
        </listitem>
    </itemizedlist>
  ZSearch est dérivé du projet Apache Lucene. Pour plus d'informations sur Lucene, visitez
  <ulink url="http://lucene.apache.org/java/docs/"/>.
    </para>
</sect1>

<sect1 id="zend.search.file-formats">
    <title>Formats de fichier</title>
    <para>
      Le format de fichier des index de ZSearch est compatible avec celui de Lucene
      version 1.4 et plus.
    </para>

    <para>
      Une description détaillé du format est disponible ici:
      <ulink url="http://lucene.apache.org/java/docs/fileformats.html"/>.
    </para>
</sect1>

<sect1 id="zend.search.document-object">
    <title>Objet document</title>
    <para>
    ZSearch considère les documents comme des sujets atomique à
    pour l'indexation.  Un documents est divisé en champs nommés
    , et les champs ont du contenu qui peut-être recherché.
    </para>

    <para>
    Un document est representé par l'objet Zend_Search_Lucene_Document,
    et cet objet contient des objets
    Zend_Search_Lucene_Field qui representent les champs.
    </para>

    <para>
    La classe <code>Zend_Search_Lucene_Field</code> fournis plusiers méthodes
    statique pour créer des champs avec différente caractéristique:
    </para>

    <programlisting role="php"><![CDATA[
$doc = new Zend_Search_Lucene_Document(); #A TRADUIRE#

// Le champ Field is not tokenized, but is indexed and stored within the index.
// Stored fields can be retrived from the index.
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype', 'autogenerated'));

// Field is not tokenized nor indexed, but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created', time()));

// Binary String valued Field that is not tokenized nor indexed,
// but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Binary('icon', $iconData));

// Field is tokenized and indexed, and is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Text('annotation', 'Document annotation text...'));

// Field is tokenized and indexed, but that is not stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', 'My cool document content..'));]]>
    </programlisting>

    <para>
    Vous pouvez donner le nom que vous voulez aux champs. Le nom 'contents' est
    utilisé par défaut. C'est une bonne idée de placer les
    principales données de votre documents dans le champs avec ce nom.
    </para>
</sect1>

<sect1 id="zend.search.index-creation">
    <title>Créer et mettre à jour l'index</title>
    <para>
    La crŽation et la mise à jour d'index est disponible
    dans le module ZSearch et dans Java Lucene. Vous pouvez utilisez les
    capacités des deux.
    </para>

    <para>
    Le listing de code PHP fournis un exemple de comment indexer un fichier
    en utilisant l'API d'indexation de ZSearch:
    </para>

    <programlisting role="php"><![CDATA[
$index = new ZSearch('/data/my-index', true /* vrais pour créer un nouvel index */);

$doc = new Zend_Search_Lucene_Document();
// Stocke l'URL du document pour l'identifier dans un résultat de recherche.
$doc->addField(Zend_Search_Lucene_Field::Text('url', $docUrl));
// Index document content #A TRADUIRE#
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', $docContent));

// Ajoute un document à l'index.
$index->addDocument($doc);]]>
    </programlisting>

    <para>
    <code>ZSearchAnalyzer</code> class is used by indexer to tokenize document
    text fields.#A TRADUIRE#
    </para>
    <para>
    Les méthodes <code>ZSearchAnalyzer::getDefault()</code> et
    <code>ZSearchAnalyzer::setDefault()</code> sont utilisés pour
    récupérer et choisir l'analyseur.
    </para>
    <para>
    Cela signifie que vous pouvez utiliser votre propre analyseur de texte ou choisir
    celui-ci parmis les analyseurs prédéfinis:
    <code>ZSearchTextAnalyser</code> et <code>ZSearchTextCIAnalyser</code> (par défaut).
    Both of them interpret token as a sequense of letters. <code>ZSearchTextCIAnalyser</code> converts tokens
    to lower case. #A TRADUIRE#
    </para>
    <para>
    Pour changer d'analyseur utiliser ce code:
    </para>
    <programlisting role="php"><![CDATA[
ZSearchAnalyzer::setDefault(new ZSearchTextAnalyzer());
...
$index->addDocument($doc);
]]>
    </programlisting>


    <para>
    Les nouveaux document ajoutés peuvent être récupérer de l'index aprè une opération commit.
    </para>
    <para>
    <code>ZSearch::commit()</code> est automatiquement appelé à la
    fin de l'éxecution du script et avant toute recherche.
    </para>
    <para>
    Chaque appel à commit() #A TRADUIRE# call generates new index segment. So it must be requested as rarely as possible.
    From the other side commiting large amount of documents in one step needs more memory.
    </para>
    <para>
    Automatic segment management optimization is a subject of future ZSearch enhancements.
    </para>

    <para>
    &#160; <!-- &nbsp; -->
    </para>

    <para>
    Le code Java ci dessous fournis un exemple de comment indexer un fichier en
    utilisant Java Lucene:
    </para>

    <programlisting role="java"><![CDATA[
/**
* Création d'un index:
*/
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.document.*;

import java.io.*

...

IndexWriter indexWriter = new IndexWriter("/data/my_index", new SimpleAnalyzer(), true);

...

String filename = "/path/to/file-to-index.txt"
File f = new File(filename);

Document doc = new Document();
doc.add(Field.Text("path", filename));
doc.add(Field.Keyword("modified",DateField.timeToString(f.lastModified())));
doc.add(Field.Text("author", "unknown"));
FileInputStream is = new FileInputStream(f);
Reader reader = new BufferedReader(new InputStreamReader(is));
doc.add(Field.Text("contents", reader));

indexWriter.addDocument(doc);]]>
    </programlisting>

    <para>
    Il est important de noter que n'importe quel sorte d'information peut-être
    ajouter à l'index.
    Des informations spécifique à l'application ou des metadatas
    peuvent être stockés dans les champs du document,
    et peuvent être récupéré plus tard avec le document
    pendant la recherche.
    </para>

    <para>
    Il est de la responsabilité de votre application de controler l'indexeur
    Lucene indexer et ZSearch. Cela signifie que les donnés peuvent être
    indexés de n'importe quel source accessible à votre application.
    Par exemple, ce peut-être le système de fichier, une base de
    donnés, un formulaire HTML, etc.
    </para>
</sect1>

<sect1 id="zend.search.index-creation-jar">
    <title>Créer un index avec LuceneIndexCreation.jar</title>

    <para>
    Pour démarrer rapidement avec ZSearch, un fichier JAR (Java) a
    été crée pour générer un index depuis la
    ligne de commande.Pour plus d'informations sur les fichiers JAR, visitez:
    <ulink url="http://java.sun.com/docs/books/tutorial/jar/basics/index.html"/>.
    </para>

    <para>
    LuceneIndexCreation.jar lit les fichier texte et construit un index à
    partir d'eux. Utilisation:
    <programlisting role="java"><![CDATA[
java -jar LuceneIndexCreation.jar [-c] [-s] <document_directory> <index_directory>
-c   - force l'index à sensible à la case
-s   - stocke le contenu dans l'index
]]></programlisting>
Cette commande analyse le répertoire <code>&lt;document_directory&gt;</code>,
 ainsi que tous ces sous répertoires, et génère un index Lucene.
  L'index est une série de fichier qui seront stokés dans un
  répertoire séparé <code>&lt;index_directory&gt;</code>.
    </para>

    <para>
    Pour chaque document à indexer, LuceneIndexCreation créer un objet
    document avec trois champs: un champ <emphasis>contents</emphasis> qui contient le
    contenu (corp) du document,
    un champs <emphasis>modified</emphasis> qui contient la date de la dernière
    modification et le chemin complet ainsi que le nom du fichier dans le champ
    <emphasis>path</emphasis>.
    </para>

    <para>
    Si <option>-c</option> est specifié, alors l'index est sensible à la
    case. Sinon tous les termes sont convertit en miniscule avant d'être
    ajouté à l'index.
    </para>

    <para>
    Si <option>-s</option> est specifié, alors le contenu du document est stocké dans l'index et peut-être récupéré avec les champs
    <code>path</code> et <code>modified</code>.
    </para>
    <para>
    Sinon seul les champs <code>path</code> et <code>modified</code> sont stockés,
    et le champs <code>contents</code> est seulement indexé. Dans ce cas le
    contenu du document peut-être récupéré dans sa source
    original en utlisant son path.
    </para>
    <para>
    Soyez prudent, utiliser l'option <option>-s</option> augmente la taille de l'index
    de presque 5 fois.
    </para>
</sect1>

<sect1 id="zend.search.index-directory">
    <title>Le dossier index</title>

    <para>
    Après la création de l'index, le dossier index
    contiendra plusieurs fichiers:
    </para>
#A TRADUIRE#
    <itemizedlist>
        <listitem>
            <para>
            <filename>segments</filename> file is a list of index segments.
            </para>
        </listitem>
        <listitem>
            <para>
            <filename>*.cfs</filename> files contain index segments.
            Note! Optimized index has always only one segment.
            </para>
        </listitem>
        <listitem>
            <para>
            Le fichier <filename>deletable</filename> est la liste des fichiers
	    qui ne sont plus utilisés par l'index, mais qui ne peuvent pas
	    être supprimés.
            </para>
        </listitem>
    </itemizedlist>
</sect1>

<sect1 id="zend.search.search">
    <title>Chercher dans l'ndex</title>

    <para>
    Il y a deux méthodes pour chercher dans l'index. La première
    méthode utilise Query Parser pour construire la requête à
    partir d'une chaine de caractères. La seconde fournis la possibilité
    de créer vos propres requêtes en utilisant l'API ZSearch.
    </para>

    <para>
    Avant de choisir d'utiliser le Query Parser fournis, considérez ceci:

        <orderedlist>
            <listitem>
Si par programmation vous générez la chaine de la requête
puis que vous l'analysez avec le query parser alors vous devriez sérieusement
examiner la possibilité de construire vos requêtes avec l'API.
En d'autre mots, le query parser est fait pour du texte entré par un humain, 
pas pour du texte généré par un programme.
            </listitem>
            <listitem>#A TRADUIRE#
Untokenized fields are best added directly to queries, and not through
the query parser. If a field's values are generated programmatically
by the application, then so should query clauses for this field.
An analyzer, which the query parser uses, is designed to convert
human-entered text to terms. Program-generated values, like dates,
keywords, etc., should be consistently program-generated.
            </listitem>
            <listitem>
Dans un formulaire de recherche, les champs constitués principalement de texte 
devrait utiliser le query parser. Tous les autres, comme les dates, etc... devrait être
ajouté directement avec l'API de requê. Un champs avec peu de choix possible,
qui peuvent être choisis via un menu déroulant ne doit pas être mis dans une
 query string, mais devrait être ajouté dans TermQuery. #TRADUIRE Qu'est ce que TermQuery???#
            </listitem>
        </orderedlist>

    </para>

    <para>
    Les deux méthodes utilsie la même méthode de l'API pour chercher
    dans l'index:

    <programlisting role="php"><![CDATA[
require_once('ZSearch/ZSearch.php');

$index = new ZSearch('/data/my_index');

$index->find($query);]]>
    </programlisting>

    La méthode <code>ZSearch::find()</code> détermines le type de donnés
    entré automatiquement et utilise le query parser pour construire l 'objet
    ZSearchQuery approprié.
    </para>

    <para>
    Il est important de noté que <code>find()</code> EST sensible à la case.
    Par défaut, LuceneIndexCreation.jar met le contenu des documents en miniscule.
    Cela peut-être coupé via la ligne de commande (lancez LuceneIndexCreation.jar
    sans arguments pour afficher l'aide). La case du texte donné en argument à
    <code>find()</code> doit être la même que celle de l'index.
    Si l'index est en minisucule, alors tous les textes passés en paramètre 
    à <code>find()</code> doit passer par <code>strtolower()</code>, ou sinon il ne
    correspondra pas.
    </para>

    <para>
    Le résultat de la recherche est un tableau d'objets ZSearchQueryHit. Chacun d'eux
    a deux attributs: <code>$hit->document</code> est le numéro de document dans l'index
    et <code>$hit->score</code> qui le score du résultat lors de la recherche.
    Les résultats sont triés par score (le meilleur score en premier).
    </para>

    <para>
    L'objet ZSearchQueryHit donne chaque champs du ZSearchDocument trouver pendant la recherche
    comme attribut de hit. Dans cet exemple, un hit est retourné et le document
    correspondant a deux champs: titre et auteur.

    <programlisting role="php"><![CDATA[
require_once('ZSearch/ZSearch.php');

$index = new ZSearch('/data/my_index');

$hits = $index->find($query);

foreach ($hits as $hit) {
    echo $hit->id;
    echo $hit->score;

    echo $hit->title;
    echo $hit->author;
}]]>
    </programlisting>
    </para>

    <para>
    L'objet ZSearchDocument original peut-être retourné depuis
    ZSearchQueryHit.

    Vous pouvez récupérer les parties indexés du document en utilisant
    la méthode <code>getDocument()</code> de l'objet index et alors récupérer
    ceux si via la méthode <code>getFieldValue()</code>:
    <programlisting role="php"><![CDATA[
require_once('ZSearch/ZSearch.php');

$index = new ZSearch('/data/my_index');

$hits = $index->find($query);
foreach ($hits as $hit) {
    // retourne un objet ZSearchDocument pour ce hit
    echo $document = $hit->getDocument();

    // retourne un objet ZSearchField depuis le ZSearchDocument
    echo $document->getField('title');

    // retourne la valeur de l'objet ZSearchField
    echo $document->getFieldValue('title');

    // même chose que getFieldValue()
    echo $document->title;
}]]>
    </programlisting>

    Les champs disponible depuis l'objet ZSearchDocument sont determinés au
    moment de l'indexation par l'application d'indexation (ex: LuceneIndexCreation.jar).
    </para>

    <para>
    Attention, l'identifiant du document ('path' dans notre exemple) est stocké dans
    l'index et doit être-récupérer à partir de celui-ci.
    </para>

</sect1>

<sect1 id="zend.search.term-query">
    <title>Rechercher d'un terme</title>

    <para>
    Deux méthode de recherche peuvent être utilisés pour rechercher
    un terme.
    </para>

    <para>
    Recherche avec une chaine de caractères:
    <programlisting role="php"><![CDATA[
$hits = $index->find('word1');]]>
    </programlisting>
    </para>

    <para>or</para>

    <para>
    Construction de la requêtre avec l'API:
    <programlisting role="php"><![CDATA[
$term  = new ZSearchTerm('word1');
$query = new ZSearchTermQuery($term);
$hits  = $index->find($query);]]>
    </programlisting>
    </para>

</sect1>

<sect1 id="zend.search.multiterm-query">
    <title>Recherche avec plusieurs termes</title>

    <para>
    Chaque terme peut-être définis comme requis, interdit, ou.

    <itemizedlist>
        <listitem>
            <para>
            requis signifie que le document doit contenir ce terme.
            </para>
        </listitem>
        <listitem>
            <para>
            interdit signifie que le document ne doit pas contenir ce terme.
            </para>
        </listitem>
        <listitem>
            <para>
	    ou, dans ce cas les documents doivent contenir un des termes.
            </para>
        </listitem>
    </itemizedlist>
    </para>

    <para>
    Cela signifie que si des termes optionnels sont ajouté à la recherche avec
    les termes requis, alors il y aura les même résultats,
    mais la seconde aura des résultats qui corresponderont aux termes optionnels,
    qui seront placés en haut des résultats.
    </para>

    <para>
    Deux méthodes de recherche peuvent être utilisé pour des recherche
    multi-termes.
    </para>

    <para>
    Recherche par chaine de caractères:
    <programlisting role="php"><![CDATA[
$hits = $index->find('+word1 author:word2 -word3');]]>
    </programlisting>

    <itemizedlist>
        <listitem>'+' est utilisé pour définir un terme comme requis.</listitem>
        <listitem>'-' est utilisé pour définir un terme comme interdit.</listitem>
        <listitem>
        Le préfixe 'field:' est utilisé pour indiquer un champ du document
	lors de la recherche. Si ce n'est pas indiqué, alors le champs 'contents' est
	utilisé.
        </listitem>
    </itemizedlist>
    </para>

    <para>ou</para>

    <para>
    Construction de recherche par l'API:
    <programlisting role="php"><![CDATA[
$query = new ZSearchMultiTermQuery();

$query->addTerm(new ZSearchTerm('word1'), true);
$query->addTerm(new ZSearchTerm('word2'), null);
$query->addTerm(new ZSearchTerm('word3'), false);

$hits  = $index->find($query);]]>
    </programlisting>

    <para>
        Le tableau <code>$signs</code> contient des informations sur le type du terme:
    <itemizedlist>
        <listitem>true est utilisé pour un terme définis comme requis.</listitem>
        <listitem>false est utilisé pour un terme définis comme interdit.</listitem>
        <listitem>
        null true est utilisé pour un terme définis comme ou requis,
        nor est utilisé pour un terme définis comme ou interdit.
        </listitem>
    </itemizedlist>
    </para>

    </para>

</sect1>

<sect1 id="zend.search.phrase-query">
    <title>Recherche de phrases</title>

    <para>
    Les recherches de phrases sont très flexible et permet de chercher des phrase exact
    comme des morceau de phrases.
    Les phrases exacte contienent des espaces ou des termes à la même place.
    #A TRADUIRE#(It can be generated by Analyser for different
    purposes. Ex. term can be duplicated to increase term weight or several synonyms can be placed into one position).
    According to this phrase queries can be constructed only by API now:
    </para>

    <programlisting role="php"><![CDATA[
$query1 = new ZSearchPhraseQuery();

$query1->addTerm(new ZSearchTerm('word1'));     // Ajoute le mot 'word1' à la position 0.
$query1->addTerm(new ZSearchTerm('word2'));     // Ajoute le mot 'word2' à la position 1.
$query1->addTerm(new ZSearchTerm('word3'), 3);  // Ajoute le mot 'word3' à la position 3.

...

$query2 = new ZSearchPhraseQuery(array('word1', 'word2', 'word3'), array(0,1,3));

...

// Requête sans espace.
$query3 = new ZSearchPhraseQuery(array('word1', 'word2', 'word3'));

...

$query4 = new ZSearchPhraseQuery(array('word1', 'word2'), array(0,1), 'annotation');]]>
    </programlisting>

    <para>
#A TRADUIRE#
    Sloop factor sets the number of other words permitted between words in query phrase. If zero,
    then this is an exact phrase search.  For larger values this works like a WITHIN or NEAR operator.
    </para>
    <para>
    The slop is in fact an edit-distance, where the units correspond to moves of terms in the query phrase
    out of position.  For example, to switch the order of two words requires two moves (the first move places
    the words atop one another), so to permit re-orderings of phrases, the slop must be at least two.
    </para>
    <para>
    More exact matches are scored higher than sloppier matches, thus search results are sorted by exactness.
    The slop is zero by default, requiring exact matches.
    </para>
    <para>
    Sloop factor can be assigned after query creation:
    </para>
    <programlisting role="php"><![CDATA[
// Recherche sans espace.
$query = new ZSearchPhraseQuery(array('word1', 'word2'));

// Recherche 'mot1 mot2', 'mot1 ... mot2'
$query->setSlop(1);
$hits1 = $index->find($query);

// Recherche 'mot1 mot2', 'mot1 ... mot2', 'mot1 ... ... mot2', 'mot2 mot1'
$query->setSlop(2);
$hits2 = $index->find($query);]]>
    </programlisting>

</sect1>

<sect1 id="zend.search.scoring-API">
    <title>API pour les scores</title>

    <para>
    Le score d'une requête <literal>q</literal> pour un document <literal>d</literal>
    est définis comme ceci:
    </para>

    <para>
    <code>score(q,d) = sum( tf(t in d) * idf(t) * getBoost(t.field in d) * lengthNorm(t.field in d)  ) *
    coord(q,d) * queryNorm(q)</code>
    </para>

    <para>
    tf(t in d) - <code>ZSearchSimilarity::tf($freq)</code> - un facteur de score basé sur 
    la fréquence des termes ou des phrase dans le document.
    </para>

    <para>
    idf(t) - <code>ZSearchSimilarity::tf($term, $reader)</code> - un facteur de score
    pour un terme simple pour l'index specifié.
    </para>

    <para>
    getBoost(t.field in d) - facteur de boost pour le champ du terme.
    </para>

    <para>#A TRADUIRE#
    lengthNorm($term) - the normalization value for a field given the total
    number of terms contained in a field. This value is stored within the index.
    These values, together with field boosts, are stored in an index and multiplied
    into scores for hits on each field by the search code.
    </para>
    <para>
    Matches in longer fields are less precise, so implementations of this method
    usually return smaller values when numTokens is large, and larger values when numTokens is small.
    </para>

    <para>
    coord(q,d) - <code>ZSearchSimilarity::coord($overlap, $maxOverlap)</code> - a score
    factor based on the fraction of all query terms that a document contains.
    </para>

    <para>
    The presence of a large portion of the query terms indicates a better match
    with the query, so implementations of this method usually return larger values
    when the ratio between these parameters is large and smaller values when
    the ratio between them is small.
    </para>

    <para>
    queryNorm(q) -  the normalization value for a query given the sum of the squared weights
    of each of the query terms. This value is then multiplied into the weight of each query
    term.
    </para>

    <para>
    This does not affect ranking, but rather just attempts to make scores from different
    queries comparable.
    </para>

    <para>
    Scoring algorithm can be customized by defining your own Similatity class. To do this
    extend ZSearchSimilarity class as defined below, then use
    <code>ZSearchSimilarity::setDefault($similarity);</code> method to set it as default.
    </para>

    <programlisting role="php"><![CDATA[
class MySimilarity extends ZSearchSimilarity {
    public function lengthNorm($fieldName, $numTerms) {
        return 1.0/sqrt($numTerms);
    }

    public function queryNorm($sumOfSquaredWeights) {
        return 1.0/sqrt($sumOfSquaredWeights);
    }

    public function tf($freq) {
        return sqrt($freq);
    }

    /**
     * It's not used now. Computes the amount of a sloppy phrase match,
     * based on an edit distance.
     */
    public function sloppyFreq($distance) {
        return 1.0;
    }

    public function idfFreq($docFreq, $numDocs) {
        return log($numDocs/(float)($docFreq+1)) + 1.0;
    }

    public function coord($overlap, $maxOverlap) {
        return $overlap/(float)$maxOverlap;
    }
}

$mySimilarity = new MySimilarity();
ZSearchSimilarity::setDefault($mySimilarity);
]]>
    </programlisting>

</sect1>

<sect1 id="zend.search.storage">
    <title>API de stockage</title>

    <para>
    Une classe abstraite ZSearchDirectory définis les fonctionnalités
    relative au répertoires.
    </para>

    <para>
    Le constructeur de ZSearch utilise une chaine ou objet ZSearchDirectory comme
    entrée.
    </para>

    <para>
    La classe ZSearchDirectoryFilesystem implementes les fonctionnalités de
    répertoire pour le système de fichier.
    </para>

    <para>
    Si une chaine est utilisé comme dans le constructeur de ZSearch, alors
    le lecteur d'index (objet ZSearch) traite le chemin et instancie l'objet
    ZSearchDirectoryFilesystem.
    </para>

    <para>
    Vous pouvez faire votre propre implementation des répertoires en étendant
    la classe ZSearchDirectory.
    </para>

    <para>
    La méthode ZSearchDirectory:

    <programlisting><![CDATA[
abstract class ZSearchDirectory {
    /**
     * Ferme le stockage.
     *
     * @return void
     */
    abstract function close();


    /**
     * Créer un nouveau fichier vide dans le répertoire avec comme nom $filename.
     *
     * @param string $name
     * @return void
     */
    abstract function createFile($filename);


    /**
     * Supprime le fichier $filename dans le répertoire.
     *
     * @param string $filename
     * @return void
     */
    abstract function deleteFile($filename);


    /**
     * Retourne true si un fichier $filename existe.
     *
     * @param string $filename
     * @return boolean
     */
    abstract function fileExists($filename);


    /**
     * Retourne la longueur du fichier $filename.
     *
     * @param string $filename
     * @return integer
     */
    abstract function fileLength($filename);


    /**
     * Retourne le timestamp UNIX de la dernière modification du fichier $filename.
     *
     * @param string $filename
     * @return integer
     */
    abstract function fileModified($filename);


    /**
     * Renomme un fichier.
     *
     * @param string $from
     * @param string $to
     * @return void
     */
    abstract function renameFile($from, $to);


    /**
     * Change la date de dernière modification du fichier $filename pour maintenant.
     *
     * @param string $filename
     * @return void
     */
    abstract function touchFile($filename);


    /**
     * Retourne un objet ZSearchFile pour le fichier $filename.
     *
     * @param string $filename
     * @return ZSearchFile
     */
    abstract function getFileObject($filename);

}]]>
    </programlisting>
    </para>

    <para>
    La méthode <code>getFileObject($filename)</code> de la classe ZSearchDirectory
    retourne un objet ZSearchFile.
    </para>
    <para>
    La classe abstraite ZSearchFile implemente l'abstraction des fichiers
    et de la lecture des fichiers d'index.
    </para>
    <para>
    Vous devez bien sur étendre la classe ZSearchFile pour votre implémentation
    de Directory.
    </para>
    <para>
    Seul deux méthodes de la classe ZSearchFile doit être surchargédans
    votre implementation:

    <programlisting><![CDATA[
class MyZSearchFile extends ZSearchFile {
    /**
     * Sets the file position indicator and advances the file pointer.
     * The new position, measured in bytes from the beginning of the file,
     * is obtained by adding offset to the position specified by whence,
     * whose values are defined as follows:
     * SEEK_SET - Set position equal to offset bytes.
     * SEEK_CUR - Set position to current location plus offset.
     * SEEK_END - Set position to end-of-file plus offset. (To move to
     * a position before the end-of-file, you need to pass a negative value
     * in offset.)
     * Upon success, returns 0; otherwise, returns -1
     *
     * @param integer $offset
     * @param integer $whence
     * @return integer
     */
    public function seek($offset, $whence=SEEK_SET) {
        ...
    }

    /**
     * Read a $length bytes from the file and advance the file pointer.
     *
     * @param integer $length
     * @return string
     */
    protected function _fread($length=1) {
        ...
    }]]>
    </programlisting>
    </para>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->



