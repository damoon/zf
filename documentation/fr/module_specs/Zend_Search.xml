<sect1 id="zend.search.introduction">
    <!-- @todo review and revise upon completion of refactoring -->
    <title>Introduction</title>
    <para>
  ZSearch is a general purpose text search engine written entirely in PHP 5.
  Since it stores its index on the filesystem and does not require a database
  server, it can add search capabilities to almost any PHP-driven website.
  ZSearch supports the following features:
    <itemizedlist>
        <listitem>
            <para>Ranked searching - best results returned first</para>
        </listitem>
        <listitem>
            <para>
               Many powerful query types: phrase queries, wildcard queries,
               proximity queries, range queries and more
                <footnote>
                   <para>
                     Only term and multi term queries are supported at this time.
                   </para>
                </footnote>
            </para>
        </listitem>
        <listitem>
            <para>Search by specific field (e.g., title, author, contents)</para>
        </listitem>
    </itemizedlist>
  ZSearch was derived from the Apache Lucene project.  For more information on Lucene, visit
  <ulink url="http://lucene.apache.org/java/docs/"/>.
    </para>
</sect1>

<sect1 id="zend.search.file-formats">
    <title>File Formats</title>
    <para>
      ZSearch index file formats are binary compatible with a Lucene
      version 1.4 and above.
    </para>

    <para>
      A detailed description of this format is available here:
      <ulink url="http://lucene.apache.org/java/docs/fileformats.html"/>.
    </para>
</sect1>

<sect1 id="zend.search.document-object">
    <title>Document Object</title>
    <para>
    ZSearch operates with documents as atomic subjects for indexing.  A document is
    divided into named fields, and fields have content that can be searched.
    </para>

    <para>
    A documented is represented by the Zend_Search_Lucene_Document object, and this object contains
    Zend_Search_Lucene_Field objects that represent the fields.
    </para>

    <para>
    <code>Zend_Search_Lucene_Field</code> class provides several static methods to create fields with
    different characteristics:
    </para>

    <programlisting role="php"><![CDATA[
$doc = new Zend_Search_Lucene_Document();

// Field is not tokenized, but is indexed and stored within the index.
// Stored fields can be retrived from the index.
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype', 'autogenerated'));

// Field is not tokenized nor indexed, but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created', time()));

// Binary String valued Field that is not tokenized nor indexed,
// but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Binary('icon', $iconData));

// Field is tokenized and indexed, and is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Text('annotation', 'Document annotation text...'));

// Field is tokenized and indexed, but that is not stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', 'My cool document content..'));]]>
    </programlisting>

    <para>
    You could give names for fields by your own choice. 'contents' field name is used to search by default.
    Thus that's good idea to place main document data into the field with this name.
    </para>
</sect1>

<sect1 id="zend.search.index-creation">
    <title>Creating and Updating the Index</title>
    <para>
    Index creation and updating capabilities are implemented within ZSearch module and Java Lucene.
    You can use both of these capabilities.
    </para>

    <para>
    The PHP code listing below provides an example of how to index a file
    using ZSearch indexing API:
    </para>

    <programlisting role="php"><![CDATA[
$index = new ZSearch('/data/my-index', true /* true to create new index */);

$doc = new Zend_Search_Lucene_Document();
// Store document URL to identify it in search result.
$doc->addField(Zend_Search_Lucene_Field::Text('url', $docUrl));
// Index document content
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', $docContent));

// Add document to the index.
$index->addDocument($doc);]]>
    </programlisting>

    <para>
    <code>ZSearchAnalyzer</code> class is used by indexer to tokenize document
    text fields.
    </para>
    <para>
    <code>ZSearchAnalyzer::getDefault()</code> and <code>ZSearchAnalyzer::setDefault()</code> methods are used
    to get and set default analyser.
    </para>
    <para>
    Thus you can assign your own text analayser or choose it from the set of predefined analysers:
    <code>ZSearchTextAnalyser</code> and <code>ZSearchTextCIAnalyser</code> (default).
    Both of them interpret token as a sequense of letters. <code>ZSearchTextCIAnalyser</code> converts tokens
    to lower case.
    </para>
    <para>
    To switch between analysers use code:
    </para>
    <programlisting role="php"><![CDATA[
ZSearchAnalyzer::setDefault(new ZSearchTextAnalyzer());
...
$index->addDocument($doc);
]]>
    </programlisting>


    <para>
    Newly added documents could be retrived from the index after commit
    operation.
    </para>
    <para>
    <code>ZSearch::commit()</code> is automatically called at the end of script execution and
    before any search request.
    </para>
    <para>
    Each commit() call generates new index segment. So it must be requested as rarely as possible.
    From the other side commiting large amount of documents in one step needs more memory.
    </para>
    <para>
    Automatic segment management optimization is a subject of future ZSearch enhancements.
    </para>

    <para>
    &#160; <!-- &nbsp; -->
    </para>

    <para>
    The Java program listing below provides an example of how to index a file
    using Java Lucene:
    </para>

    <programlisting role="java"><![CDATA[
/**
* Index creation:
*/
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.document.*;

import java.io.*

...

IndexWriter indexWriter = new IndexWriter("/data/my_index", new SimpleAnalyzer(), true);

...

String filename = "/path/to/file-to-index.txt"
File f = new File(filename);

Document doc = new Document();
doc.add(Field.Text("path", filename));
doc.add(Field.Keyword("modified",DateField.timeToString(f.lastModified())));
doc.add(Field.Text("author", "unknown"));
FileInputStream is = new FileInputStream(f);
Reader reader = new BufferedReader(new InputStreamReader(is));
doc.add(Field.Text("contents", reader));

indexWriter.addDocument(doc);]]>
    </programlisting>

    <para>
    It is important to note that any kind of information can be added to the index.
    Application-specific information or metadata can be stored in the document
    fields, and later retrieved with the document during search.
    </para>

    <para>
    It is the responsibility of your application to control the Lucene indexer
    and ZSearch.  This means that data can be indexed from any source
    that is accessible by your application.  For example, this could be the
    filesystem, a database, an HTML form, etc.
    </para>
</sect1>

<sect1 id="zend.search.index-creation-jar">
    <title>Creating an Index with LuceneIndexCreation.jar</title>

    <para>
    To get started with ZSearch quickly, a JAR file (Java) has been created to
    generate an index from the command line.  For more information on JAR files,
    please visit: <ulink url="http://java.sun.com/docs/books/tutorial/jar/basics/index.html"/>.
    </para>

    <para>
    LuceneIndexCreation.jar consumes text files and builds an index from them.  Usage:
    <programlisting role="java"><![CDATA[
java -jar LuceneIndexCreation.jar [-c] [-s] <document_directory> <index_directory>
-c   - force index to be case sensitive
-s   - store content in the index
]]></programlisting>
    This command consumes the directory <code>&lt;document_directory&gt;</code>, including all of its subdirectories,
    and produces a Lucene index.  The index is a set of files that will be stored in a separate
    directory that is specified by <code>&lt;index_directory&gt;</code>.
    </para>

    <para>
    For each document to be indexed, LuceneIndexCreation creates a document object with three
    fields: a <emphasis>contents</emphasis> field containing the contents (body) of the document,
    a <emphasis>modified</emphasis> field containing the file modification time, and
    the full path and filename in a <emphasis>path</emphasis> field.
    </para>

    <para>
    If <option>-c</option> is specified, then index is forced to be case sensitive. Otherwise all terms are converted to lower case before to be added into the index.
    </para>

    <para>
    If <option>-s</option> is specified, then document's content is also stored in the index
    and can be retrieved with <code>path</code> and <code>modified</code> fields.
    </para>
    <para>
    Otherwise only <code>path</code> and <code>modified</code> fields are stored,
    and <code>contents</code> field is only indexed. In this case document content must
    be retrieved from an original source by its path.
    </para>
    <para>
    Please be careful, using <option>-s</option> option increases index size near five times.
    </para>
</sect1>

<sect1 id="zend.search.index-directory">
    <title>Index Directory</title>

    <para>
    After index creation, the index directory will contain several files:
    </para>

    <itemizedlist>
        <listitem>
            <para>
            <filename>segments</filename> file is a list of index segments.
            </para>
        </listitem>
        <listitem>
            <para>
            <filename>*.cfs</filename> files contain index segments.
            Note! Optimized index has always only one segment.
            </para>
        </listitem>
        <listitem>
            <para>
            <filename>deletable</filename> file is a list of files that are no longer used
            by the index, but which could not be deleted.
            </para>
        </listitem>
    </itemizedlist>
</sect1>

<sect1 id="zend.search.search">
    <title>Searching the Index</title>

    <para>
There are two ways to search the index. The first method uses
Query Parser to construct query from a string. The second provides
the ability to create your own queries through the ZSearch API.
    </para>

    <para>
    Before choosing to use the provided Query Parser, please consider
    the following:

        <orderedlist>
            <listitem>
If you are programmatically generating a query string and then parsing
it with the query parser then you should seriously consider building
your queries directly with the query API. In other words, the query
parser is designed for human-entered text, not for program-generated text.
            </listitem>
            <listitem>
Untokenized fields are best added directly to queries, and not through
the query parser. If a field's values are generated programmatically
by the application, then so should query clauses for this field.
An analyzer, which the query parser uses, is designed to convert
human-entered text to terms. Program-generated values, like dates,
keywords, etc., should be consistently program-generated.
            </listitem>
            <listitem>
In a query form, fields which are general text should use the query parser.
All others, such as date ranges, keywords, etc. are better added directly
through the query API. A field with a limit set of values, that can be
specified with a pull-down menu should not be added to a query string
which is subsequently parsed, but rather added as a TermQuery clause.
            </listitem>
        </orderedlist>

    </para>

    <para>
    Both ways use the same API method to search through the index:

    <programlisting role="php"><![CDATA[
require_once('ZSearch/ZSearch.php');

$index = new ZSearch('/data/my_index');

$index->find($query);]]>
    </programlisting>

    The <code>ZSearch::find()</code> method determines input type automatically and
    uses query parser to construct appropriate ZSearchQuery object
    from a string.
    </para>

    <para>
    It is important to note that <code>find()</code> IS case sensitive.  By default,
    LuceneIndexCreation.jar normalizes all documents to lowercase.  This can be turned
    off with a command line switch (type LuceneIndexCreation.jar with no arguments
    for help).  The case of the text supplied to <code>find()</code> must match that
    of the index.  If the index is normalized to lowercase, then all text supplied
    to <code>find()</code> must pass through <code>strtolower()</code>, or else it
    may not match.
    </para>

    <para>
    The search result is an array of ZSearchQueryHit objects.  Each of these has
    two properties: <code>$hit->document</code> is a document number within
    the index and <code>$hit->score</code> is a score of the hit in
    a search result. Result is ordered by score (top scores come first).
    </para>

    <para>
    The ZSearchQueryHit object also exposes each field of the ZSearchDocument found by
    the hit as a property of the hit.  In this example, a hit is returned and
    the corresponding document has two fields: title and author.

    <programlisting role="php"><![CDATA[
require_once('ZSearch/ZSearch.php');

$index = new ZSearch('/data/my_index');

$hits = $index->find($query);

foreach ($hits as $hit) {
    echo $hit->id;
    echo $hit->score;

    echo $hit->title;
    echo $hit->author;
}]]>
    </programlisting>
    </para>

    <para>
    Optionally, the original ZSearchDocument object can be returned from the
    ZSearchQueryHit.

    You can retrieve indexed parts of the document by using the <code>getDocument()</code>
    method of the index object and then get them by
    <code>getFieldValue()</code> method:
    <programlisting role="php"><![CDATA[
require_once('ZSearch/ZSearch.php');

$index = new ZSearch('/data/my_index');

$hits = $index->find($query);
foreach ($hits as $hit) {
    // return ZSearchDocument object for this hit
    echo $document = $hit->getDocument();

    // return a ZSearchField object from the ZSearchDocument
    echo $document->getField('title');

    // return the string value of the ZSearchField object
    echo $document->getFieldValue('title');

    // same as getFieldValue()
    echo $document->title;
}]]>
    </programlisting>

    The fields available from the ZSearchDocument object are determined at
    the time of indexing.  The document fields are either indexed, or
    index and stored, in the document by the indexing application
    (e.g. LuceneIndexCreation.jar).
    </para>

    <para>
    Pay attention, that document identity ('path' in our example) is also stored
    in the index and must be retrieved from them.
    </para>

</sect1>

<sect1 id="zend.search.term-query">
    <title>Term Queries</title>

    <para>
    Term queries are intended for a searching for a single term.
    </para>

    <para>
    Both of a search method can be used for term queries.
    </para>

    <para>
    Query string:
    <programlisting role="php"><![CDATA[
$hits = $index->find('word1');]]>
    </programlisting>
    </para>

    <para>or</para>

    <para>
    Query construction by API:
    <programlisting role="php"><![CDATA[
$term  = new ZSearchTerm('word1');
$query = new ZSearchTermQuery($term);
$hits  = $index->find($query);]]>
    </programlisting>
    </para>

</sect1>

<sect1 id="zend.search.multiterm-query">
    <title>Multi Term Queries</title>

    <para>
    Multi term queries are intended for a searching for a set of terms.
    </para>

    <para>
    Each term in a set can be defined as required, prohibited or neither
    required, nor prohibited (optional).

    <itemizedlist>
        <listitem>
            <para>
            required which means that documents which do not match this term
            will not match the query;
            </para>
        </listitem>
        <listitem>
            <para>
            prohibited which means that documents which do match this term
            will not match the query;
            </para>
        </listitem>
        <listitem>
            <para>
            neither, in which case matched documents are neither prohibited from
            nor required to match the term. However, a document must match at least
            1 term to match the query.
            </para>
        </listitem>
    </itemizedlist>
    </para>

    <para>
    It means, that if optional terms are added to a query with required terms,
    then they will have the same result set, but second query will have hits,
    which match optional terms, moved to the top of result set.
    </para>

    <para>
    Both of a search method can be used for multi term queries.
    </para>

    <para>
    Query string:
    <programlisting role="php"><![CDATA[
$hits = $index->find('+word1 author:word2 -word3');]]>
    </programlisting>

    <itemizedlist>
        <listitem>'+' is used to define required term.</listitem>
        <listitem>'-' is used to define prohibited term.</listitem>
        <listitem>
        'field:' prefix is used to indicate document field for a search.
        If it's omitted, then 'contents' is used.
        </listitem>
    </itemizedlist>
    </para>

    <para>or</para>

    <para>
    Query construction by API:
    <programlisting role="php"><![CDATA[
$query = new ZSearchMultiTermQuery();

$query->addTerm(new ZSearchTerm('word1'), true);
$query->addTerm(new ZSearchTerm('word2'), null);
$query->addTerm(new ZSearchTerm('word3'), false);

$hits  = $index->find($query);]]>
    </programlisting>

    <para>
        <code>$signs</code> array contains an information about term type:
    <itemizedlist>
        <listitem>true is used to define required term.</listitem>
        <listitem>false is used to define prohibited term.</listitem>
        <listitem>
        null is used to define neither required,
        nor prohibited term.
        </listitem>
    </itemizedlist>
    </para>

    </para>

</sect1>

<sect1 id="zend.search.phrase-query">
    <title>Phrase Queries</title>

    <para>
    Phrase Queries are intended for a searching for a phrases.
    </para>

    <para>
    Phrase Queries are very flexible and allow to search exact phrases as well as sloppy phrases.
    Exact phrases can also contain gaps or terms in the same places. (It can be generated by Analyser for different
    purposes. Ex. term can be duplicated to increase term weight or several synonyms can be placed into one position).
    According to this phrase queries can be constructed only by API now:
    </para>

    <programlisting role="php"><![CDATA[
$query1 = new ZSearchPhraseQuery();

$query1->addTerm(new ZSearchTerm('word1'));     // Add 'word1' at 0 relative position.
$query1->addTerm(new ZSearchTerm('word2'));     // Add 'word2' at 1 relative position.
$query1->addTerm(new ZSearchTerm('word3'), 3);  // Add 'word3' at 3 relative position.

...

$query2 = new ZSearchPhraseQuery(array('word1', 'word2', 'word3'), array(0,1,3));

...

// Query without a gap.
$query3 = new ZSearchPhraseQuery(array('word1', 'word2', 'word3'));

...

$query4 = new ZSearchPhraseQuery(array('word1', 'word2'), array(0,1), 'annotation');]]>
    </programlisting>

    <para>
    Sloop factor sets the number of other words permitted between words in query phrase. If zero,
    then this is an exact phrase search.  For larger values this works like a WITHIN or NEAR operator.
    </para>
    <para>
    The slop is in fact an edit-distance, where the units correspond to moves of terms in the query phrase
    out of position.  For example, to switch the order of two words requires two moves (the first move places
    the words atop one another), so to permit re-orderings of phrases, the slop must be at least two.
    </para>
    <para>
    More exact matches are scored higher than sloppier matches, thus search results are sorted by exactness.
    The slop is zero by default, requiring exact matches.
    </para>
    <para>
    Sloop factor can be assigned after query creation:
    </para>
    <programlisting role="php"><![CDATA[
// Query without a gap.
$query = new ZSearchPhraseQuery(array('word1', 'word2'));

// Search for 'word1 word2', 'word1 ... word2'
$query->setSlop(1);
$hits1 = $index->find($query);

// Search for 'word1 word2', 'word1 ... word2', 'word1 ... ... word2', 'word2 word1'
$query->setSlop(2);
$hits2 = $index->find($query);]]>
    </programlisting>

</sect1>

<sect1 id="zend.search.scoring-API">
    <title>Scoring API</title>

    <para>
    The score of query <literal>q</literal> for document <literal>d</literal>
    is defined as follows:
    </para>

    <para>
    <code>score(q,d) = sum( tf(t in d) * idf(t) * getBoost(t.field in d) * lengthNorm(t.field in d)  ) *
    coord(q,d) * queryNorm(q)</code>
    </para>

    <para>
    tf(t in d) - <code>ZSearchSimilarity::tf($freq)</code> - a score factor based on a term or phrase's frequency in a document.
    </para>

    <para>
    idf(t) - <code>ZSearchSimilarity::tf($term, $reader)</code> - a score factor for a simple term for the specified index.
    </para>

    <para>
    getBoost(t.field in d) - boost factor for the term field.
    </para>

    <para>
    lengthNorm($term) - the normalization value for a field given the total
    number of terms contained in a field. This value is stored within the index.
    These values, together with field boosts, are stored in an index and multiplied
    into scores for hits on each field by the search code.
    </para>
    <para>
    Matches in longer fields are less precise, so implementations of this method
    usually return smaller values when numTokens is large, and larger values when numTokens is small.
    </para>

    <para>
    coord(q,d) - <code>ZSearchSimilarity::coord($overlap, $maxOverlap)</code> - a score
    factor based on the fraction of all query terms that a document contains.
    </para>

    <para>
    The presence of a large portion of the query terms indicates a better match
    with the query, so implementations of this method usually return larger values
    when the ratio between these parameters is large and smaller values when
    the ratio between them is small.
    </para>

    <para>
    queryNorm(q) -  the normalization value for a query given the sum of the squared weights
    of each of the query terms. This value is then multiplied into the weight of each query
    term.
    </para>

    <para>
    This does not affect ranking, but rather just attempts to make scores from different
    queries comparable.
    </para>

    <para>
    Scoring algorithm can be customized by defining your own Similatity class. To do this
    extend ZSearchSimilarity class as defined below, then use
    <code>ZSearchSimilarity::setDefault($similarity);</code> method to set it as default.
    </para>

    <programlisting role="php"><![CDATA[
class MySimilarity extends ZSearchSimilarity {
    public function lengthNorm($fieldName, $numTerms) {
        return 1.0/sqrt($numTerms);
    }

    public function queryNorm($sumOfSquaredWeights) {
        return 1.0/sqrt($sumOfSquaredWeights);
    }

    public function tf($freq) {
        return sqrt($freq);
    }

    /**
     * It's not used now. Computes the amount of a sloppy phrase match,
     * based on an edit distance.
     */
    public function sloppyFreq($distance) {
        return 1.0;
    }

    public function idfFreq($docFreq, $numDocs) {
        return log($numDocs/(float)($docFreq+1)) + 1.0;
    }

    public function coord($overlap, $maxOverlap) {
        return $overlap/(float)$maxOverlap;
    }
}

$mySimilarity = new MySimilarity();
ZSearchSimilarity::setDefault($mySimilarity);
]]>
    </programlisting>

</sect1>

<sect1 id="zend.search.storage">
    <title>Storage API</title>

    <para>
    An abstract class ZSearchDirectory defines directory functionality.
    </para>

    <para>
    The ZSearch constructor uses either a string or ZSearchDirectory object
    as an input.
    </para>

    <para>
    ZSearchDirectoryFilesystem class implements directory functionality for file system.
    </para>

    <para>
    If string is used as an input for the ZSearch constructor, then the index reader
    (ZSearch object) treats it as a file system path and instantiates
    ZSearchDirectoryFilesystem object by themselves.
    </para>

    <para>
    You can define your own directory implementation by extending ZSearchDirectory class.
    </para>

    <para>
    ZSearchDirectory methods:

    <programlisting><![CDATA[
abstract class ZSearchDirectory {
    /**
     * Closes the store.
     *
     * @return void
     */
    abstract function close();


    /**
     * Creates a new, empty file in the directory with the given $filename.
     *
     * @param string $name
     * @return void
     */
    abstract function createFile($filename);


    /**
     * Removes an existing $filename in the directory.
     *
     * @param string $filename
     * @return void
     */
    abstract function deleteFile($filename);


    /**
     * Returns true if a file with the given $filename exists.
     *
     * @param string $filename
     * @return boolean
     */
    abstract function fileExists($filename);


    /**
     * Returns the length of a $filename in the directory.
     *
     * @param string $filename
     * @return integer
     */
    abstract function fileLength($filename);


    /**
     * Returns the UNIX timestamp $filename was last modified.
     *
     * @param string $filename
     * @return integer
     */
    abstract function fileModified($filename);


    /**
     * Renames an existing file in the directory.
     *
     * @param string $from
     * @param string $to
     * @return void
     */
    abstract function renameFile($from, $to);


    /**
     * Sets the modified time of $filename to now.
     *
     * @param string $filename
     * @return void
     */
    abstract function touchFile($filename);


    /**
     * Returns a ZSearchFile object for a given $filename in the directory.
     *
     * @param string $filename
     * @return ZSearchFile
     */
    abstract function getFileObject($filename);

}]]>
    </programlisting>
    </para>

    <para>
    <code>getFileObject($filename)</code> method of ZSearchDirectory class returns
    ZSearchFile object.
    </para>
    <para>
    ZSearchFile abstract class implements file abstraction and index file reading
    primitives.
    </para>
    <para>
    You must also extend ZSearchFile class for your Directory implementation.
    </para>
    <para>
    Only two methods of ZSearchFile class must be overloaded in your implementation:

    <programlisting><![CDATA[
class MyZSearchFile extends ZSearchFile {
    /**
     * Sets the file position indicator and advances the file pointer.
     * The new position, measured in bytes from the beginning of the file,
     * is obtained by adding offset to the position specified by whence,
     * whose values are defined as follows:
     * SEEK_SET - Set position equal to offset bytes.
     * SEEK_CUR - Set position to current location plus offset.
     * SEEK_END - Set position to end-of-file plus offset. (To move to
     * a position before the end-of-file, you need to pass a negative value
     * in offset.)
     * Upon success, returns 0; otherwise, returns -1
     *
     * @param integer $offset
     * @param integer $whence
     * @return integer
     */
    public function seek($offset, $whence=SEEK_SET) {
        ...
    }

    /**
     * Read a $length bytes from the file and advance the file pointer.
     *
     * @param integer $length
     * @return string
     */
    protected function _fread($length=1) {
        ...
    }]]>
    </programlisting>
    </para>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->